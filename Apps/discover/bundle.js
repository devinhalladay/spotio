(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  "app.name": "Entdecken",
  "header.name": "Browse",
  "story.reason.label": "ähnlich wie",
  "offlineTitle": "Entdecken Nicht offline verfügbar",
  "offlineMessage": "Geh zum Laden online.",
  "errorTitle": "Fehler",
  "errorMessage": "Fehler beim Laden",
  "emptyTitle": "Fang mit Deiner Lieblingsmusik an.",
  "emptyMessage": "Sobald Du anfängst zu hören, schlagen wir Dir basierend auf Deiner Auswahl neue Musik vor. Stöber auch in unseren fertigen Playlists und lass Dich inspirieren.",
  "emptyButton": "Playlists durchstöbern"
};
},{}],2:[function(require,module,exports){
module.exports = {
  "app.name": "Ανακάλυψε",
  "header.name": "Περιήγηση",
  "story.reason.label": "μοιάζει με",
  "offlineTitle": "«Ανακάλυψε»: δεν είναι διαθέσιμο εκτός σύνδεσης",
  "offlineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
  "errorTitle": "Σφάλμα",
  "errorMessage": "Η φόρτωση απέτυχε.",
  "emptyTitle": "Για να ξεκινήσεις, άκουσε ένα αγαπημένο σου κομμάτι.",
  "emptyMessage": "Μόλις αρχίσεις να ακούς, θα σου προτείνουμε νέες μουσικές με βάση τις επιλογές σου. Εξερεύνησε τις έτοιμες λίστες μας για να εμπνευστείς.",
  "emptyButton": "Κάνε περιήγηση στις λίστες"
};
},{}],3:[function(require,module,exports){
module.exports = {
  "app.name": "Discover",
  "header.name": "Browse",
  "story.reason.label": "similar to",
  "offlineTitle": "Discover Not Available Offline",
  "offlineMessage": "Please go online to load.",
  "errorTitle": "Error",
  "errorMessage": "Failed to load.",
  "emptyTitle": "To get started, play something you love.",
  "emptyMessage": "Once you start listening, we’ll suggest new music based on your choices. Explore our readymade playlists for inspiration.",
  "emptyButton": "Browse playlists"
};
},{}],4:[function(require,module,exports){
module.exports = {
  "app.name": "Descubre",
  "header.name": "Explorar",
  "story.reason.label": "similar a",
  "offlineTitle": "Descubrir no está disponible sin conexión",
  "offlineMessage": "Conéctate a la red para cargar.",
  "errorTitle": "Error",
  "errorMessage": "No se pudo cargar.",
  "emptyTitle": "Para empezar, reproduce algo que te encanta.",
  "emptyMessage": "Una vez que empieces a escuchar, te sugeriremos nueva música basada en tus elecciones. Explora nuestras playlists confeccionadas para encontrar inspiración.",
  "emptyButton": "Explora las playlists"
};
},{}],5:[function(require,module,exports){
module.exports = {
  "app.name": "Descubrir",
  "header.name": "Explorar",
  "story.reason.label": "similar a",
  "offlineTitle": "La función de Descubrir no está disponible sin conexión",
  "offlineMessage": "Por favor, conéctate para cargar.",
  "errorTitle": "Error",
  "errorMessage": "No se ha logrado cargar.",
  "emptyTitle": "Para empezar, escucha algo que te guste.",
  "emptyMessage": "Una vez que empieces a escuchar, te sugeriremos más música basándonos en lo que tú elijas. También puedes explorar nuestras playlists ya hechas e inspirarte en ellas.",
  "emptyButton": "Explorar playlists"
};
},{}],6:[function(require,module,exports){
module.exports = {
  "app.name": "Discover",
  "header.name": "Browse",
  "story.reason.label": "samanlainen kuin",
  "offlineTitle": "Discover-toimintoa ei voi käyttää offline-tilassa",
  "offlineMessage": "Siirry online-tilaan, jotta voit ladata.",
  "errorTitle": "Virhe",
  "errorMessage": "Lataus epäonnistui.",
  "emptyTitle": "Aloita kuuntelemalla jotain, mistä pidät.",
  "emptyMessage": "Kun aloitat kuuntelun, ehdotamme uutta musiikkia valintojesi perusteella. Voit löytää uusia ideoita valmiista soittolistoistamme.",
  "emptyButton": "Selaa soittolistoja"
};
},{}],7:[function(require,module,exports){
module.exports = {
  "app.name": "Découvrir",
  "header.name": "Parcourir",
  "story.reason.label": "semblable à",
  "offlineTitle": "La fonctionnalité Découvertes n'est pas accesisble hors ligne",
  "offlineMessage": "Veuillez accéder à Internet pour charger le contenu.",
  "errorTitle": "Erreur",
  "errorMessage": "Le chargement a échoué.",
  "emptyTitle": "Pour commencer, écoutez quelque chose que vous adorez.",
  "emptyMessage": "Lorsque vous aurez commencé à écouter de la musique, nous vous ferons des suggestions en fonction de vos choix. Puisez de l'inspiration dans nos listes de lecture toutes faites.",
  "emptyButton": "Parcourir les listes de lecture"
};
},{}],8:[function(require,module,exports){
module.exports = {
  "app.name": "Découvertes",
  "header.name": "Parcourir",
  "story.reason.label": "similaire à",
  "offlineTitle": "La page Découvrir n'est pas disponible hors connexion.",
  "offlineMessage": "Connectez-vous pour procéder au chargement.",
  "errorTitle": "Erreur",
  "errorMessage": "Échec du chargement.",
  "emptyTitle": "Pour commencer, écoutez la musique que vous adorez.",
  "emptyMessage": "Dès que vous commencez l'écoute, nous vous proposons de la musique à partir de vos choix. Explorez nos playlists toutes faites dont vous pourrez vous inspirez.",
  "emptyButton": "Parcourir les playlists"
};
},{}],9:[function(require,module,exports){
module.exports = {
  "app.name": "Felfedezés",
  "header.name": "Böngészés",
  "story.reason.label": "hasonló, mint",
  "offlineTitle": "Offline módban nem érhető el a Felfedezés lap",
  "offlineMessage": "Csatlakozz az internethez, majd indítsd el.",
  "errorTitle": "Hiba",
  "errorMessage": "Betöltési hiba.",
  "emptyTitle": "Hallgass meg valamit, amit szeretsz.",
  "emptyMessage": "A szám elindulása után a választásod alapján elkezdünk más számokat ajánlani. Pillants bele lejátszási listáinkba, hogy ihletet kapj.",
  "emptyButton": "Lejátszási listák böngészése"
};
},{}],10:[function(require,module,exports){
module.exports = {
  "app.name": "Temukan",
  "header.name": "Browse",
  "story.reason.label": "serupa dengan",
  "offlineTitle": "Temukan Tidak Tersedia Offline",
  "offlineMessage": "Alihkan ke online untuk memuat.",
  "errorTitle": "Kesalahan",
  "errorMessage": "Gagal memuat.",
  "emptyTitle": "Untuk memulai, mainkan sesuatu yang kamu sukai.",
  "emptyMessage": "Setelah kamu mulai mendengarkan, kami akan menyarankan musik baru berdasarkan pilihanmu. Telusuri playlist yang telah kami siapkan untuk inspirasi.",
  "emptyButton": "Browse playlist"
};
},{}],11:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":259,"./de.lang":1,"./el.lang":2,"./en.lang":3,"./es-419.lang":4,"./es.lang":5,"./fi.lang":6,"./fr-CA.lang":7,"./fr.lang":8,"./hu.lang":9,"./id.lang":10,"./it.lang":12,"./ja.lang":13,"./nl.lang":14,"./pl.lang":15,"./pt-BR.lang":16,"./sv.lang":17,"./tr.lang":18,"./zh-Hant.lang":19,"./zsm.lang":20}],12:[function(require,module,exports){
module.exports = {
  "app.name": "Scopri",
  "header.name": "Naviga",
  "story.reason.label": "simile a",
  "offlineTitle": "Scopri non è disponibile offline",
  "offlineMessage": "Passa online per caricare.",
  "errorTitle": "Errore",
  "errorMessage": "Impossibile caricare.",
  "emptyTitle": "Per iniziare, ascolta qualcosa che ti piace.",
  "emptyMessage": "Una volta iniziato l'ascolto, ti suggeriremo nuova musica basata sulle tue scelte. Esplora le nostre playlist già pronte per trarre ispirazione.",
  "emptyButton": "Naviga tra le playlist"
};
},{}],13:[function(require,module,exports){
module.exports = {
  "app.name": "ディスカバー",
  "header.name": "Browse",
  "story.reason.label": "これも聴いてみる？",
  "offlineTitle": "ディスカバーはオフラインでは利用できません",
  "offlineMessage": "ロードするには、インターネットに接続してください。",
  "errorTitle": "エラー",
  "errorMessage": "ロードに失敗しました。",
  "emptyTitle": "好きなものを選択して再生を開始してください。",
  "emptyMessage": "再生を開始すると、ユーザーの選択に基づいて、Spotifyが新しい曲を選曲します。インスピレーションを得るために、既成のプレイリストをチェックしてみてください。",
  "emptyButton": "プレイリストをブラウズ"
};
},{}],14:[function(require,module,exports){
module.exports = {
  "app.name": "Ontdekken",
  "header.name": "Bladeren",
  "story.reason.label": "vergelijkbaar met",
  "offlineTitle": "Ontdekken is niet offline beschikbaar",
  "offlineMessage": "Ga online om te laden.",
  "errorTitle": "Fout",
  "errorMessage": "Laden mislukt.",
  "emptyTitle": "Ga aan de slag door iets dat je leuk vindt af te spelen.",
  "emptyMessage": "Wanneer je eenmaal begint met luisteren bevelen we je nieuwe muziek aan gebaseerd op je keuzes. Ontdek onze kant-en-klare afspeellijsten voor inspiratie.",
  "emptyButton": "Blader door afspeellijsten"
};
},{}],15:[function(require,module,exports){
module.exports = {
  "app.name": "Odkryj muzykę",
  "header.name": "Przeglądaj",
  "story.reason.label": "podobne do",
  "offlineTitle": "Funkcja Odkrywaj jest niedostępna w trybie offline",
  "offlineMessage": "Przejdź do trybu online, aby załadować.",
  "errorTitle": "Błąd",
  "errorMessage": "Ładowanie nie powiodło się.",
  "emptyTitle": "Aby zacząć, odtwórz coś, co lubisz.",
  "emptyMessage": "Gdy zaczniesz słuchać, zaproponujemy Ci nowe utwory na podstawie Twojego wyboru. Inspiracją mogą być nasze gotowe playlisty.",
  "emptyButton": "Przeglądaj playlisty"
};
},{}],16:[function(require,module,exports){
module.exports = {
  "app.name": "Descobrir",
  "header.name": "Navegar",
  "story.reason.label": "parecido com",
  "offlineTitle": "Descobrir não disponível offline",
  "offlineMessage": "Fique online para carregar.",
  "errorTitle": "Erro",
  "errorMessage": "Falha no carregamento.",
  "emptyTitle": "Para começar, toque algo que você ama.",
  "emptyMessage": "Depois que começar a ouvir, vamos sugerir novas músicas baseadas em suas escolhas. Explore nossas playlists prontas para se inspirar.",
  "emptyButton": "Navegar pelas playlists."
};
},{}],17:[function(require,module,exports){
module.exports = {
  "app.name": "Upptäck",
  "header.name": "Start",
  "story.reason.label": "liknar",
  "offlineTitle": "Upptäck är inte tillgängligt i offlineläge",
  "offlineMessage": "Anslut till internet om du vill läsa in appen.",
  "errorTitle": "Fel",
  "errorMessage": "Det gick inte att läsa in appen.",
  "emptyTitle": "Sätt igång och lyssna på nåt du gillar.",
  "emptyMessage": "När du börjar lyssna föreslår vi annan musik baserat på dina låtval. Utforska dina färdiga spellistor och bli inspirerad.",
  "emptyButton": "Bläddra igenom spellistor"
};
},{}],18:[function(require,module,exports){
module.exports = {
  "app.name": "Keşfet",
  "header.name": "Gözat",
  "story.reason.label": "benzer",
  "offlineTitle": "Keşfet Çevrimdışı Kullanılamaz",
  "offlineMessage": "Yüklemek için lütfen çevrimiçi ol.",
  "errorTitle": "Hata",
  "errorMessage": "Yüklenemedi.",
  "emptyTitle": "Başlamak için sevdiğin bir şeyler çal.",
  "emptyMessage": "Müzik dinlemeye başladığında sana tercihlerine göre yeni müzikler önereceğiz. İlham almak için hazır çalma listelerimizi keşfet.",
  "emptyButton": "Çalma listelerine göz at"
};
},{}],19:[function(require,module,exports){
module.exports = {
  "app.name": "發掘更多",
  "header.name": "瀏覽",
  "story.reason.label": "類似",
  "offlineTitle": "離線時無法使用發掘功能。",
  "offlineMessage": "請上網以載入。",
  "errorTitle": "錯誤",
  "errorMessage": "載入失敗。",
  "emptyTitle": "播放些你喜愛的歌曲，輕鬆上手！",
  "emptyMessage": "開始收聽後，我們會根據你的選擇建議新音樂。探索現成的播放清單獲得靈感。",
  "emptyButton": "瀏覽播放清單"
};
},{}],20:[function(require,module,exports){
module.exports = {
  "app.name": "Temui",
  "header.name": "Layari",
  "story.reason.label": "serupa dengan",
  "offlineTitle": "Temui Tidak Tersedia di Luar Talian",
  "offlineMessage": "Sila ke online untuk memuatkan.",
  "errorTitle": "Ralat",
  "errorMessage": "Gagal untuk memuatkan.",
  "emptyTitle": "Untuk memulakan, mainkan lagu yang anda suka.",
  "emptyMessage": "Apabila anda mula mendengar, kami akan mencadangkan muzik baru berasaskan pilihan anda. Terokai senarai main siap sedia kami untuk mendapatkan inspirasi.",
  "emptyButton": "Layari senarai main"
};
},{}],21:[function(require,module,exports){
module.exports={
  "name": "discover",
  "version": "2.1.45",
  "description": "show recommendations based on a user's listening history",
  "main": "src/main.js",
  "repository": "https://ghe.spotify.net/discovery/discover-spotlet",
  "directories": {
    "test": "tests"
  },
  "author": "Nova <nova@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}

},{}],22:[function(require,module,exports){
'use strict';

var live = require('../../../libs/spotify-live');
var cosmos = require('../../../libs/spotify-live-models/util/cosmos').cosmos;
var ClientLogger = require('../../../libs/spotify-client-logger');
var OfflineError = require('./offline-error');
var Utils = require('./utils');
var EmptyMessage = require('./empty-message');
var Reason = require('./reason');
var UserInput = require('./user-input');
var pkg = require('../package.json');
var iframeDataAttr = require('./iframe-data-attr');
var iframeResize = require('./iframe-resize');

var URL = 'hm://bartender3/v2/stories?language=LN';
var updatedURL;

/**
 * Creates a new DiscoverController.
 * @param {Object} props A map of properties.
 * @constructor
 */
function DiscoverController(props) {

  var expected = {
    'template': 'function',
    'emptyTemplate': 'function',
    'offlineErrorTemplate': 'function',
    'strings': 'object',
    'contentContainer': 'object',
    'errorContainer': 'object',
    'userInputContainer': 'object'
  };

  Utils.checkExpectedProps(expected, props);

  this.template = props.template;
  this.emptyTemplate = props.emptyTemplate;
  this.offlineErrorTemplate = props.offlineErrorTemplate;
  this.strings = props.strings;
  this.contentContainer = props.contentContainer;
  this.errorContainer = props.errorContainer;
  this.userInputContainer = props.userInputContainer;

  this.clientLogger = new ClientLogger();
  this.clientLogger.setConstant({ source: pkg.name });
}

/**
 * Initializes an instance of DiscoverController.
 * @param {string} language   The current language
 * @param {Function} [opt_callback=]  An optional callback.
 * @param {string} [opt_username=] An optional username.
 */
DiscoverController.prototype.init = function (language, opt_callback, opt_username) {
  if (!language) throw new Error('DiscoverController.init requires language param.');
  var callback = opt_callback || null;
  updatedURL = URL.replace(/LN/, language);
  if (opt_username) {
    updatedURL = updatedURL + '&username=' + opt_username;
  }
  var request = new cosmos.Request('GET', updatedURL);
  var key = this.clientLogger.createTimer('bartender-request');
  if (!this.data || this.userInput) {
    cosmos.resolver.resolve(request, this.handleInit.bind(this, key, callback));
  }
};

/**
 * Handles initialization.
 * @param  {string}   key      A log timer key.
 * @param  {Function} callback A callback.
 * @param  {Object}   error    An error returned from a Cosmos request.
 * @param  {Object}   response A response from a Cosmos request.
 */
DiscoverController.prototype.handleInit = function (key, callback, error, response) {

  this.clientLogger.userImpression({
    event_version: 'initial-view',
    app_version: pkg.version
  });

  if (error) {
    this.fail(key, error);
    return;
  }

  this.contentContainer.innerHTML = '';

  this.data = JSON.parse(response.getBody());
  var logData = {};

  if (!this.data.length) {
    this.showEmptyMessage();
    this.logRequest(key, 'success', 'no-recs');
  } else {
    for (var i = 0, max = this.data.length; i < max; i++) {
      var reason = new Reason(i);
      reason.init(this.data[i]);
      logData[reason.names] = this.data[i].stories.length;
      reason.render(this.contentContainer, this.template);
    }

    this.logRequest(key, 'success', 'none', logData);
  }

  if (callback) callback(this);
};

/**
 * Handles failed requests.
 * @param  {string} opt_key   A logger key.
 * @param  {Object} opt_error An error object.
 */
DiscoverController.prototype.fail = function (opt_key, opt_error) {

  var key = opt_key || '',
      error = opt_error || {};

  this.showError();
  this.logRequest(key, 'fail', error.message);
};

/**
 * Logs the cosmos request
 * @param {String} key
 * @param {String} status
 * @param {String} message
 * @param {Object} opt_data
 */
DiscoverController.prototype.logRequest = function (key, status, message, opt_data) {
  if (!key) {
    return;
  }
  this.clientLogger.logTimer(key, {
    target_uri: updatedURL,
    status: status,
    message: message,
    opt_data: opt_data
  });
};

/**
 * Query app arguments.
 */
DiscoverController.prototype.checkAppArgs = function () {
  live('spotify:application').query('arguments', this.handleCheckAppArgs.bind(this));
};

/**
 * Handles application query.
 * @param  {Object} error     An error object.
 * @param  {Object} data      A map of properties.
 */
DiscoverController.prototype.handleCheckAppArgs = function (error, data) {
  if (error) {
    console.log('query app args error: ', error);
    return;
  } else if (data.arguments && data.arguments.indexOf('userinput') !== -1) {
    this.userInput = new UserInput(this.userInputContainer);
    this.userInput.render(this);
  }
};

/**
 * Shows empty message.
 */
DiscoverController.prototype.showEmptyMessage = function () {
  this.contentContainer.classList.add('empty-container');
  var emptyMessage = new EmptyMessage(this.contentContainer, this.emptyTemplate, this.strings);
  emptyMessage.render();
};

/**
 * Displays the error screen.
 */
DiscoverController.prototype.showError = function () {
  this.errorContainer.parentNode.classList.add('show-error-screen');
  var error = new OfflineError(this.errorContainer, this.offlineErrorTemplate, this.strings);
  error.render();
};

/**
 * Hides error.
 */
DiscoverController.prototype.hideError = function () {
  this.errorContainer.parentNode.classList.remove('show-error-screen');
};

/**
 * Shows offline error.
 */
DiscoverController.prototype.showOffline = function () {
  this.errorContainer.parentNode.classList.add('show-offline-screen');
  var offline = new OfflineError(this.errorContainer, this.offlineErrorTemplate, this.strings);
  offline.render();
  this.hideContent();

  if (iframeDataAttr('embedded')) {
    iframeResize.addResizeListener();
    iframeResize.postIframeHeight();
  }
};

/**
 * Hides offline error.
 */
DiscoverController.prototype.hideOffline = function () {
  this.errorContainer.parentNode.classList.remove('show-offline-screen');
  this.showContent();
};

/**
 * Show content.
 */
DiscoverController.prototype.showContent = function () {
  this.contentContainer.classList.remove('hide');
};

/**
 * Hide content.
 */
DiscoverController.prototype.hideContent = function () {
  this.contentContainer.classList.add('hide');
};

module.exports = DiscoverController;

},{"../../../libs/spotify-client-logger":135,"../../../libs/spotify-live":312,"../../../libs/spotify-live-models/util/cosmos":308,"../package.json":21,"./empty-message":23,"./iframe-data-attr":25,"./iframe-resize":26,"./offline-error":30,"./reason":31,"./user-input":36,"./utils":37}],23:[function(require,module,exports){
'use strict';

var href = require('../../../libs/spotify-handlebars/helpers/href');

/**
 * Creates a new EmptyMessage.
 * @constructor
 * @param {Object} el dom object
 * @param {Function} template handlebars
 * @param {Object} strings
 */
function EmptyMessage(el, template, strings) {
  this.el = el;
  this.template = template;
  this.strings = strings;
}

/**
 * Render the empty message html.
 */
EmptyMessage.prototype.render = function () {
  this.el.innerHTML = this.template({
    errorTitle: this.strings['emptyTitle'],
    errorMessage: this.strings['emptyMessage'],
    errorEscapeMessage: this.strings['emptyButton'],
    errorEscapeUrl: href('spotify:app:browse')
  });
};

module.exports = EmptyMessage;

},{"../../../libs/spotify-handlebars/helpers/href":244}],24:[function(require,module,exports){
(function (global){
'use strict';

/* global global */
var HptoAd = global.UNIT_TEST ? require('../tests/unit/mock/hpto-ad-mock') : require('../../../libs/spotify-ad-formats').HptoAd;
var events = require('../../../libs/spotify-events');
var eventsCenter = require('../../../libs/spotify-events/center');

/**
 * Creates a new Hpto Ad.
 * @constructor
 * @param {String} name of spotlet
 * @param {Object} hpto container dom el
 */
function Hpto(name, el, headerEl) {
  this.hpto = HptoAd.appendTo(el);
  this.headerEl = headerEl;
  this.el = el;
}

/**
 * Render the header name
 */
Hpto.prototype.render = function () {
  var self = this;
  this.hpto.enable();

  eventsCenter.on(HptoAd.AD_HPTO_RENDERED, function () {
    self.hideBrowse();
    events.update(self.el);
  });

  eventsCenter.on(HptoAd.AD_HPTO_HIDDEN, function () {
    self.showBrowse();
  });
};

Hpto.prototype.hideBrowse = function () {
  this.headerEl.className += ' hidden';
};

Hpto.prototype.showBrowse = function () {
  this.headerEl.className = this.headerEl.className.replace(/(?:^|\s)hidden(?!\S)/g, '');
};

module.exports = Hpto;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/spotify-ad-formats":85,"../../../libs/spotify-events":163,"../../../libs/spotify-events/center":150,"../tests/unit/mock/hpto-ad-mock":38}],25:[function(require,module,exports){
"use strict";

module.exports = function iframeDataAttr(name) {
  if (window.frameElement) {
    return window.frameElement.dataset[name];
  }

  return false;
};

},{}],26:[function(require,module,exports){
'use strict';

var iframeDataAttr = require('./iframe-data-attr');
var hasAddedResizeListener = false;

function postIframeHeight() {
  if (!window || typeof window.parent === 'undefined') {
    return;
  }

  var isOffline = document.body.classList.contains('show-offline-screen');
  var height = isOffline ? window.parent.window.innerHeight : document.querySelector('.online-container').clientHeight;

  window.parent.postMessage({
    name: iframeDataAttr('postMessageName'),
    uri: window.frameElement.src,
    height: height
  }, iframeDataAttr('origin'));
}

function addResizeListener() {
  if (hasAddedResizeListener) {
    return;
  }

  hasAddedResizeListener = true;
  window.parent.addEventListener('resize', postIframeHeight, false);
}

exports.postIframeHeight = postIframeHeight;
exports.addResizeListener = addResizeListener;

},{"./iframe-data-attr":25}],27:[function(require,module,exports){
'use strict';

var iframeDataAttr = require('./iframe-data-attr');

exports.render = function render(params) {
  var headerContainer = document.querySelector('.main-header');
  var hptoContainer = document.querySelector('#hpto');
  var browseNavContainer = document.querySelector('#browseNav');

  if (iframeDataAttr('embedded')) {
    document.documentElement.style.overflow = 'hidden';
    headerContainer.style.display = 'none';
    hptoContainer.style.display = 'none';
    browseNavContainer.style.display = 'none';
    return;
  }

  // Main header
  var header = new params.Header(headerContainer, params.i18n);
  header.render();

  // Hpto Ad
  var hpto = new params.HptoAd('discover', hptoContainer, headerContainer);
  hpto.render();

  // Navbar
  params.live('spotify:client').query('session(language)', function (error, data) {
    var language = 'en';
    if (data.session && data.session.language) {
      language = data.session.language;
    }
    params.browseNavbar.init('browseNav', 'discover', params.cosmos, language);
  });
};

},{"./iframe-data-attr":25}],28:[function(require,module,exports){
'use strict';

/**
 * Creates a new Header.
 * @constructor
 * @param {Object} el dom object
 * @param {Object} strings
 */
function Header(el, strings) {
  this.el = el;
  this.strings = strings;
}

/**
 * Render the header name
 */
Header.prototype.render = function () {
  this.el.innerHTML = this.strings['header.name'];
};

module.exports = Header;

},{}],29:[function(require,module,exports){
'use strict';

var pkg = require('../package.json');
var bridge = require('../../../libs/spotify-bridge-request');

var glue = require('../../../libs/spotify-glue-cat');
glue.gridOverlay.listen();

var live = require('../../../libs/spotify-live');
var events = require('../../../libs/spotify-events');
var liveModels = require('../../../libs/spotify-live-models');
var cosmos = require('spotify-cosmos-api');

require('../../../libs/spotify-live-models/client-storage').register();
require('../../../libs/spotify-live-models/session-storage').register();
require('../../../libs/spotify-live-models/list-variant').register();
liveModels.register();

// Required to register the handlebars helpers that are used by the templates below.
var hbs = require('../../../libs/spotify-handlebars');
var helpers = require('../../../libs/spotify-handlebars/helpers');
var i18n = require('../i18n/index');
var glueStrings = i18n.glueStrings();
var appStrings = i18n.appStrings();

helpers.loc.register(glueStrings);
helpers.loc.register(appStrings);
helpers.numeral.setLocale(i18n.locale());
hbs.register(helpers);

// Templates
var template = require('./templates/section-divider.hbs');
var emptyTemplate = require('./templates/empty-state.hbs');
var offlineErrorTemplate = require('../../../libs/spotify-glue-cat/templates/v1/error-and-offline.hbs');

// DOM Logging
var DomLogger = require('../../../libs/spotify-dom-logger');
new DomLogger().init();

var iframeDataAttr = require('./iframe-data-attr');
var iframeResize = require('./iframe-resize');

var mainContainer = require('./main-container');
mainContainer.render({
  i18n: appStrings,
  live: live,
  cosmos: cosmos,
  Header: require('./main-header'),
  HptoAd: require('./hpto-ad'),
  browseNavbar: require('../../../libs/browse-navbar')
});

// Containers
var contentContainer = document.getElementById('content-container');
var errorContainer = document.querySelector('.offline-container');
var userInputContainer = document.getElementById('usernameForm');

// Controller
var DiscoverController = require('./discover-controller.js');
var disc = new DiscoverController({
  'template': template,
  'emptyTemplate': emptyTemplate,
  'offlineErrorTemplate': offlineErrorTemplate,
  'strings': appStrings,
  'contentContainer': contentContainer,
  'errorContainer': errorContainer,
  'userInputContainer': userInputContainer
});

var Runner = require('./runner');
var runner = new Runner();
runner.run(disc, function () {
  events.attach();
  events.update();

  if (iframeDataAttr('embedded')) {
    iframeResize.addResizeListener();
    iframeResize.postIframeHeight();
  }
});

require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/live').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos').init();

},{"../../../libs/browse-navbar":59,"../../../libs/spotify-bridge-request":134,"../../../libs/spotify-dom-logger":137,"../../../libs/spotify-events":163,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":205,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":206,"../../../libs/spotify-expose-dev-mode-debug-globals/live":208,"../../../libs/spotify-glue-cat":228,"../../../libs/spotify-glue-cat/templates/v1/error-and-offline.hbs":232,"../../../libs/spotify-handlebars":256,"../../../libs/spotify-handlebars/helpers":246,"../../../libs/spotify-live":312,"../../../libs/spotify-live-models":276,"../../../libs/spotify-live-models/client-storage":273,"../../../libs/spotify-live-models/list-variant":277,"../../../libs/spotify-live-models/session-storage":288,"../i18n/index":11,"../package.json":21,"./discover-controller.js":22,"./hpto-ad":24,"./iframe-data-attr":25,"./iframe-resize":26,"./main-container":27,"./main-header":28,"./runner":32,"./templates/empty-state.hbs":34,"./templates/section-divider.hbs":35,"spotify-cosmos-api":554}],30:[function(require,module,exports){
'use strict';

/**
 * Creates a new OfflineError.
 * @constructor
 * @param {Object} el dom object
 * @param {Function} template handlebars
 * @param {Object} strings
 */
function OfflineError(el, template, strings) {
  this.el = el;
  this.template = template;
  this.strings = strings;
}

/**
 * Render the offline and error message html
 */
OfflineError.prototype.render = function () {
  this.el.innerHTML = this.template({
    offlineTitle: this.strings['offlineTitle'],
    offlineMessage: this.strings['offlineMessage'],
    errorTitle: this.strings['errorTitle'],
    errorMessage: this.strings['errorMessage']
  });
};

module.exports = OfflineError;

},{}],31:[function(require,module,exports){
'use strict';

var Story = require('./story');

/**
 * Creates a new Reason.
 * @param {Number} index Indicates a parent reason container.
 */
function Reason(index) {
  if (typeof index === 'undefined') throw new Error('New Reasons require an index.');
  this.index = index;
}

/**
 * Initializes a Reason.
 * @param {Object} data A map of properties describing a story.
 */
Reason.prototype.init = function (data) {
  this.title = this.format(this.addIndices(data.reason.text), this.getArtistHTML(data.reason));
  var artistNames = this.getArtistNames(data.reason);
  this.names = artistNames.length > 0 ? artistNames.toString() : data.reason.text;
  this.stories = [];
  for (var i = 0, max = data.stories.length; i < max; i++) {
    var story = new Story(i);
    story.init(data.stories[i]);
    this.stories.push(story);
  }
};

/**
 * Iterates over reason and returns an array of html snippets
 * representing artist links.
 * @param  {Object} data A map of properties.
 * @return {Object}      An array of artist html snippets.
 */
Reason.prototype.getArtistHTML = function (reason) {
  var html = [],
      fields = reason.fields;
  for (var i = 0, max = fields.length; i < max; i++) {
    html.push('<a href="' + fields[i].uri + '">' + fields[i].name + '</a>');
  }
  return html;
};

/**
 * Iterates over reason and returns an array of artist names.
 * @param  {Object} data A map of properties.
 * @return {Object}      An array of artist names.
 */
Reason.prototype.getArtistNames = function (reason) {
  var names = [],
      fields = reason.fields;
  for (var i = 0, max = fields.length; i < max; i++) {
    if (fields[i].name) {
      names.push(fields[i].name);
    }
  }
  return names;
};

/**
 * Inserts numbers inside a pattern representing
 * the pattern's order in the passed string.
 * @param {string} str A string.
 */
Reason.prototype.addIndices = function (str) {
  var i = 0;
  return str.replace(/{}/g, function () {
    return '{' + i++ + '}';
  });
};

/**
 * Formats a string with passed arguments.
 * @param  {string} str  A string to format.
 * @param  {Object} args Items to use in formatting the string.
 * @return {string}      A formatted string.
 */
Reason.prototype.format = function (str, args) {
  return str.replace(/{(\d+)}/g, this.replacer.bind(this, args));
};

/**
 * Returns an entry from the passed arguments.
 * @param  {string} match The matched pattern.
 * @param  {string} index The contents within the pattern.
 * @return {string}       A entry from the passed args array.
 */
Reason.prototype.replacer = function (args, match, number) {
  return typeof args[number] != 'undefined' ? args[number] : match;
};

/**
 * Renders a Reason.
 * @param  {Object}   container A parent dom element.
 * @param  {Function} template  A template.
 */
Reason.prototype.render = function (container, template) {
  container.insertAdjacentHTML('beforeend', template(this));
};

module.exports = Reason;

},{"./story":33}],32:[function(require,module,exports){
'use strict';

var live = require('../../../libs/spotify-live');
var iframeDataAttr = require('./iframe-data-attr');

/**
 * Creates a new Runner.
 *
 * A Runner kicks off an app and handles initial
 * client session before making any backend queries.
 * Also sets up and handles a session listener for
 * any changes on the session (ie. online/offline).
 * @constructor
 */
function Runner() {}

/**
 * Queries client session.
 * @param  {Object}   disc     A discover controller.
 * @param  {Function} callback A callback function.
 */
Runner.prototype.run = function (disc, callback) {
  live('spotify:client').query('session(developer, online, language)', this.handleRun.bind(this, disc, callback));
};

/**
 * Handles session properties query.
 * @param  {Object}   disc     A discover controller.
 * @param  {Function} callback A callback function.
 * @param  {Object}   error    An error object.
 * @param  {Object}   data     A map of properties.
 */
Runner.prototype.handleRun = function (disc, callback, error, data) {
  if (!data || !data.session) {
    return;
  }

  var language = data.session.language || 'en'; // english as the default.

  this.setUpSessionListener(disc, language, callback);

  if (!data.session.online) {
    disc.showOffline();
  } else {
    disc.init(language, callback);
  }

  if (data.session.developer) {
    disc.checkAppArgs();
  }
};

/**
 * Listens for updates on client session.
 * @param {Object} disc       A discover controller
 * @param {string} language   The current language
 * @param {Function} callback A callback
 */
Runner.prototype.setUpSessionListener = function (disc, language, callback) {
  live('spotify:client').get('session').on('update', this.handleSessionListener.bind(this, disc, language, callback));
};

/**
 * Handles events from client listener.
 * @param {string} language   The current language
 * @param {Function} callback A callback
 * @param  {Object} properties A map of properties.
 */
Runner.prototype.handleSessionListener = function (disc, language, callback, properties) {
  if (!properties || typeof properties.online === 'undefined') {
    return;
  }

  if (properties.online) {
    disc.hideOffline();
    disc.init(language, callback);
  } else if (!iframeDataAttr('embedded')) {
    disc.showOffline();
  }
};

module.exports = Runner;

},{"../../../libs/spotify-live":312,"./iframe-data-attr":25}],33:[function(require,module,exports){
'use strict';

/**
 * Creates a new Story.
 * @param {Number} index Indicates a parent reason container.
 */
function Story(index) {
  if (typeof index === 'undefined') throw new Error('New Stories require an index.');
  this.index = index;
}

/**
 * Initializes a Story.
 * @param {Object} story A map of properties describing a story.
 */
Story.prototype.init = function (story) {
  this.uri = story.titleUri;
  this.url = story.titleUri;
  this.imageUrl = story.imageUrl;
  this.name = story.title;
  this.title = story.title;
  this.artists = [{
    'uri': story.subtitleUri,
    'name': story.subtitle
  }];
  this.playable = true;
};

module.exports = Story;

},{}],34:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <a class=\"button button-white\" href=\"";
  if (helper = helpers.errorEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"error-escape\">";
  if (helper = helpers.errorEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n  ";
  return buffer;
  }

  buffer += " <div class=\"empty-content\">\n  <h1 class=\"hdr-l\">";
  if (helper = helpers.errorTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n  <div class=\"message\">";
  if (helper = helpers.errorMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>";
  return buffer;
  });

},{"hbsfy/runtime":403}],35:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../libs/spotify-glue-cat/templates/v1/media-object.hbs');
HandlebarsCompiler.registerPartial('../../../../libs/spotify-glue-cat/templates/v1/media-object.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      --><div class=\"col-xs-4 col-sm-4 col-md-3 col-lg-2 media-object crsl-item\" data-log-context=\"item-";
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        ";
  stack1 = self.invokePartial(partials['../../../../libs/spotify-glue-cat/templates/v1/media-object.hbs'], '../../../../libs/spotify-glue-cat/templates/v1/media-object.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div><!--\n    ";
  return buffer;
  }

  buffer += "<div class=\"section-divider\" data-log-context=\"section-";
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "/";
  if (helper = helpers.names) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.names); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <h1>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</h1>\n  <div class=\"section-auxiliary\">\n    <button class=\"button button-icon-only spoticon-chevron-left-16\"\n        data-carousel=\"";
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "-carousel\" data-button=\"carousel-left\"></button>\n    <button class=\"button button-icon-only spoticon-chevron-right-16\"\n        data-carousel=\"";
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "-carousel\" data-button=\"carousel-right\"></button>\n  </div>\n</div>\n<div class=\"carousel\" data-carousel=\"";
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "-carousel\" data-carousel-main data-log-context=\"section-";
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "/";
  if (helper = helpers.names) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.names); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <div class=\"row\">\n    <div class=\"crsl-inner\" data-carousel-inner><!-- leave these comments (needed to make the carousel align)\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.stories) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.stories); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.stories) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  --></div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"../../../../libs/spotify-glue-cat/templates/v1/media-object.hbs":235,"hbsfy/runtime":403}],36:[function(require,module,exports){
'use strict';

/**
 * Creates new UserInput for looking up other
 * users' recommendations.
 * @constructor
 * @param {Object} container A dom element.
 */
function UserInput(container) {
  if (!container) throw new Error('A new UserInput requires a passed container.');
  this.container = container;
}

/**
 * Renders the input field and button.
 * @param  {Object} controller A discover controller.
 */
UserInput.prototype.render = function (controller) {
  this.container.style.display = 'block';
  var button = this.container.querySelector('button');
  var input = this.container.querySelector('input');
  button.addEventListener('click', this.handleClick.bind(this, input, controller), false);
};

/**
 * Handles click.
 * @param  {Object} input      A form input.
 * @param  {Object} controller A discover controller.
 * @param  {Object} e          An event object.
 */
UserInput.prototype.handleClick = function (input, controller, e) {
  e.preventDefault();
  controller.init('en', null, encodeURIComponent(input.value));
};

module.exports = UserInput;

},{}],37:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/**
 * Utility functions.
 * @namespace
 */
var Utils = {

  /**
   * Checks an expected map of properties against a passed map of properties.
   * @memberOf Utils
   * @param   {Object}     expected A map of properties.
   * @param   {Object}     props    A map of properties.
   * @returns {Boolean}    True if properties match.
   * @throws Will throw an error if properties do not match.
   */
  checkExpectedProps: function checkExpectedProps(expected, props) {
    var msg = '';
    for (var i in expected) {
      if (expected.hasOwnProperty(i) && (!props[i] || _typeof(props[i]) !== expected[i])) {
        msg += 'Expected property \"' + i + '\" of type ' + expected[i] + '. ';
      }
    }
    if (msg) throw new Error(msg);
    return true;
  }
};

module.exports = Utils;

},{}],38:[function(require,module,exports){
'use strict';

var HptoAd = {};
HptoAd.appendTo = function () {
  return HptoAd;
};
HptoAd.enable = function () {};
HptoAd.AD_HPTO_RENDERED = 'ad:hpto:rendered';
HptoAd.AD_HPTO_HIDDEN = 'ad:hpto:hidden';

module.exports = HptoAd;

},{}],39:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== 'undefined') {
  var has = require('ramda/src/has');
  var rType = require('ramda/src/type');
  var equals = require('ramda/src/equals');
  var contains = require('ramda/src/contains');
  var all = require('ramda/src/all');
  var pluck = require('ramda/src/pluck');
}

function isString(a) {
  return rType(a) === 'String';
}
function isObject(a) {
  return rType(a) === 'Object';
}
function isNull(a) {
  return rType(a) === 'Null';
}
function isUndefined(a) {
  return a === void 0;
}
function isNumber(a) {
  return rType(a) === 'Number';
}
function isBoolean(a) {
  return rType(a) === 'Boolean';
}

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};

var hexRegEx = /([0-9]|[a-f]|[A-F])/gm;

AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function InvalidSchemaError(msg) {
  return new Error('InvalidSchemaError: ' + msg);
};
var InvalidProtocolError = function InvalidProtocolError(msg) {
  return new Error('InvalidProtocolError: ' + msg);
};
var ValidationError = function ValidationError(msg) {
  return new Error('ValidationError: ' + msg);
};
var ProtocolValidationError = function ProtocolValidationError(msg) {
  return new Error('ProtocolValidationError: ' + msg);
};

function Record(name, namespace, fields, typeName) {
  function validateArgs(name, namespace, fields) {
    if (!isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!isNull(namespace) && !isUndefined(namespace) && !isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!Array.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.typeName = typeName;
  this.namespace = namespace;
  this.fields = fields;
}

function isHex(input) {
  return typeof input === 'string' && (input.match(hexRegEx) || []).length === input.length;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (isString(schema)) {
    typeName = schema;
  } else if (isObject(schema)) {
    if (isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (isString(schema.name)) {
      typeName = schema.name;
    } else if (isString(schema.type)) {
      typeName = schema.type;
    }
    /** BEGIN CHANGE BY drewp **/
    else if (has('valueSchema', schema) && isString(schema.valueSchema.type)) {
        typeName = schema.typeName;
      }
    /** END CHANGE BY drewp **/
  } else {
    throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (!isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (contains(typeName, AvroSpec.PrimitiveTypes)) {
    return typeName;
  } else if (isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace, typeName) {
  this.branchNames = function () {
    return typeSchemas.map(function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!Array.isArray(typeSchemas) || !typeSchemas.length) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.typeName = typeName;
  this.namespace = namespace;
}

function Enum(symbols, typeName) {

  function validateArgs(symbols) {
    if (!Array.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!all(function (symbol) {
      return isString(symbol);
    }, symbols)) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
  this.typeName = typeName;
}

function AvroArray(itemSchema, typeName) {

  function validateArgs(itemSchema) {
    if (isNull(itemSchema) || isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
  this.typeName = typeName;
}

function Map(valueSchema, typeName) {
  function validateArgs(valueSchema) {
    if (isNull(valueSchema) || isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
  this.typeName = typeName;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!contains(type, AvroSpec.PrimitiveTypes)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function _validate(schema, obj, fieldName) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj, fieldName);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function _validateRecord(schema, obj) {
    if (!isObject(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = pluck('name', schema.fields).sort();
    var objFieldNames = Object.keys(obj).sort();
    if (!equals(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }
    return all(function (field) {
      return _validate(field.schema, obj[field.name], field.name);
    }, schema.fields);
  };

  var _validateUnion = function _validateUnion(schema, obj, fieldName) {
    if (isObject(obj)) {
      if (Array.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (Object.keys(obj).length !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = Object.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (contains(unionBranch, schema.branchNames())) {
          var typeIndex = schema.branchNames().indexOf(unionBranch);
          var unionBranchVal = obj[unionBranch];
          if (isNull(unionBranchVal) && contains('null', schema.branchNames()) || isUndefined(unionBranchVal)) {
            return true;
          }
          try {
            _validate(schema.typeSchemas[typeIndex], obj[unionBranch]);
            return true;
          } catch (e) {
            throw new ValidationError('Expected field name ' + fieldName + ' value to validate. Instead got an error: ' + e.message);
          }
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (isNull(obj)) {
      if (contains('null', schema.branchNames())) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else if (Array.isArray(obj)) {
      throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function _validateEnum(schema, obj) {
    if (isString(obj)) {
      if (contains(obj, schema.symbols)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function _validateArray(schema, obj) {
    if (Array.isArray(obj)) {
      return all(function (member) {
        return _validate(schema.itemSchema, member);
      }, obj);
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function _validateMap(schema, obj) {
    if (isObject(obj)) {
      return all(function (key) {
        return _validate(schema.valueSchema, obj[key]);
      }, Object.keys(obj));
    } else if (Array.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function _validatePrimitive(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (isNull(obj) || isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        if (isHex(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript bytes for Avro byts, got ' + JSON.stringify(obj));
        }
      case 'string':
        if (isString(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function _saveNamedType(fullyQualifiedTypeName, schema) {
    if (has(fullyQualifiedTypeName, _namedTypes)) {
      if (!equals(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function _lookupTypeByFullyQualifiedName(fullyQualifiedTypeName) {
    if (has(fullyQualifiedTypeName, _namedTypes)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function _parseNamedType(schema, namespace) {
    if (contains(schema, AvroSpec.PrimitiveTypes)) {
      return new Primitive(schema);
    } else if (!isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(Object.keys(_namedTypes)));
    }
  };

  var _parseSchema = function _parseSchema(schema, parentSchema, namespace) {
    if (isNull(schema) || isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (isObject(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, schema.fields.map(function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }), schema.type);
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (has('symbols', schema)) {
          var newEnum = new Enum(schema.symbols, schema.type);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (has('items', schema)) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace), schema.type);
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (has('values', schema)) {
          return new Map(_parseSchema(schema.values, schema, namespace), schema.type);
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (has('type', schema) && contains(schema.type, AvroSpec.PrimitiveTypes)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (Array.isArray(schema)) {
      if (!schema.length) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = schema.map(function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace, 'union');
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!has(fullyQualifiedTypeName, _typeSchemaValidators)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(Object.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function _initSchemaValidators(protocol) {
    var namedTypes = {};
    if (!has('protocol', protocol) || !isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (Array.isArray(protocol.types)) {
      protocol.types.forEach(function (typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"ramda/src/all":518,"ramda/src/contains":519,"ramda/src/equals":520,"ramda/src/has":521,"ramda/src/pluck":541,"ramda/src/type":543}],40:[function(require,module,exports){
module.exports = {
  "browse": "Browse",
  "charts": "Hitlisten",
  "discover": "Entdecken",
  "genres-moods": "Genres und Stimmungen",
  "highlights": "Highlights",
  "more": "Mehr",
  "new-releases": "Neuerscheinungen",
  "news": "News",
  "overview": "Übersicht",
  "toplists": "Toplisten",
  "concerts": "Konzerte"
};
},{}],41:[function(require,module,exports){
module.exports = {
  "browse": "Περιήγηση",
  "charts": "Τσαρτ",
  "discover": "Ανακάλυψε",
  "genres-moods": "Είδη και διαθέσεις",
  "highlights": "Τα καλύτερα",
  "more": "Περισσότερα",
  "new-releases": "Νέες κυκλοφορίες",
  "news": "Ειδήσεις",
  "overview": "Επισκόπηση",
  "toplists": "Κορυφαίες λίστες",
  "concerts": "Συναυλίες"
};
},{}],42:[function(require,module,exports){
module.exports = {
  "browse": "Browse",
  "charts": "Charts",
  "discover": "Discover",
  "genres-moods": "Genres & Moods",
  "highlights": "Highlights",
  "more": "More",
  "new-releases": "New Releases",
  "news": "News",
  "overview": "Overview",
  "toplists": "Top lists",
  "concerts": "Concerts"
}
;
},{}],43:[function(require,module,exports){
module.exports = {
  "browse": "Explorar",
  "charts": "Listas",
  "discover": "Descubre",
  "genres-moods": "Géneros y estados de ánimo",
  "highlights": "Lo más destacado",
  "more": "Más",
  "new-releases": "Música nueva",
  "news": "Noticias",
  "overview": "Vista general",
  "toplists": "Listas de éxitos",
  "concerts": "Conciertos"
};
},{}],44:[function(require,module,exports){
module.exports = {
  "browse": "Explorar",
  "charts": "Listas de éxitos",
  "discover": "Descubrir",
  "genres-moods": "Géneros y estados de ánimo",
  "highlights": "Destacados",
  "more": "Más",
  "new-releases": "Música nueva",
  "news": "Noticias",
  "overview": "Vista general",
  "toplists": "Listas de favoritos",
  "concerts": "Conciertos"
};
},{}],45:[function(require,module,exports){
module.exports = {
  "browse": "Browse",
  "charts": "Listat",
  "discover": "Discover",
  "genres-moods": "Genret & fiilikset",
  "highlights": "Kohokohdat",
  "more": "Lisää",
  "new-releases": "Uutuuksia",
  "news": "Uutiset",
  "overview": "Yleiskatsaus",
  "toplists": "Listat",
  "concerts": "Konsertit"
};
},{}],46:[function(require,module,exports){
module.exports = {
  "browse": "Parcourir",
  "charts": "Palmarès",
  "discover": "Découvrir",
  "genres-moods": "Genres et ambiances",
  "highlights": "Sélection",
  "more": "Plus",
  "new-releases": "Sorties",
  "news": "Actualités",
  "overview": "Présentation",
  "toplists": "Palmarès",
  "concerts": "Concerts"
};
},{}],47:[function(require,module,exports){
module.exports = {
  "browse": "Parcourir",
  "charts": "Les Tops",
  "discover": "Découvertes",
  "genres-moods": "Genres et ambiances",
  "highlights": "Temps forts",
  "more": "Plus",
  "new-releases": "Nouveautés",
  "news": "Actus",
  "overview": "Présentation",
  "toplists": "Top listes",
  "concerts": "Concerts"
};
},{}],48:[function(require,module,exports){
module.exports = {
  "browse": "Böngészés",
  "charts": "Toplisták",
  "discover": "Felfedezés",
  "genres-moods": "Műfajok és hangulatok",
  "highlights": "Reflektorfényben",
  "more": "Több",
  "new-releases": "Újdonságok",
  "news": "Hírek",
  "overview": "Áttekintés",
  "toplists": "Toplisták",
  "concerts": "Koncertek"
};
},{}],49:[function(require,module,exports){
module.exports = {
  "browse": "Browse",
  "charts": "Tangga Lagu",
  "discover": "Temukan",
  "genres-moods": "Genres & Moods",
  "highlights": "Sorotan",
  "more": "Lainnya",
  "new-releases": "Rilis Terbaru",
  "news": "Berita",
  "overview": "Tinjauan",
  "toplists": "Daftar teratas",
  "concerts": "Konser"
};
},{}],50:[function(require,module,exports){
module.exports = {
  "browse": "Naviga",
  "charts": "Classifiche",
  "discover": "Scopri",
  "genres-moods": "Generi e mood",
  "highlights": "In evidenza",
  "more": "Più",
  "new-releases": "Nuove uscite",
  "news": "Notizie",
  "overview": "Panoramica",
  "toplists": "Top list (plurale ndt)",
  "concerts": "Concerti"
};
},{}],51:[function(require,module,exports){
module.exports = {
  "browse": "Browse",
  "charts": "チャート",
  "discover": "ディスカバー",
  "genres-moods": "ジャンル＆気分",
  "highlights": "ハイライト",
  "more": "詳細",
  "new-releases": "ニューリリース",
  "news": "ニュース",
  "overview": "トップ",
  "toplists": "トップリスト",
  "concerts": "コンサート"
};
},{}],52:[function(require,module,exports){
module.exports = {
  "browse": "Bladeren",
  "charts": "Hitlijsten",
  "discover": "Ontdekken",
  "genres-moods": "Genres en stemmingen",
  "highlights": "Highlights",
  "more": "Meer",
  "new-releases": "Nieuwe releases",
  "news": "Nieuws",
  "overview": "Overzicht",
  "toplists": "Toplijsten",
  "concerts": "Concerten"
};
},{}],53:[function(require,module,exports){
module.exports = {
  "browse": "Przeglądaj",
  "charts": "Listy przebojów",
  "discover": "Odkryj muzykę",
  "genres-moods": "Gatunki i nastroje",
  "highlights": "Rekomendacje",
  "more": "Więcej",
  "new-releases": "Nowe utwory",
  "news": "Wiadomości",
  "overview": "Przegląd",
  "toplists": "Toplisty",
  "concerts": "Koncerty"
};
},{}],54:[function(require,module,exports){
module.exports = {
  "browse": "Navegar",
  "charts": "Paradas",
  "discover": "Descobrir",
  "genres-moods": "Gêneros & Momentos",
  "highlights": "Destaques",
  "more": "Mais",
  "new-releases": "Lançamentos",
  "news": "Notícias",
  "overview": "Visão geral",
  "toplists": "Listas das mais tocadas",
  "concerts": "Ao vivo"
};
},{}],55:[function(require,module,exports){
module.exports = {
  "browse": "Start",
  "charts": "Listor",
  "discover": "Upptäck",
  "genres-moods": "Genrer och teman",
  "highlights": "Höjdpunkter",
  "more": "Mer",
  "new-releases": "Nya releaser",
  "news": "Nyheter",
  "overview": "Översikt",
  "toplists": "Topplistor",
  "concerts": "Konserter"
};
},{}],56:[function(require,module,exports){
module.exports = {
  "browse": "Gözat",
  "charts": "Listeler",
  "discover": "Keşfet",
  "genres-moods": "Türler ve Ruh Halleri",
  "highlights": "Öne Çıkanlar",
  "more": "Daha fazla",
  "new-releases": "Yeni Çıkanlar",
  "news": "Yenilikler",
  "overview": "Genel Görünüm",
  "toplists": "En çok dinlenen listeler",
  "concerts": "Konserler"
};
},{}],57:[function(require,module,exports){
module.exports = {
  "browse": "瀏覽",
  "charts": "排行榜",
  "discover": "發掘更多",
  "genres-moods": "風格與心情",
  "highlights": "焦點",
  "more": "更多",
  "new-releases": "最新發行",
  "news": "最新消息",
  "overview": "摘要",
  "toplists": "當紅清單",
  "concerts": "演唱會"
};
},{}],58:[function(require,module,exports){
module.exports = {
  "browse": "Layari",
  "charts": "Carta",
  "discover": "Temui",
  "genres-moods": " Genre & Suasana Hati",
  "highlights": "Sorotan",
  "more": "Lebih banyak",
  "new-releases": "Keluaran Baharu",
  "news": "Berita",
  "overview": "Gambaran keseluruhan",
  "toplists": "Senarai paling popular",
  "concerts": "Konsert"
};
},{}],59:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var language = __spotify && __spotify.locale || 'en';
var strings = require('./locales/index.js')[language];
var template = require('../spotify-glue-cat/templates/v1/navbar.hbs');
var spotifyEvents = require('../spotify-events');

// Quickstart resolves i18n modules by putting copy strings
// in `strings` prop.
if (strings.strings && _typeof(strings.strings) === 'object') {
  strings = strings.strings;
}

// All possible navigation items for Browse
var NAV_ITEMS = {
  overview: {
    displayName: strings['overview'],
    link: 'spotify:app:browse:home',
    match: 'home'
  },
  toplists: {
    displayName: strings['toplists'],
    link: 'spotify:app:browse:toplists',
    match: 'toplists'
  },
  charts: {
    displayName: strings['charts'],
    link: 'spotify:app:charts',
    match: 'charts'
  },
  genres: {
    displayName: strings['genres-moods'],
    link: 'spotify:app:browse:genres',
    match: 'genres'
  },
  releases: {
    displayName: strings['new-releases'],
    link: 'spotify:app:browse:releases',
    match: 'releases'
  },
  discover: {
    displayName: strings['discover'],
    link: 'spotify:app:discover',
    match: 'discover'
  },
  concerts: {
    displayName: strings['concerts'],
    link: 'spotify:app:concerts',
    match: 'concerts',
    matcher: 'concerts:*'
  }
};

var navBar, navContainerId, activeTab, navItems;

// Initialize the navigation
// cb - callback that will be fed the created nav bar
function init(elementId, tab, cosmos, locale) {
  navContainerId = elementId;
  activeTab = tab;
  new Promise(getTabs(cosmos, locale)).then(setNavigation());
}

// Final method to set navigation
function setNavigation() {
  return function (navItems) {
    var html = template({
      'nav-items': navItems.map(function (item) {
        var tmplData = {
          'id': item.link,
          'name': item.displayName,
          'url': item.link
        };

        if (item.matcher) {
          tmplData.matcher = item.matcher;
        }

        return tmplData;
      })
    });
    var containerElement = document.querySelector('#' + navContainerId);
    containerElement.innerHTML = html;
    spotifyEvents.update(containerElement);
  };
}

function isNull(x) {
  if (typeof x === "undefined" || x === null) {
    return true;
  } else {
    return false;
  }
}

function getTabs(cosmos, locale) {
  return function (resolve) {
    navItems = [NAV_ITEMS.overview, NAV_ITEMS.charts, NAV_ITEMS.genres, NAV_ITEMS.releases, NAV_ITEMS.discover, NAV_ITEMS.concerts];
    if (isNull(locale)) {
      locale = "en";
      console.error("Could not set locale, will use default.", locale);
    }
    var url = "hm://browseview/v3/space/tab-bar?locale=" + locale + "&platform=web";
    cosmos.resolver.get(url, function (err, resp) {
      if (err) {
        console.error("Failed to fetch tabs, using default tab structure.", err);
      } else {
        var data = resp.getJSONBody();
        if (data && data.items && data.items.length > 0) {
          var items = getItems(data.items);
          if (items.length > 0) {
            navItems = items;
          } else {
            console.error("Could not retrieve items from data, using default tab structure.", resp);
          }
        } else {
          console.error("Garbled data received, using default tab structure.", resp);
        }
      }
      resolve(navItems);
    });
  };
}

function getItems(data) {
  var items = [];
  for (var index in data) {
    var item = data[index].link;
    if (!isNull(item.uri) && !isNull(item.label)) {
      // Infer match from last section of the uri
      var split = item.uri.split(":");
      var match = split[split.length - 1];
      if (!isNull(match) && !isNull(item.label) && !isNull(item.uri)) {
        // Here we extend the predefined list of NAV_ITEMS in order to be
        // able to add additional properties for the template, such as the
        // `matcher` property, which we don't get back from Spaces API.
        items.push(Object.assign(NAV_ITEMS[match] || {}, {
          displayName: item.label,
          link: item.uri,
          match: match
        }));
      } else {
        console.error("Skipping broken item data", JSON.stringify(item));
      }
    } else {
      console.error("Skipping broken item data", JSON.stringify(item));
    }
  }
  return items;
}

function destroy() {}

exports.init = init;
exports.destroy = destroy;

},{"../spotify-events":163,"../spotify-glue-cat/templates/v1/navbar.hbs":240,"./locales/index.js":60}],60:[function(require,module,exports){
'use strict';

module.exports = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

},{"../i18n/de.lang":40,"../i18n/el.lang":41,"../i18n/en.lang":42,"../i18n/es-419.lang":43,"../i18n/es.lang":44,"../i18n/fi.lang":45,"../i18n/fr-CA.lang":46,"../i18n/fr.lang":47,"../i18n/hu.lang":48,"../i18n/id.lang":49,"../i18n/it.lang":50,"../i18n/ja.lang":51,"../i18n/nl.lang":52,"../i18n/pl.lang":53,"../i18n/pt-BR.lang":54,"../i18n/sv.lang":55,"../i18n/tr.lang":56,"../i18n/zh-Hant.lang":57,"../i18n/zsm.lang":58}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                   * Message Proxy is a tool to create a REST-like service
                                                                                                                                                                                                                                                   * between iframes in Zelda using Cosmos.
                                                                                                                                                                                                                                                   */

var _uris = require('./uris.json');

var _uris2 = _interopRequireDefault(_uris);

var _spotifyBridgeRequest = require('../spotify-bridge-request');

var _spotifyBridgeRequest2 = _interopRequireDefault(_spotifyBridgeRequest);

var _uuidJs = require('uuid-js');

var _uuidJs2 = _interopRequireDefault(_uuidJs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BASE_URI = 'sp://messages/v1/message-proxy/';
var METHODS = ['POST', 'SUB', 'GET', 'REPLY'];
var DEFAULT_TIMEOUT = 5000; // 5 seconds.

function messageProxy(requestObj, callback, timeout) {
  var uri = requestObj.uri;
  var body = {};

  // Validate Request
  if (!requestObj) throw new Error('Need a request object.');
  if (METHODS.indexOf(requestObj.method) === -1) {
    throw new Error('Need a valid method: "POST" | "SUB" | "GET" | "REPLY"');
  }
  if (!_uris2.default.hasOwnProperty(uri)) {
    throw new Error('Uri need to be one of these: ', Object.keys(_uris2.default));
  }
  if (requestObj.method !== 'POST' && !callback) {
    throw new Error('Callback needed for "GET", "SUB", & "REPLY" requests');
  }

  var requiredKeys = _uris2.default[uri][requestObj.method] || [];

  // GET
  if (requestObj.method === 'GET') {
    var _ret = function () {
      var getTimeout = void 0;

      requiredKeys.forEach(function (requiredKey) {
        if (!requestObj.body.hasOwnProperty(requiredKey)) {
          throw new Error('Uri \'GET\' request body missing\n                        a required key: ' + requiredKey);
        }
        body[requiredKey] = requestObj.body[requiredKey];
      });

      var replyUri = '' + BASE_URI + uri + '-' + _uuidJs2.default.create();
      body.replyUri = replyUri;

      var unsubscribe = _spotifyBridgeRequest2.default.cosmos({ method: 'SUB', uri: replyUri }, function (err, response) {
        if (!err && response) {
          var dataErr = JSON.parse(response.body).error;
          callback(dataErr, response);
        } else {
          callback(err);
        }
        unsubscribe();
        clearTimeout(getTimeout);
      });

      _spotifyBridgeRequest2.default.cosmos({
        method: 'POST',
        uri: '' + BASE_URI + uri + '-get',
        body: JSON.stringify(body)
      }, function (err) {
        if (err) {
          callback(err);
          unsubscribe();
        }
      });

      getTimeout = setTimeout(function () {
        callback(new Error('Timeout for \'GET\':', uri));
        unsubscribe();
      }, timeout || DEFAULT_TIMEOUT);

      return {
        v: true
      };
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }

  // REPLY
  if (requestObj.method === 'REPLY') {
    return _spotifyBridgeRequest2.default.cosmos({ method: 'SUB', uri: '' + BASE_URI + uri + '-get' }, function (err, response) {
      callback(err, response, function reply(replyErr, data) {
        var replyData = {};
        if (replyErr) {
          replyData.error = replyErr;
        } else {
          requiredKeys.forEach(function (requiredKey) {
            if (!data.hasOwnProperty(requiredKey)) {
              throw new Error('Reply data missing\n                                a required key: ' + requiredKey);
            }
            replyData[requiredKey] = data[requiredKey];
          });
        }
        _spotifyBridgeRequest2.default.cosmos({
          method: 'POST',
          uri: JSON.parse(response.body).replyUri,
          body: JSON.stringify(replyData)
        });
      });
    });
  }

  // POST
  if (requestObj.method === 'POST') {
    requiredKeys.forEach(function (requiredKey) {
      if (!requestObj.body.hasOwnProperty(requiredKey)) {
        throw new Error('Uri \'POST\' request body missing\n                        a required key: ' + requiredKey);
      }
      body[requiredKey] = requestObj.body[requiredKey];
    });

    _spotifyBridgeRequest2.default.cosmos({
      method: 'POST',
      uri: BASE_URI + uri,
      body: JSON.stringify(body)
    }, function (err) {
      if (err && callback) callback(err);
    });

    return true;
  }

  // SUB
  return _spotifyBridgeRequest2.default.cosmos({ method: 'SUB', uri: BASE_URI + uri }, callback);
}

exports.default = messageProxy;

},{"../spotify-bridge-request":134,"./uris.json":62,"uuid-js":587}],62:[function(require,module,exports){
module.exports={
  "history": {
    "GET": ["count"],
    "REPLY": ["history"]
  },
  "ads-debug-ta": {
    "REPLY": ["enabled"]
  },
  "unit-test": {
    "GET": ["key1"],
    "POST": ["key2"],
    "REPLY": ["key3"]
  }
}

},{}],63:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var abba = function abba(flag, callback) {
  cosmos.resolver.post({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (err, response) {
    if (global.__spotify.abba_overrides && flag in global.__spotify.abba_overrides) {
      callback(null, global.__spotify.abba_overrides[flag]);
      return;
    }

    if (err) {
      callback(err, null);
      return;
    }
    var body = response.getJSONBody();
    var flags = body && body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === flag && flags[0].cell;
    callback(null, featureFlagCell || null);
  });
};
module.exports = abba;
// Also expose as an easily stubbable property.
abba.get = abba;

abba.subscribe = function (flag, callback) {
  var oldValue;

  var update = function update(newValue) {
    // ABBA might pub even though the value we're after haven't actually
    // changed, so must make sure that the flag we're tracking actually
    // changed value.
    if (newValue !== oldValue) {
      oldValue = newValue;
      callback(null, newValue);
    }
  };

  var cosmosSubscription = cosmos.resolver.subscribe({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (subscribeError) {
    if (subscribeError) {
      callback(subscribeError);
      return;
    }

    abba.get(flag, function (err, newValue) {
      if (err) {
        callback(err);
        return;
      }
      update(newValue);
    });
  });

  var subscription = {
    cancel: function cancel() {
      if (cosmosSubscription) cosmosSubscription.cancel();
      var index = abba._subscriptions[flag].indexOf(subscription);
      if (index !== -1) {
        abba._subscriptions[flag].splice(index, 1);
      }
      subscription = cosmosSubscription = null;
    },
    _update: update
  };

  if (!(flag in abba._subscriptions)) abba._subscriptions[flag] = [];
  abba._subscriptions[flag].push(subscription);

  return subscription;
};

abba._subscriptions = {};

abba.override = function (flag, value) {
  if (!('abba_overrides' in global.__spotify)) global.__spotify.abba_overrides = {};
  global.__spotify.abba_overrides[flag] = value;

  (abba._subscriptions[flag] || []).forEach(function (subscription) {
    subscription._update(value);
  });
  console.warn('[abba.override]', 'Keep in mind that this is not persistent and only updates existing `abba.subscribe`s and subsequent `abba.get`s');
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":554}],64:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ankündigungen ausblenden",
  "Sponsored": "Gesponsert",
  "Advertisement": "Werbung",
  "Promoted": "Beworben",
  "PresentedBy": "Präsentiert von"
};
},{}],65:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Απόκρυψη ανακοινώσεων",
  "Sponsored": "Χορηγία",
  "Advertisement": "Διαφήμιση",
  "Promoted": "Προώθηση",
  "PresentedBy": "Παρουσιάζεται από:"
};
},{}],66:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Hide Announcements",
  "Sponsored": "Sponsored",
  "Advertisement": "Advertisement",
  "Promoted": "Promoted",
  "PresentedBy": "Presented By"
};
},{}],67:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ocultar Noticias",
  "Sponsored": "Patrocinado",
  "Advertisement": "Anuncio",
  "Promoted": "Promocionados",
  "PresentedBy": "Presentado por"
};
},{}],68:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ocultar mensajes",
  "Sponsored": "Patrocinado",
  "Advertisement": "Publicidad",
  "Promoted": "Promocionados",
  "PresentedBy": "Ofrecido por"
};
},{}],69:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Piilota ilmoitukset",
  "Sponsored": "Sponsoroitu",
  "Advertisement": "Mainos",
  "Promoted": "Nostettu",
  "PresentedBy": "Listan tarjoaa"
};
},{}],70:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Masquer les publicités",
  "Sponsored": "Commandité",
  "Advertisement": "Publicité",
  "Promoted": "Commanditée",
  "PresentedBy": "Présenté par"
};
},{}],71:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Masquer",
  "Sponsored": "Sponsorisé",
  "Advertisement": "Publicité",
  "Promoted": "Sponsorisé",
  "PresentedBy": "Présenté(e) par"
};
},{}],72:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Hírek elrejtése",
  "Sponsored": "Fizetett hirdetés",
  "Advertisement": "Reklám",
  "Promoted": "Szponzorált",
  "PresentedBy": "Szponzor:"
};
},{}],73:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Sembunyikan Pemberitahuan",
  "Sponsored": "Disponsori",
  "Advertisement": "Iklan",
  "Promoted": "Dipromosikan",
  "PresentedBy": "Disajikan Oleh"
};
},{}],74:[function(require,module,exports){
(function (global){
'use strict';

var window = window || global;

var Translations = require('../../spotify-translations');
var glueLocales = require('../../spotify-glue-cat/strings');

var locales = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

var i18n = new Translations();

function getClientLocale() {
  return window.__spotify && window.__spotify.locale || 'en';
}

function setLocale(locale) {
  if (locale === 'auto') {
    locale = getClientLocale();
  }

  var strings = locales[locale].strings || locales[locale];

  i18n.injectData(strings || {});
}

setLocale('auto');

exports.locale = getClientLocale;
exports.locales = locales;
exports.setLocale = setLocale;
exports.get = i18n.get.bind(i18n);

exports.glueStrings = function () {
  return glueLocales[getClientLocale()];
};

exports.appStrings = function () {
  return locales[getClientLocale()];
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-glue-cat/strings":231,"../../spotify-translations":353,"../i18n/de.lang":64,"../i18n/el.lang":65,"../i18n/en.lang":66,"../i18n/es-419.lang":67,"../i18n/es.lang":68,"../i18n/fi.lang":69,"../i18n/fr-CA.lang":70,"../i18n/fr.lang":71,"../i18n/hu.lang":72,"../i18n/id.lang":73,"../i18n/it.lang":75,"../i18n/ja.lang":76,"../i18n/nl.lang":77,"../i18n/pl.lang":78,"../i18n/pt-BR.lang":79,"../i18n/sv.lang":80,"../i18n/tr.lang":81,"../i18n/zh-Hant.lang":82,"../i18n/zsm.lang":83}],75:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Nascondi annunci",
  "Sponsored": "Sponsorizzato",
  "Advertisement": "Pubblicità",
  "Promoted": "Promossi",
  "PresentedBy": "Presentato da"
};
},{}],76:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "お知らせを非表示にする",
  "Sponsored": "スポンサー付き",
  "Advertisement": "広告",
  "Promoted": "プロモーション済み",
  "PresentedBy": "提供元:"
};
},{}],77:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Aankondigingen verbergen",
  "Sponsored": "Gesponsord",
  "Advertisement": "Advertentie",
  "Promoted": "Aangeboden",
  "PresentedBy": "Gepresenteerd door"
};
},{}],78:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ukryj ogłoszenia",
  "Sponsored": "Sponsorowane",
  "Advertisement": "Reklama",
  "Promoted": "Promowane",
  "PresentedBy": "Prezentuje"
};
},{}],79:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ocultar",
  "Sponsored": "Patrocinado",
  "Advertisement": "Propaganda",
  "Promoted": "Promocional",
  "PresentedBy": "Apresentadas por"
};
},{}],80:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Dölj musikaviseringar",
  "Sponsored": "Sponsrad",
  "Advertisement": "Reklam",
  "Promoted": "Sponsrat",
  "PresentedBy": "Presenteras av"
};
},{}],81:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Duyuruları Gizle",
  "Sponsored": "Sponsorlu",
  "Advertisement": "Reklam",
  "Promoted": "Tanıtılan",
  "PresentedBy": "Sunan"
};
},{}],82:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "隱藏公告",
  "Sponsored": "贊助",
  "Advertisement": "廣告",
  "Promoted": "已宣傳",
  "PresentedBy": "贊助商："
};
},{}],83:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Sembunyikan Pengumuman",
  "Sponsored": "Tajaan",
  "Advertisement": "Iklan",
  "Promoted": "Dipromosikan",
  "PresentedBy": "Dipersembahkan Oleh"
};
},{}],84:[function(require,module,exports){
module.exports = '<svg width="150px" height="20px" viewBox="0 0 147 20" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n    <title>spotify spotlight svg 2</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n        <rect id="Rectangle-1" fill="#FFFFFF" sketch:type="MSShapeGroup" x="70" y="5" width="1" height="11"></rect>\n        <g id="Imported-Layers" sketch:type="MSLayerGroup">\n            <path d="M10.001005,0.0447 C4.48874372,0.0447 0.0198994975,4.491 0.0198994975,9.9758 C0.0198994975,15.461 4.48874372,19.9071 10.001005,19.9071 C15.5135678,19.9071 19.9821106,15.461 19.9821106,9.9758 C19.9821106,4.491 15.5135678,0.0447 10.001005,0.0447" id="Fill-1" fill="#84BD00" sketch:type="MSShapeGroup"></path>\n            <path d="M15.5438191,10.6003 C12.4630151,8.7165 7.95648241,8.1864 4.33135678,9.2809 C3.92060302,9.4054 3.68844221,9.8371 3.81246231,10.2466 C3.93748744,10.6553 4.3720603,10.8861 4.78361809,10.7624 C7.95698492,9.804 12.0471357,10.2792 14.7294472,11.9197 C15.0951759,12.1435 15.5740704,12.0292 15.799799,11.6648 C16.0247236,11.3012 15.9095477,10.8244 15.5438191,10.6003" id="Fill-2" fill="#000000" sketch:type="MSShapeGroup"></path>\n            <path d="M16.8580905,7.2513 C13.1541709,5.0637 7.29326633,4.858 3.76753769,5.9229 C3.27396985,6.072 2.9958794,6.5906 3.14532663,7.0816 C3.29477387,7.5724 3.81628141,7.8494 4.30954774,7.7005 C7.38090452,6.773 12.6878392,6.9478 15.9051256,8.8489 C16.3477387,9.111 16.9211055,8.9655 17.1842211,8.5241 C17.4472362,8.0834 17.3017085,7.5133 16.8580905,7.2513" id="Fill-3" fill="#000000" sketch:type="MSShapeGroup"></path>\n            <path d="M14.3720603,13.5178 C11.7413065,11.9182 8.4798995,11.546 4.67788945,12.4108 C4.34231156,12.4868 4.13326633,12.8189 4.21005025,13.152 C4.28633166,13.485 4.62,13.6938 4.95487437,13.6174 C8.42914573,12.8277 11.3792965,13.1496 13.7231156,14.575 C14.0160804,14.7533 14.3990955,14.6616 14.5784925,14.369 C14.7577889,14.0772 14.6654271,13.696 14.3720603,13.5178" id="Fill-4" fill="#000000" sketch:type="MSShapeGroup"></path>\n        </g>\n        <g id="Imported-Layers" sketch:type="MSLayerGroup" transform="translate(25.000000, 5.000000)" fill="#FFFFFF">\n            <path d="M3.80616092,4.19354545 C2.22942529,3.82181818 1.9485977,3.56090909 1.9485977,3.01281818 C1.9485977,2.49481818 2.44193103,2.14636364 3.17535632,2.14636364 C3.88643678,2.14636364 4.59135632,2.411 5.33057471,2.95590909 C5.35291954,2.97236364 5.38096552,2.979 5.40845977,2.97472727 C5.43604598,2.97063636 5.46050575,2.95563636 5.47668966,2.93309091 L6.24662069,1.86009091 C6.27816092,1.816 6.2696092,1.75509091 6.22694253,1.72127273 C5.34721839,1.02336364 4.3565977,0.684090909 3.19871264,0.684090909 C1.49627586,0.684090909 0.307126437,1.69418182 0.307126437,3.13936364 C0.307126437,4.68918182 1.33287356,5.23790909 3.10556322,5.66145455 C4.61443678,6.00509091 4.86905747,6.29290909 4.86905747,6.80754545 C4.86905747,7.37772727 4.3542069,7.73227273 3.52551724,7.73227273 C2.60514943,7.73227273 1.85443678,7.42572727 1.01462069,6.70672727 C0.99383908,6.689 0.965241379,6.68081818 0.938850575,6.68236364 C0.91108046,6.68463636 0.885701149,6.69736364 0.868045977,6.71836364 L0.0047816092,7.734 C-0.0314482759,7.77618182 -0.0268505747,7.83909091 0.0149885057,7.87563636 C0.992091954,8.738 2.19374713,9.19354545 3.49057471,9.19354545 C5.32514943,9.19354545 6.51062069,8.20254545 6.51062069,6.66863636 C6.51062069,5.37236364 5.72717241,4.65545455 3.80616092,4.19354545" id="Fill-1" sketch:type="MSShapeGroup"></path>\n            <path d="M10.6611494,2.65618182 C9.86593103,2.65618182 9.21370115,2.96581818 8.67586207,3.60027273 L8.67586207,2.88618182 C8.67586207,2.82981818 8.6296092,2.78390909 8.5725977,2.78390909 L7.16082759,2.78390909 C7.10381609,2.78390909 7.05765517,2.82981818 7.05765517,2.88618182 L7.05765517,10.8211818 C7.05765517,10.8775455 7.10381609,10.9234545 7.16082759,10.9234545 L8.5725977,10.9234545 C8.6296092,10.9234545 8.67586207,10.8775455 8.67586207,10.8211818 L8.67586207,8.31645455 C9.2137931,8.91336364 9.86611494,9.20490909 10.6611494,9.20490909 C12.1386667,9.20490909 13.6342989,8.08045455 13.6342989,5.93090909 C13.6342989,3.78090909 12.1386667,2.65618182 10.6611494,2.65618182 L10.6611494,2.65618182 Z M11.9928276,5.93090909 C11.9928276,7.02545455 11.3108046,7.78936364 10.3343448,7.78936364 C9.36891954,7.78936364 8.64064368,6.99072727 8.64064368,5.93090909 C8.64064368,4.87118182 9.36891954,4.07254545 10.3343448,4.07254545 C11.2950805,4.07254545 11.9928276,4.85390909 11.9928276,5.93090909 L11.9928276,5.93090909 Z" id="Fill-2" sketch:type="MSShapeGroup"></path>\n            <path d="M17.4683218,2.65618182 C15.5654253,2.65618182 14.0747586,4.10472727 14.0747586,5.95427273 C14.0747586,7.78372727 15.5552184,9.21709091 17.4449655,9.21709091 C19.3544828,9.21709091 20.8497471,7.77336364 20.8497471,5.93090909 C20.8497471,4.09454545 19.3647816,2.65618182 17.4683218,2.65618182 L17.4683218,2.65618182 Z M17.4683218,7.80081818 C16.4561839,7.80081818 15.6931494,6.99681818 15.6931494,5.93090909 C15.6931494,4.86054545 16.4297931,4.08372727 17.4449655,4.08372727 C18.4635402,4.08372727 19.2318161,4.88763636 19.2318161,5.95427273 C19.2318161,7.02445455 18.4901149,7.80081818 17.4683218,7.80081818 L17.4683218,7.80081818 Z" id="Fill-3" sketch:type="MSShapeGroup"></path>\n            <path d="M24.9131954,2.78390909 L23.3595402,2.78390909 L23.3595402,1.21345455 C23.3595402,1.15709091 23.3134713,1.11127273 23.2564598,1.11127273 L21.8447816,1.11127273 C21.7876782,1.11127273 21.7413333,1.15709091 21.7413333,1.21345455 L21.7413333,2.78390909 L21.0624368,2.78390909 C21.0056092,2.78390909 20.9595402,2.82981818 20.9595402,2.88618182 L20.9595402,4.08572727 C20.9595402,4.142 21.0056092,4.188 21.0624368,4.188 L21.7413333,4.188 L21.7413333,7.292 C21.7413333,8.54636364 22.3727816,9.18236364 23.6182989,9.18236364 C24.1246897,9.18236364 24.5448276,9.079 24.9407816,8.857 C24.9729655,8.83918182 24.9930115,8.80490909 24.9930115,8.76845455 L24.9930115,7.62618182 C24.9930115,7.59090909 24.9744368,7.55763636 24.944,7.53918182 C24.9131954,7.52009091 24.8749425,7.51909091 24.8434023,7.53454545 C24.5714023,7.66981818 24.3084138,7.73227273 24.0146207,7.73227273 C23.5616552,7.73227273 23.3595402,7.52890909 23.3595402,7.07327273 L23.3595402,4.188 L24.9131954,4.188 C24.9702069,4.188 25.0161839,4.142 25.0161839,4.08572727 L25.0161839,2.88618182 C25.0161839,2.82981818 24.9702069,2.78390909 24.9131954,2.78390909" id="Fill-4" sketch:type="MSShapeGroup"></path>\n            <path d="M30.326069,2.79 L30.326069,2.59709091 C30.326069,2.02963636 30.546023,1.77663636 31.0397241,1.77663636 C31.333977,1.77663636 31.5703908,1.83445455 31.8352184,1.92181818 C31.8677701,1.93190909 31.9018851,1.92681818 31.9283678,1.90754545 C31.9555862,1.88827273 31.9710345,1.85736364 31.9710345,1.82454545 L31.9710345,0.648363636 C31.9710345,0.603454545 31.9417011,0.563545455 31.898023,0.550363636 C31.6182989,0.468090909 31.2604138,0.383636364 30.7245057,0.383636364 C29.4204138,0.383636364 28.7312184,1.10963636 28.7312184,2.48236364 L28.7312184,2.77781818 L28.0529655,2.77781818 C27.996046,2.77781818 27.9493333,2.82363636 27.9493333,2.88 L27.9493333,4.08572727 C27.9493333,4.142 27.996046,4.188 28.0529655,4.188 L28.7312184,4.188 L28.7312184,8.97572727 C28.7312184,9.03209091 28.7771954,9.078 28.8341149,9.078 L30.245977,9.078 C30.3029885,9.078 30.3494253,9.03209091 30.3494253,8.97572727 L30.3494253,4.188 L31.6675862,4.188 L33.6868966,8.97454545 C33.4576552,9.47745455 33.2321839,9.57754545 32.9245057,9.57754545 C32.6757701,9.57754545 32.4137931,9.50409091 32.146023,9.35918182 C32.1207356,9.34554545 32.0909425,9.34318182 32.0637241,9.35154545 C32.0367816,9.361 32.014069,9.38072727 32.0026667,9.40672727 L31.5241379,10.4446364 C31.5013333,10.4936364 31.5208276,10.5512727 31.5686437,10.5766364 C32.0681379,10.8440909 32.5191724,10.9582727 33.0764138,10.9582727 C34.1188966,10.9582727 34.6951724,10.4781818 35.2031264,9.18663636 L37.6525057,2.92927273 C37.6648276,2.89781818 37.6611494,2.86227273 37.6415632,2.83436364 C37.6222529,2.80663636 37.5908966,2.79 37.5566897,2.79 L36.0868966,2.79 C36.0429425,2.79 36.0034943,2.81763636 35.9891494,2.85845455 L34.4834943,7.11027273 L32.8342989,2.85572727 C32.8192184,2.81609091 32.7806897,2.79 32.7378391,2.79 L30.326069,2.79" id="Fill-5" sketch:type="MSShapeGroup"></path>\n            <path d="M27.188046,2.78390909 L25.7761839,2.78390909 C25.7191724,2.78390909 25.6727356,2.82981818 25.6727356,2.88618182 L25.6727356,8.97572727 C25.6727356,9.03209091 25.7191724,9.078 25.7761839,9.078 L27.188046,9.078 C27.2449655,9.078 27.2914943,9.03209091 27.2914943,8.97572727 L27.2914943,2.88618182 C27.2914943,2.82981818 27.2449655,2.78390909 27.188046,2.78390909" id="Fill-6" sketch:type="MSShapeGroup"></path>\n            <path d="M26.4892874,0.0110909091 C25.930023,0.0110909091 25.4761379,0.458727273 25.4761379,1.01172727 C25.4761379,1.565 25.930023,2.01309091 26.4892874,2.01309091 C27.0483678,2.01309091 27.5017931,1.565 27.5017931,1.01172727 C27.5017931,0.458727273 27.0483678,0.0110909091 26.4892874,0.0110909091" id="Fill-7" sketch:type="MSShapeGroup"></path>\n            <path d="M38.8578391,4.74172727 C38.2991264,4.74172727 37.8642759,4.29809091 37.8642759,3.75936364 C37.8642759,3.22063636 38.3048276,2.77190909 38.8630805,2.77190909 C39.4217931,2.77190909 39.8565517,3.21554545 39.8565517,3.75372727 C39.8565517,4.29254545 39.4164598,4.74172727 38.8578391,4.74172727 L38.8578391,4.74172727 Z M38.8630805,2.86963636 C38.3542069,2.86963636 37.9690115,3.26954545 37.9690115,3.75936364 C37.9690115,4.24890909 38.3513563,4.64354545 38.8578391,4.64354545 C39.3666207,4.64354545 39.7521839,4.24381818 39.7521839,3.75372727 C39.7521839,3.26427273 39.3695632,2.86963636 38.8630805,2.86963636 L38.8630805,2.86963636 Z M39.0833103,3.85481818 L39.3644138,4.24381818 L39.1274483,4.24381818 L38.8744828,3.887 L38.6569195,3.887 L38.6569195,4.24381818 L38.4585747,4.24381818 L38.4585747,3.21272727 L38.9236782,3.21272727 C39.165977,3.21272727 39.3253333,3.33527273 39.3253333,3.54163636 C39.3253333,3.71063636 39.2265747,3.81390909 39.0833103,3.85481818 L39.0833103,3.85481818 Z M38.9156782,3.38963636 L38.6569195,3.38963636 L38.6569195,3.71572727 L38.9156782,3.71572727 C39.0447816,3.71572727 39.1218391,3.65327273 39.1218391,3.55254545 C39.1218391,3.44645455 39.0447816,3.38963636 38.9156782,3.38963636 L38.9156782,3.38963636 Z" id="Fill-8" sketch:type="MSShapeGroup"></path>\n        </g>\n        <path d="M79.9,13.12 C81.7,13.12 82.27,12.09 82.27,11.23 C82.27,8.74 78.27,9.68 78.27,7.97 C78.27,7.25 78.94,6.74 79.83,6.74 C80.58,6.74 81.26,7 81.74,7.58 L82.12,7.16 C81.6,6.57 80.86,6.22 79.86,6.22 C78.65,6.22 77.67,6.91 77.67,8 C77.67,10.33 81.67,9.31 81.67,11.27 C81.67,11.84 81.28,12.6 79.91,12.6 C78.96,12.6 78.26,12.13 77.83,11.63 L77.46,12.06 C77.97,12.68 78.8,13.12 79.9,13.12 L79.9,13.12 Z M86.51,13 L86.51,10.23 L88.44,10.23 C89.71,10.23 90.45,9.33 90.45,8.28 C90.45,7.23 89.72,6.33 88.44,6.33 L85.94,6.33 L85.94,13 L86.51,13 Z M88.38,9.71 L86.51,9.71 L86.51,6.85 L88.38,6.85 C89.26,6.85 89.85,7.44 89.85,8.28 C89.85,9.12 89.26,9.71 88.38,9.71 L88.38,9.71 Z M96.9399999,13.12 C98.8899999,13.12 100.18,11.62 100.18,9.67 C100.18,7.72 98.8899999,6.22 96.9399999,6.22 C94.9799999,6.22 93.6999999,7.72 93.6999999,9.67 C93.6999999,11.62 94.9799999,13.12 96.9399999,13.12 L96.9399999,13.12 Z M96.9399999,12.6 C95.3199999,12.6 94.2999999,11.35 94.2999999,9.67 C94.2999999,7.97 95.3199999,6.74 96.9399999,6.74 C98.5399999,6.74 99.5799999,7.97 99.5799999,9.67 C99.5799999,11.35 98.5399999,12.6 96.9399999,12.6 L96.9399999,12.6 Z M105.88,13 L105.88,6.85 L108.06,6.85 L108.06,6.33 L103.12,6.33 L103.12,6.85 L105.3,6.85 L105.3,13 L105.88,13 Z M115.34,13 L115.34,12.48 L112.11,12.48 L112.11,6.33 L111.54,6.33 L111.54,13 L115.34,13 Z M119.45,13 L119.45,6.33 L118.88,6.33 L118.88,13 L119.45,13 Z M126.54,13.13 C127.59,13.13 128.48,12.68 129.07,12.02 L129.07,9.69 L125.98,9.69 L125.98,10.2 L128.5,10.2 L128.5,11.8 C128.13,12.17 127.43,12.61 126.54,12.61 C124.97,12.61 123.76,11.39 123.76,9.67 C123.76,7.93 124.97,6.74 126.54,6.74 C127.39,6.74 128.15,7.11 128.62,7.67 L129.05,7.36 C128.44,6.66 127.64,6.22 126.54,6.22 C124.67,6.22 123.16,7.61 123.16,9.67 C123.16,11.73 124.67,13.13 126.54,13.13 L126.54,13.13 Z M138.2,13 L138.2,6.33 L137.62,6.33 L137.62,9.31 L133.39,9.31 L133.39,6.33 L132.82,6.33 L132.82,13 L133.39,13 L133.39,9.83 L137.62,9.83 L137.62,13 L138.2,13 Z M144.43,13 L144.43,6.85 L146.61,6.85 L146.61,6.33 L141.67,6.33 L141.67,6.85 L143.85,6.85 L143.85,13 L144.43,13 Z" id="SPOTLIGHT" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>\n    </g>\n</svg>';
},{}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _src = require('./src');

Object.keys(_src).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _src[key];
    }
  });
});

},{"./src":124}],86:[function(require,module,exports){
module.exports={
  "name": "spotify-ad-formats",
  "version": "8.4.1",
  "description": "Component to render ads in the Spotify desktop client and web player",
  "keywords": [
    "ads",
    "leaderboard",
    "hpto",
    "video",
    "companion",
    "billboard"
  ],
  "author": {
    "name": "CREAM team",
    "email": "cream@spotify.com"
  },
  "contributors": [
    "Brice Lin <blin@spotify.com>",
    "Jason Palmer <jpalmer@spotify.com>",
    "Jo Blake <jblake@spotify.com"
  ],
  "browserify": {
    "transform": [
      [
        "hbsfy",
        {
          "traverse": true
        }
      ],
      [
        "partialify",
        {
          "alsoAllow": "svg"
        }
      ]
    ]
  },
  "license": "UNLICENSED",
  "repository": {
    "type": "git",
    "url": "https://ghe.spotify.net/ads/spotify-ad-formats.git"
  },
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "main": "./index.js",
  "bugs": {
    "url": "https://ghe.spotify.net/ads/spotify-ad-formats/issues"
  },
  "publishConfig": {
    "registry": "http://npm-registry.spotify.net"
  },
  "private": true
}
},{}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cosmosConnector = new _cosmosConnector2.default();

var keys = {
  AD_FORMAT: 'ad_format',
  AD_ID: 'ad_id',
  AD_PLAYBACK_ID: 'ad_playback_id',
  APP_STARTUP_ID: 'app_startup_id',
  CONTEXT: 'context',
  CREATIVE_ID: 'creative_id',
  EVENT: 'event',
  EVENT_VERSION: 'event_version',
  IN_FOCUS: 'focus',
  JSONDATA: 'jsondata',
  LINE_ITEM_ID: 'lineitem_id',
  MS_FROM_START: 'ms_from_start',
  SLOT: 'slot',
  SOURCE: 'source',
  SOURCE_VERSION: 'source_version'
};

var defaults = {};
defaults[keys.AD_FORMAT] = '';
defaults[keys.AD_ID] = '';
defaults[keys.AD_PLAYBACK_ID] = '';
defaults[keys.APP_STARTUP_ID] = '';
defaults[keys.CREATIVE_ID] = '';
defaults[keys.CONTEXT] = '';
defaults[keys.EVENT] = '';
defaults[keys.EVENT_VERSION] = '';
defaults[keys.IN_FOCUS] = 'true';
defaults[keys.JSONDATA] = '';
defaults[keys.LINE_ITEM_ID] = '';
defaults[keys.MS_FROM_START] = '0';
defaults[keys.SLOT] = '';
defaults[keys.SOURCE] = '';
defaults[keys.SOURCE_VERSION] = '';

exports.default = {

  /**
   * Keys available to log.
   * @type {Object}
   */
  keys: keys,

  /**
   * Log an AdEvent message to the backend.
   *
   * Will use default values for keys not passed.
   *
   * Logged according to the spec found at https://ghe.spotify.net/datainfra/
   *   log-parser/blob/master/spotify/log_parser/messages_specs.py
   *
   * All values need to be passed to core as strings, otherwise they won't get
   * picked up correctly.
   *
   * @example
   *
   * var adLogger = require('../ad_logger.js').default;
   * var message = {};
   * message[adLogger.keys.EVENT] = 'event_errored';
   * message[adLogger.keys.AD_FORMAT] = 'banner';
   * message[adLogger.keys.LINE_ITEM_ID] = 'foo';
   * adLogger.log(message);
   *
   * @param {Object} message The data to log.
   * @return {Promise}
   */
  log: function log(message) {
    var fields = Object.assign({}, defaults, message);
    var body = {
      message: 'AdEvent',
      version: 4,
      fields: ['' + fields[keys.AD_PLAYBACK_ID], '' + fields[keys.APP_STARTUP_ID], '' + fields[keys.AD_ID], '' + fields[keys.LINE_ITEM_ID], '' + fields[keys.CREATIVE_ID], '' + fields[keys.AD_FORMAT], '' + fields[keys.SOURCE], '' + fields[keys.CONTEXT], '' + fields[keys.EVENT], '' + fields[keys.EVENT_VERSION], '' + fields[keys.JSONDATA], '' + fields[keys.SOURCE_VERSION], '' + fields[keys.SLOT], '' + fields[keys.MS_FROM_START], '' + (window.top.document.hasFocus() ? '1' : '0')]
    };
    return cosmosConnector.logMessage(body);
  },
  logError: function logError(context, errorMessage) {
    var body = {
      message: 'AdError',
      version: 2,
      fields: [String(context), String(errorMessage),

      // As of version 2 of AdError, the remaining fields are
      // not relevant for display ads
      '', // http-error-code
      '', // request-url
      '', // companion-ad
      '' // tracking-event
      ]
    };
    // Cosmos Connector uses debug module for console debugging
    return cosmosConnector.logMessage(body);
  }
};

},{"./cosmos-connector":90}],88:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyAbbaMini = require('../../spotify-abba-mini');

var _spotifyAbbaMini2 = _interopRequireDefault(_spotifyAbbaMini);

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FEATURE_FLAG = 'ad_quality_feedback_desktop';

var cosmosConnector = new _cosmosConnector2.default();

function createMessage(creativeId) {
  return {
    message: 'AdFeedbackEvent',
    version: 1,
    fields: ['' + Date.now(), '', // log_id
    '', // line_item_id
    '' + creativeId, '' // displayed_ad_content
    ]
  };
}

function createButton() {
  var button = document.createElement('button');
  button.type = 'button';
  button.className = 'ad-feedback-button';
  return button;
}

function doOnce(fn) {
  var count = 0;

  return function () {
    if (count === 0) {
      count++;
      return fn.apply(this, arguments);
    }
  };
}

/**
 * Create an adFeedbackButton.
 * @param {Object} creativeId
 * @return {Object} adFeedbackButton
 * @return {Function} adFeedbackButton.appendTo
 * @example
 * AdFeedbackButton(creativeId).appendTo(parentNode);
 */
function AdFeedbackButton(creativeId) {
  var adFeedbackButton = {};
  var button = createButton();

  adFeedbackButton.appendTo = function (parentNode) {
    parentNode.appendChild(button);
  };

  adFeedbackButton._logMessage = doOnce(function (message) {
    cosmosConnector.logMessage(message);
  });

  function onClick(e) {
    e.preventDefault();
    e.stopPropagation();
    adFeedbackButton._logMessage(createMessage(creativeId));
    button.disabled = true;
  }

  button.addEventListener('click', onClick);

  return adFeedbackButton;
}

/**
 * Checks if user has feature flag to show adFeedbackButton
 *
 * @example
 * AdFeedbackButton
 * .checkFeatureFlag()
 * .then(function () {
 *   AdFeedbackButton(creativeId).appendTo(parentNode);
 * });
 *
 * @return {Promise} Rejects if not enabled
 */
AdFeedbackButton.checkFeatureFlag = function () {
  return new Promise(function (resolve, reject) {
    (0, _spotifyAbbaMini2.default)(FEATURE_FLAG, function (err, cell) {
      if (err || cell !== FEATURE_FLAG) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
};

exports.default = AdFeedbackButton;

},{"../../spotify-abba-mini":63,"./cosmos-connector":90}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var spotlightSvg = null;

/**
 * Singleton class definining the global configuration.
 * This is going to be injected by index.js and bootstrap.js (tests).
 *
 * @api public
 */
var config = {
  /**
   * Gets spotlight svg
   *
   * @return spotlight svg file
   */

  getSpotlightSvg: function getSpotlightSvg() {
    return spotlightSvg;
  },


  /**
   * @param {svg} svg - spotlight svg file
   */
  setSpotlightSvg: function setSpotlightSvg(svg) {
    spotlightSvg = svg;
  }
};

exports.default = config;

},{}],90:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug')('saf:cosmos-connector');

var sessionId = Date.now();

/**
 * Resource URIs
 */

var AD_CONFIG_ENDPOINT = 'hm://ads/v1/config';
var AD_SLOT_ENDPOINT = 'hm://ads/v1/ads';
var LASERTAG_ENDPOINT = 'hm://lasertag/v1/adtag?alt=json';
var SLOT_URI = 'sp://ads/v1/adslots';
var FORMAT_URI = 'sp://ads/v1/formats/';
var TARGETING_URI = 'sp://ads/v1/targeting';
var STREAMTIME_URI = 'sp://ads/v1/testing/playtime';
var EVENT_URI = 'sp://ads/v1/events/{eventType}/{adId}';
var SETTINGS_URI = 'sp://ads/v1/settings';
var PREVIEW_URI = 'hm://asp/v2/preview/{adId}';
var LOG_URI = 'sp://logging/v1/log';
var SPONSORED_URI = 'hm://sponsoredplaylist/v1/sponsored';
var ABBA_FLAG_URI = 'sp://abba/v1/flags';

var FORMATS = ['audio', 'video', 'banner'];

/**
 * Interface for making cosmos requests in SAF context.
 *
 * Usage:
 *   var cosmosConnector = new CosmosConnector();
 *   cosmosConnector.getTargeting().then(function(){
 *     // do something
 *   })
 *
 * @api public
 * @return {void} Constructor
 */

var CosmosConnector = function () {
  function CosmosConnector() {
    _classCallCheck(this, CosmosConnector);

    this._cosmos = _spotifyCosmosApi2.default;
  }

  /**
   * Set Cosmos for testing purpose.
   *
   * @api public
   * @param {Object} c - cosmos
   */

  _createClass(CosmosConnector, [{
    key: 'setCosmos',
    value: function setCosmos(c) {
      this._cosmos = c;
    }

    /**
     * Fetch targeting data from Ads Resolver via Cosmos.
     *
     * @api public
     * @return {Promise}
     */

  }, {
    key: 'getTargeting',
    value: function getTargeting() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var req = new _this._cosmos.Request('GET', TARGETING_URI, {});

        _this._cosmos.resolver.resolve(req, function (err, res) {
          if (err) reject(new Error(err));else resolve(res.getJSONBody());
        });
      });
    }

    /**
     * Fetch all local targeting, including UI-specific properties such as
     * client width/height.  The returned promise is guaranteed to resolve successfully.
     *
     * @api public
     * @return {Promise}
     */

  }, {
    key: 'getLocalTargeting',
    value: function getLocalTargeting() {
      return this.getTargeting().catch(function (e) {
        debug('error retrieving targeting: %o', e);
        return {};
      }).then(function (targeting) {
        return Object.assign(targeting, {
          client_width: document.body.clientWidth,
          client_height: document.body.clientHeight
        });
      });
    }

    /**
     * Fetch targeting data from Hermes Resolver via Cosmos.
     *
     * @api public
     * @return {Promise}
     */

  }, {
    key: 'getTargetingFromLasertag',
    value: function getTargetingFromLasertag() {
      var req = new this._cosmos.Request('GET', LASERTAG_ENDPOINT, {});

      return this._resolveJSON(req);
    }

    /**
     * Fetch ad slot config from Spotify Ad Service
     * @api public
     * @param {String} slot The slot id (e.g. leaderboard)
     * @return {Promise<Response>} where Response has the shape:
     *   {
     *      "config_ttl_ms": 300000,
     *      "request_when": {
     *         "focus_time_elapsed_ms": number
     *      },
     *      "iframe_sandboxed_attrs": arrayOf(string)
     *      "app_blacklist": arrayOf(string)   // blacklisted app ids
     *      "app_whitelist": arrayOf(string)   // whitelisted app ids
     *   }
     */

  }, {
    key: 'getAdSlotConfig',
    value: function getAdSlotConfig(slot) {
      var req = new this._cosmos.Request('GET', AD_CONFIG_ENDPOINT, {});
      return this._resolveJSON(req).then(function (response) {
        return response[slot];
      });
    }

    /**
     * Fetch an ad from Spotify Ad Service
     * @api public
     * @param {String} slot The slot id (e.g. leaderboard)
     * @param {Object} [flags] Optional map of flag values
     * @return {Promise<Response>} where Response has the shape:
     *   {
     *      "pod": {
     *        "leaderboard": [{
     *          "type": oneOf("text/html"),
     *          "html": string  // html to inject into the iframe
     *        }]
     *      }]
     *   }
     */

  }, {
    key: 'getAdForSlot',
    value: function getAdForSlot(slot, flags) {
      var _this2 = this;

      return this.getLocalTargeting().then(function (targeting) {
        debug('fetch ad for slot=%o, localTargeting=%o', slot, targeting);
        return new _this2._cosmos.Request('GET', AD_SLOT_ENDPOINT + '/' + slot, {}, {
          targeting: targeting,
          pod: {},
          session_id: sessionId,
          overrides: flags || {}
        });
      }).then(this._resolveJSON.bind(this)).then(function (res) {
        if (!res.pod) {
          throw new Error('pod-not-defined');
        }
        if (!res.pod[slot]) {
          throw new Error('slot-not-defined');
        }
        if (res.pod[slot].length === 0) {
          throw new Error('no-ads');
        }
        return res.pod[slot][0];
      });
    }

    /*
     * Fetch preview ad from ASP.
     *
     * @api public
     * @param {String} preview ad id (gid)
     * @return {Promise}
     */

  }, {
    key: 'getPreviewAd',
    value: function getPreviewAd(adId) {
      var req = new this._cosmos.Request('GET', PREVIEW_URI.replace('{adId}', adId), {});

      return this._resolveJSON(req);
    }

    /**
     * Patch targeting by key to value.
     *
     * @api public
     * @param {String|Number} key
     * @param {Object} value
     * @return {Promise}
     */

  }, {
    key: 'patchTargeting',
    value: function patchTargeting(key, value) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var putTargetingRequest = new _this3._cosmos.Request('PUT', TARGETING_URI + '/' + key, { 'Content-Type': 'application/json' }, {
          value: value
        });

        _this3._cosmos.resolver.resolve(putTargetingRequest, function (err) {
          debug('patchTargeting key=%o val=%o req=%o err=%o', key, value, putTargetingRequest, err);
          if (err) reject(new Error(err));else resolve(true);
        });
      });
    }

    /**
     * Increment stream time to receive the next ad break (audio/video).
     *
     * @api public
     * @param {Number} increment in seconds
     * @return {Promise}
     */

  }, {
    key: 'increaseStreamTime',
    value: function increaseStreamTime(increment) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var streamTimeIncreaseRequest = new _this4._cosmos.Request('POST', STREAMTIME_URI, { 'Content-Type': 'application/json' }, {
          value: increment
        });

        _this4._cosmos.resolver.resolve(streamTimeIncreaseRequest, function (err) {
          debug('increaseStreamTime inc=%o err=%o', increment, err);
          if (err) reject(new Error(err));else resolve(true);
        });
      });
    }

    /**
     * Adds a new adslot to a spotlet by ad type
     *
     * @api public
     * @param {String} slotId - E.g. "stream"
     * @param {String} inventoryType - E.g. "video"
     * @return {Promise}
     */

  }, {
    key: 'addNewSlot',
    value: function addNewSlot(slotId, inventoryType) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var postSlotRequest = new _this5._cosmos.Request('POST', SLOT_URI, { 'Content-Type': 'application/json' }, { slot_id: slotId, inventory_types: [inventoryType] });

        _this5._cosmos.resolver.resolve(postSlotRequest, function (err) {
          debug('addNewSlot slotId=%o inventoryType=%o err=%o', slotId, inventoryType, err);
          if (err) reject('addNewSlot error: ', new Error(err));else resolve(SLOT_URI + '/' + slotId + '/' + inventoryType);
        });
      });
    }

    /**
     * Subscribe to an adslot at `uri'
     *
     * @api public
     * @param {String} slotUri - E.g "sp://ads/v1/adslots/stream/video"
     * @param {Function} callback
     * @return {void}
     */

  }, {
    key: 'subscribeToSlot',
    value: function subscribeToSlot(slotUri, callback) {
      var request = new this._cosmos.Request('SUB', slotUri, {});
      this._cosmos.resolver.resolve(request, function (err, res) {
        debug('slot updated uri=%o err=%o res=%o', slotUri, err, res);
        if (!err) callback(res.getJSONBody());
      });
    }

    /**
     * Subscribe to an adslot type. E.g "sp://ads/v1/adslots/preview"
     *
     * @api public
     * @param {String} slotType - E.g "preview"
     * @param {Function} callback
     * @return {Promise}
     */

  }, {
    key: 'subscribeToSlotType',
    value: function subscribeToSlotType(slotType, callback) {
      var request = new this._cosmos.Request('SUB', SLOT_URI + '/' + slotType, {});
      this._cosmos.resolver.resolve(request, function (err, res) {
        debug('slot updated type=%o err=%o res=%o', slotType, err, res);
        if (!err) callback(res.getJSONBody());
      });
    }

    /**
     * Subscribe to a format.
     *
     * @api public
     * @param {String} formatType - E.g "banner"
     * @param {Function} callback
     * @return {Promise}
     */

  }, {
    key: 'subscribeToFormat',
    value: function subscribeToFormat(formatType, callback) {
      var request = new this._cosmos.Request('SUB', FORMAT_URI + formatType, {});
      this._cosmos.resolver.resolve(request, function (err, res) {
        if (!err) callback(res.getJSONBody());
      });
    }
  }, {
    key: 'subscribeToAllFormats',
    value: function subscribeToAllFormats(callback) {
      var _this6 = this;

      FORMATS.map(function (format) {
        _this6.subscribeToFormat(format, function (ev) {
          callback(format, ev);
        });
      });
    }

    /**
     * POST ad event.
     *
     * @api public
     * @param {String} adId
     * @param {String} event
     * @param {Object} payload
     * @return {Promise}
     */

  }, {
    key: 'postEvent',
    value: function postEvent(adId, eventType, payload) {
      var _this7 = this;

      var eventURI = EVENT_URI.replace('{adId}', adId).replace('{eventType}', eventType);

      return new Promise(function (resolve, reject) {
        var postEventRequest = new _this7._cosmos.Request('POST', eventURI, {
          'Content-Type': 'application/json'
        }, payload || {});

        _this7._cosmos.resolver.resolve(postEventRequest, function (err, res) {
          debug('posted event type=%o adId=%o req=%o err=%o res=%o', eventType, adId, postEventRequest, err, res);
          if (err) reject(new Error(err));else resolve(res);
        });
      });
    }

    /**
     * POST to ad slot
     *
     * @api public
     * @param {String} slotId
     * @params {Object} payload
     * @return {Promise}
     */

  }, {
    key: 'postToSlot',
    value: function postToSlot(slotId, payload) {
      var _this8 = this;

      var slotURI = SLOT_URI + '/' + slotId;
      return new Promise(function (resolve, reject) {
        var postSlotIdRequest = new _this8._cosmos.Request('POST', slotURI, {
          'Content-Type': 'application/json'
        }, payload || {});

        _this8._cosmos.resolver.resolve(postSlotIdRequest, function (err, res) {
          debug('posted to slot id=%o req=%o err=%o res=%o', slotId, postSlotIdRequest, err, res);
          if (err) reject(new Error(err));else resolve(res);
        });
      });
    }

    /**
     * Get a specific configuration for a given slot.
     *
     * @param {String} slot Name of the slot.
     * @param {String} key Name of the configuration.
     * @return {Promise} Promise that get's resolved with the result.
     */

  }, {
    key: 'getSlotConfiguration',
    value: function getSlotConfiguration(slot, key) {
      return this.getSlotConfigurations(slot).then(function (response) {
        var result = void 0;
        response.getJSONBody().settings.forEach(function (setting) {
          if (setting.id === slot) {
            result = setting[key];
          }
        });
        return result;
      });
    }

    /**
     * Get the configuration for a given slot.
     *
     * @param {string} slot Name of the slot to get the configuration for.
     * @return {Promise}
     */

  }, {
    key: 'getSlotConfigurations',
    value: function getSlotConfigurations(slot) {
      var method = 'GET';
      var uri = SETTINGS_URI + '/' + slot;
      var headers = { 'Content-Type': 'application/json' };
      var body = {};
      var request = new this._cosmos.Request(method, uri, headers, body);
      return this._resolve(request);
    }

    /**
     * Configure an ad slot.
     *
     * @api public
     * @param {string} slot Name of the slot to configure.
     * @param {string} key Name of the key to configure.
     * @param {string} value New value of the key.
     * @return {Promise}
     */

  }, {
    key: 'configureSlot',
    value: function configureSlot(slot, key, value) {
      var method = 'PUT';
      var uri = SETTINGS_URI + '/' + slot + '/' + key;
      var headers = { 'Content-Type': 'application/json' };
      var body = { value: value };
      var request = new this._cosmos.Request(method, uri, headers, body);
      return this._resolve(request);
    }
  }, {
    key: 'logMessage',
    value: function logMessage(body) {
      var method = 'POST';
      var headers = { 'Content-Type': 'application/json' };
      var request = new this._cosmos.Request(method, LOG_URI, headers, body);
      return this._resolve(request);
    }

    /**
     * Get list of sponsored uris from Sponsored Playlist service
     *
     * @api public
     * @return {Promise}
     */

  }, {
    key: 'getSponsoredUris',
    value: function getSponsoredUris() {
      var req = new this._cosmos.Request('GET', SPONSORED_URI, {});

      return this._resolveJSON(req);
    }

    /**
     * Get sponsorship ad from Sponsored Playlist service
     *
     * @api public
     * @param {String} uri - playlist uri
     * @return {Promise}
     */

  }, {
    key: 'getSponsorshipAd',
    value: function getSponsorshipAd(uri) {
      var req = new this._cosmos.Request('GET', SPONSORED_URI + '/' + uri, {});

      return this._resolveJSON(req);
    }
  }, {
    key: 'subToState',
    value: function subToState(cb) {
      var req = new this._cosmos.Request('SUB', 'sp://ads/v1/state', {});

      this._cosmos.resolver.resolve(req, function (err, res) {
        debug('state update err=%o, res=%o', err, res);
        if (!err) cb(res.getJSONBody());
      });
    }
  }, {
    key: 'getState',
    value: function getState() {
      var req = new this._cosmos.Request('GET', 'sp://ads/v1/state', {});

      return this._resolveJSON(req);
    }

    /**
     * Fetch feature flags from ABBA
     *
     * @api public
     * @param {Array} flags - array of flags to fetch
     * @return {Promise}
     */

  }, {
    key: 'getFeatureFlags',
    value: function getFeatureFlags(flags) {
      var req = new this._cosmos.Request('POST', ABBA_FLAG_URI, { 'Content-Type': 'application/json' }, { flags: flags });

      return this._resolveJSON(req);
    }

    /**
     * Resolve a Cosmos request.
     *
     * @api private
     * @param {Cosmos.Request} request Request to resolve.
     * @return {Promise}
     */

  }, {
    key: '_resolve',
    value: function _resolve(request) {
      var _this9 = this;

      return new Promise(function (resolve, reject) {
        _this9._cosmos.resolver.resolve(request, function (err, res) {
          debug('resolve req=%o, err=%o, res=%o', request, err, res);
          if (err) reject(new Error(err));else resolve(res);
        });
      });
    }

    /**
     * Resolve a cosmos request, and return the JSON result.
     *
     * NOTE: This won't work with SUB requests since the promise will only
     * execute once.
     *
     * @api private
     * @param {Cosmos.Request} request Request to resolve.
     * @return {Promise}
     */

  }, {
    key: '_resolveJSON',
    value: function _resolveJSON(request) {
      return this._resolve(request).then(function (res) {
        return res.getJSONBody();
      });
    }
  }]);

  return CosmosConnector;
}();

exports.default = CosmosConnector;

},{"debug":369,"spotify-cosmos-api":554}],91:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

/**
 * Renders a pie chart like count down timer using SVG.
 *
 * Typical use case:
 *
 * var container = document.getElementById('animation-container');
 * var animation = new CountDownAnimation(container, 2000);
 * ...
 * animation.start(); // start the count down
 *
 * @param {Element} container - Container to render the count down in.
 * @param {Number} duration - Animation duration in ms.
 */

var CountDownAnimation = function () {
  function CountDownAnimation(container, duration) {
    _classCallCheck(this, CountDownAnimation);

    this._container = container;
    this._duration = duration;
    this._started = 0;
    this._remaining = 1.0;
    this._animate = this._animate.bind(this);
    this._setupDomNodes();
    this._draw(); // Render first frame
  }

  /**
   * Start the animation.
   *
   * @public
   */

  _createClass(CountDownAnimation, [{
    key: 'start',
    value: function start() {
      this._started = new Date().getTime();
      this._animate();
    }

    /**
     * Create the dom nodes needed for the animation.
     *
     * @private
     */

  }, {
    key: '_setupDomNodes',
    value: function _setupDomNodes() {
      this._svg = document.createElementNS(SVG_NAMESPACE, 'svg');
      this._svg.setAttribute('id', 'countdown');
      this._svg.setAttribute('width', '20');
      this._svg.setAttribute('height', '20');

      this._circle = document.createElementNS(SVG_NAMESPACE, 'circle');
      this._circle.setAttribute('cx', '10');
      this._circle.setAttribute('cy', '10');
      this._circle.setAttribute('r', '5');
      this._circle.setAttribute('fill', 'none');
      this._circle.setAttribute('stroke', '#dfe0e6');
      this._circle.setAttribute('stroke-width', '10');
      this._circle.setAttribute('stroke-dasharray', '0 31.4159 31.4159 0');
      this._circle.setAttribute('stroke-dashoffset', '0');
      this._circle.setAttribute('transform', 'rotate(-90 10 10)');

      this._svg.appendChild(this._circle);
      this._container.appendChild(this._svg);
    }

    /**
     * Draw the current state of the animation.
     *
     * @private
     */

  }, {
    key: '_draw',
    value: function _draw() {
      var offset = Math.max(this._remaining, 0) * Math.PI * 10;
      this._circle.setAttribute('stroke-dashoffset', offset);
    }

    /**
     * Start animating the count down timer.
     *
     * @private
     */

  }, {
    key: '_animate',
    value: function _animate() {
      var elapsed = new Date().getTime() - this._started;
      this._remaining = 1 - elapsed / this._duration;
      this._draw();
      if (this._remaining > 0) {
        requestAnimationFrame(this._animate);
      }
    }
  }]);

  return CountDownAnimation;
}();

exports.default = CountDownAnimation;

},{}],92:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyEventDispatcher = require('../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _messageProxy = require('../../message-proxy');

var _messageProxy2 = _interopRequireDefault(_messageProxy);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _eventTypes = require('./event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _billboardAd = require('./formats/billboard-ad');

var _billboardAd2 = _interopRequireDefault(_billboardAd);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cosmosConnector = new _cosmosConnector2.default();

var debugLog = (0, _debug2.default)('saf:debug');

// Setup debug logging so that formatted objects will show up
// in the TA console log retrieved via the Selenium API.
function setupDebugTALogging() {
  (0, _debug2.default)('Setup TA Logging');
  _debug2.default.useColors = function () {
    return false;
  };
  _debug2.default.formatters.o = JSON.stringify;
  subToFormats();
}

if (typeof localStorage !== 'undefined' && localStorage.getItem('ads.debug.setupTA')) {
  setupDebugTALogging();
}

// Check Zlink for ads.debug.setupTA
(0, _messageProxy2.default)({ method: 'GET', uri: 'ads-debug-ta' }, function (err, response) {
  if (err) return;
  var body = JSON.parse(response.body);
  if (body.enabled) {
    setupDebugTALogging();
  }
});

/**
 * Overrides default cosmos connector instance
 *
 * @param {CosmosConnector} newCosmosConnectorInstance new instance
 */

function setCosmosConnector(newCosmosConnectorInstance) {
  cosmosConnector = newCosmosConnectorInstance;
}

/**
 * Overrides a targeting attribute for debugging purpose
 *
 * E.g.
 *   patchTargeting('aduserid', 1111);
 *
 * @api protected
 * @param {String} key targeting key.
 * @param {String} value targeting value.
 */

function patchTargeting(key, value) {
  return cosmosConnector.patchTargeting(key, value);
}

/**
 * Override an aduserid (ppid) for ads targeting and frequency capping
 */
function setAdUserId(value) {
  return patchTargeting('aduserid', value);
}

/**
 * Refreshes all active leaderboards
 */

function refreshLeaderboard() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_FORCE_REFRESH_LEADERBOARD,
    'params': {},
    'extra': {}
  });
}

/**
 * Refreshes all active hpto
 */

function refreshHPTO() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_FORCE_REFRESH_HPTO,
    'params': {},
    'extra': {}
  });
}

/**
 * Sets timeout for billboard
 */

function setBillboardTimeout(seconds) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_SET_BILLBOARD_TIMEOUT,
    'params': {
      timeout: seconds * 1000
    },
    'extra': {}
  });
}

/**
 * Sets timeout for billboard
 */

function triggerBillboard() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_FORCE_REFRESH_BILLBOARD,
    'params': {},
    'extra': {}
  });
}

/**
 * Increases user stream time
 */

function increaseStreamTime(seconds) {
  return cosmosConnector.increaseStreamTime(seconds);
}

/**
 * Retreive the ad server endpoint from core
 *
 * @param {string} slot The ad slot to get endpoint for
 * @return {Promise}
 */

function getAdServerEndpoint(slot) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    cosmosConnector.getSlotConfigurations(slot).then(function (res) {
      if (res.getStatusCode() === 200) {
        var endpoint = res.getJSONBody().settings[0][key];
        resolve(endpoint);
      } else {
        reject('Unable to get slot settings for slot ' + slot);
      }
    });
  });
}

/**
 * Tell core to request ads from ad mocker and not from DFP for a given ad slot.
 *
 * Endpoint should look like "http://foo.bar.net?foo=baz"
 *
 * @api public
 * @param {string} slot The ad slot to use ad mocker for.
 * @param {string} endpoint The endpoint to fetch ads from for the given slot.
 * @return {Promise}
 */

function overrideAdServerEndpoint(slot, endpoint) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    cosmosConnector.configureSlot(slot, key, endpoint).then(function (res) {
      if (res.getStatusCode() === 200) {
        resolve();
      } else {
        reject('Unable to set slot settings for slot ' + slot);
      }
    });
  });
}

/**
 * Tell core to request ads from ad mocker and not from DFP for a given ad slot.
 *
 * Endpoint should look like "http://foo.bar.net"
 *
 * @api public
 * @param {string} slot The ad slot to use ad mocker for.
 * @param {string} endpoint The endpoint to fetch ads from for the given slot.
 * @param {string} sessionId The test automation session id.
 * @return {Promise}
 */

function setAdServerEndpoint(slot, endpoint, sessionId) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    cosmosConnector.getSlotConfigurations(slot).then(function (resp) {
      if (resp.getStatusCode() === 200) {
        var updated = resp.getJSONBody().settings[0][key].replace('https://pubads.g.doubleclick.net', endpoint);
        updated += '&session_id=' + sessionId;

        cosmosConnector.configureSlot(slot, key, updated).then(function (res) {
          if (res.getStatusCode() === 200) {
            resolve();
          } else {
            reject('Unable to set slot settings for slot ' + slot);
          }
        });
      } else {
        reject('Unable to set slot settings for slot ' + slot);
      }
    });
  });
}

function getAdSlotConfigurations(slot, cb) {
  cosmosConnector.getSlotConfigurations(slot).then(function (res) {
    if (res.getStatusCode() === 200) {
      (cb || function (body) {
        debugLog('config for slot=%o, res=%o', slot, res);
      })(res.getJSONBody());
    } else {
      throw new Error('bad status code from slot config: ' + resp.getStatusCode());
    }
  });
}

/**
 * Get the spotify ad format version
 *
 * @return {String}
 */

function getVersion() {
  return require('../package.json').version;
}

/**
 * Clear an ad slot in core
 *
 * @param {String} slot The name of the slot to clear.
 * @return {Promise}
 */

function clearSlot(slot) {
  return cosmosConnector.postToSlot(slot, {
    intent: 'clear'
  });
}

function configureSlot(slot, k, v) {
  return cosmosConnector.configureSlot(slot, k, v);
}

function subToState(cb) {
  return cosmosConnector.subToState(function (res) {
    if (cb) {
      cb(res);
    } else {
      debugLog('ads state updated: %o', res.state);
    }
  });
}

function subToFormats(cb) {
  return cosmosConnector.subscribeToAllFormats(function (fmt, ev) {
    (cb || function () {
      debugLog('event for format %o: %o', fmt, ev);
    })(fmt, ev);
  });
}

function getState(cb) {
  return cosmosConnector.getState().then(function (res) {
    if (cb) {
      cb(res);
    } else {
      debugLog('ads state: %o', res.state);
    }
  });
}

function setAdLeaderboardHtml(html) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_HTML,
    'params': {
      html: html
    },
    'extra': {}
  });
}

function setLeaderboardAdSlotFlags(flags) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    type: _eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_FLAGS,
    params: {
      flags: flags
    }
  });
}

function setLeaderboardRefreshIntervalMs(ms) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    type: _eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_REFRESH_INTERVAL,
    params: {
      interval: ms
    }
  });
}

function vikingboardOn() {
  setLeaderboardAdSlotFlags({ viking: true });
}

function vikingboardOff() {
  setLeaderboardAdSlotFlags({ viking: false });
}

var receivedAdLeaderboardHtml = '';
_spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_RECEIVED_AD_LEADERBOARD_HTML, function (e) {
  receivedAdLeaderboardHtml = e.params.html;
});

function getReceivedAdLeaderboardHtml() {
  return receivedAdLeaderboardHtml;
}

exports.default = {
  setCosmosConnector: setCosmosConnector,
  patchTargeting: patchTargeting,
  refreshLeaderboard: refreshLeaderboard,
  refreshHPTO: refreshHPTO,
  setBillboardTimeout: setBillboardTimeout,
  triggerBillboard: triggerBillboard,
  increaseStreamTime: increaseStreamTime,
  getAdServerEndpoint: getAdServerEndpoint,
  overrideAdServerEndpoint: overrideAdServerEndpoint,
  setAdServerEndpoint: setAdServerEndpoint,
  getVersion: getVersion,
  clearSlot: clearSlot,
  subToState: subToState,
  subToFormats: subToFormats,
  getState: getState,
  configureSlot: configureSlot,
  debug: _debug2.default,
  BillboardAd: _billboardAd2.default,
  setAdUserId: setAdUserId,
  setAdLeaderboardHtml: setAdLeaderboardHtml,
  getReceivedAdLeaderboardHtml: getReceivedAdLeaderboardHtml,
  getAdSlotConfigurations: getAdSlotConfigurations,
  setLeaderboardAdSlotFlags: setLeaderboardAdSlotFlags,
  vikingboardOn: vikingboardOn,
  vikingboardOff: vikingboardOff,
  setLeaderboardRefreshIntervalMs: setLeaderboardRefreshIntervalMs
};

},{"../../message-proxy":61,"../../spotify-event-dispatcher":146,"../package.json":86,"./cosmos-connector":90,"./event-types":96,"./formats/billboard-ad":99,"debug":369}],93:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * DFP Request Network ID
 */

var NETWORK_ID = 6465052;

var TEMPLATES = {
  gpt: require('./templates/gpt.hbs')
};

/*
 * Returns template based on name
 *
 * @param {String} name
 * @return {hbs}
 */
function template(name) {
  return TEMPLATES[name];
}

/**
 * Create dfp inventory unit from device/product data
 * @param {String} platform
 * @param {Boolean} isPremium
 * @return {String} inventory unit
 */
function inventoryUnit(platform, isPremium) {
  var unit = isPremium ? 'premium-' + platform : platform;

  return '/' + NETWORK_ID + '/' + unit;
}

function parseHptoHtml(iframeDoc) {
  var tplSpans = iframeDoc.body.getElementsByTagName('span');
  var jsonContent = null;
  var html = '';

  for (var i = 0, len = tplSpans.length; i < len; i++) {
    var templateName = tplSpans[i].getAttribute('data-template');

    if (templateName === 'hpto-json') {
      try {
        jsonContent = JSON.parse(tplSpans[i].innerHTML);
      } catch (e) {
        return null;
      }
    } else if (templateName === 'hpto-html') {
      html = tplSpans[i].innerHTML;
    }
  }

  if (!jsonContent) {
    return null;
  }

  jsonContent.hpto.html = html;

  return jsonContent;
}

/**
 * @param {Object} data
 * @param {String} data.inventoryType
 * @param {String} data.width
 * @param {String} data.height
 * @param {String} data.inventoryUnit
 * @param {String} data.targetingData
 * @param {String} data.ppid
 * @return {String} compiled html
 */
function renderGPT(data) {
  var dfpSlotId = data.inventoryType + '-' + new Date().getTime();
  return TEMPLATES.gpt({
    slotId: dfpSlotId,
    width: data.width,
    height: data.height,
    inventoryUnit: data.inventoryUnit,
    targetingParameters: data.targetingData,
    ppid: data.ppid
  });
}

function fetchHptoAd(domEl, targetingData) {
  return new Promise(function (resolve, reject) {
    var iframe = _utils2.default.createSandboxedIframe();
    iframe.style.display = 'none';

    domEl.appendChild(iframe);

    var iframeDoc = iframe.contentDocument;

    iframeDoc.open();
    iframeDoc.write(renderGPT(targetingData));
    iframeDoc.close();

    iframeDoc.addEventListener('placementReady', function () {
      var hptoData = parseHptoHtml(iframeDoc);
      iframe.parentNode.removeChild(iframe);
      resolve(hptoData);
    });

    iframeDoc.addEventListener('eventEmpty', function () {
      reject(new Error('[HPTO dfp] Returned empty event'));
    });
  });
}

exports.default = {
  NETWORK_ID: NETWORK_ID,
  template: template,
  inventoryUnit: inventoryUnit,
  renderGPT: renderGPT,
  parseHptoHtml: parseHptoHtml,
  fetchHptoAd: fetchHptoAd
};

},{"../utils":130,"./templates/gpt.hbs":94}],94:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          .setTargeting(\"";
  stack1 = ((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\",\"";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\")\n        ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n              '";
  stack1 = ((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "': '";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "',\n              ";
  return buffer;
  }

  buffer += "<html>\n  <head>\n    <script type=\"text/javascript\">\n      var googletag = googletag || {};\n      googletag.cmd = googletag.cmd || [];\n\n      (function() {\n        var useSSL = true;\n        var src = (useSSL ? 'https:' : 'http:') +\n                  '//www.googletagservices.com/tag/js/gpt.js';\n        document.write('<scr' + 'ipt src=\"' + src + '\"></scr' + 'ipt>');\n      })();\n\n      googletag.cmd.push(function() {\n        googletag.defineSlot('";
  if (helper = helpers.inventoryUnit) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.inventoryUnit); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "', [[";
  if (helper = helpers.width) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.width); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ", ";
  if (helper = helpers.height) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.height); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "]],\n          '";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\n          .addService(googletag.pubads().setPublisherProvidedId('";
  if (helper = helpers.ppid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.ppid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "'))\n\n        ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.targetingParameters), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ";\n\n        googletag.pubads().addEventListener(\"slotRenderEnded\", function(event) {\n          var msg = event.isEmpty ? \"eventEmpty\" : \"placementReady\";\n\n          // Attach data to the window for parent impression logging\n          window.slotRenderEndedObj = {\n            creativeId: event.creativeId,\n            lineItemId: event.lineItemId,\n            slot: '";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "',\n            targetingParams: {\n              ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.targetingParameters), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            }\n          };\n\n          var e = new CustomEvent(msg);\n          document.dispatchEvent(e);\n        });\n\n        googletag.pubads().set(\"page_url\", \"http://www.spotify.com\");\n\n        googletag.pubads().enableSingleRequest();\n        googletag.pubads().enableSyncRendering();\n        googletag.enableServices();\n      });\n    </script>\n  </head>\n  <body style=\"margin:0px\">\n    <div id=\"";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"width: ";
  if (helper = helpers.width) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.width); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px; height: ";
  if (helper = helpers.height) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.height); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px\">\n      <script type=\"text/javascript\">\n        googletag.cmd.push(function() { googletag.display(\"";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"); });\n      </script>\n    </div>\n  </body>\n</html>\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventLogger = undefined;
exports.factory = factory;

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function factory(_ref) {
  var cosmosConnector = _ref.cosmosConnector;
  var debug = _ref.debug;
  var Promise = _ref.Promise;

  function EventLogger(adId) {
    if (!adId) throw new Error('adId is required');

    var promise = Promise.resolve();

    this.logEvent = function (eventName, payload) {
      promise = promise.catch(function () {}).then(function () {
        return cosmosConnector.postEvent(adId, eventName, payload);
      }).then(function () {
        debug(adId, eventName, payload);
        return true;
      }).catch(function (err) {
        debug(adId, eventName, payload, err);
        throw err;
      });

      return promise;
    };
  }

  return EventLogger;
}

var EventLogger = exports.EventLogger = factory({
  cosmosConnector: new _cosmosConnector2.default(),
  debug: (0, _debug3.default)('saf:event-logger'),
  Promise: Promise
});

},{"./cosmos-connector":90,"debug":369}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  AD_AUDIO_STARTED: 'ad:audio:started',
  AD_AUDIO_FINISHED: 'ad:audio:finished',

  AD_VIDEO_STARTED: 'ad:video:started',
  AD_VIDEO_FINISHED: 'ad:video:finished',

  AD_BILLBOARD_STARTED: 'ad:billboard:started',
  AD_BILLBOARD_HIDDEN: 'ad:billboard:hidden',
  AD_BILLBOARD_VISIBLE: 'ad:billboard:visible',
  AD_BILLBOARD_FOCUS_RECEIVED: 'ad:billboard:focusreceived',
  AD_BILLBOARD_DISCARDED: 'ad:billboard:discarded',
  AD_BILLBOARD_FINISHED: 'ad:billboard:finished',
  AD_BILLBOARD_MINIMIZED: 'ad:billboard:minimized',

  AD_CLICK_VIDEO_STARTED: 'ad:clickvideo:started',
  AD_CLICK_VIDEO_ENDED: 'ad:clickvideo:ended',

  AD_HPTO_HIDDEN: 'ad:hpto:hidden',
  AD_HPTO_RENDERED: 'ad:hpto:rendered',

  AD_LEADERBOARD_ERROR: 'ad:leaderboard:error',
  AD_LEADERBOARD_PLACEMENT: 'ad:leaderboard:placement',
  AD_LEADERBOARD_USED_DEFAULT: 'ad:leaderboard:used:default',

  AD_PLAYER_STATE_EVENT: 'ad:player:event',

  AD_SPONSORSHIP_ACTIVE: 'ad:sponsorship:active',

  PLAYER_PAUSE: 'pause',
  PLAYER_RESUME: 'resume',

  NAVIGATION_OPEN_URI: 'open_uri',
  NAVIGATION_HISTORY_CHANGE: 'historychange',
  NAVIGATION_STATE_CHANGE: 'statechange',
  NAVIGATION_UPGRADE: 'upgrade_premium',

  UI_VISIBILITY: 'visibilitystatechanged', // Deprecated

  APPLICATION_FOCUS_LOST: 'application:focus:lost',
  APPLICATION_FOCUS_GAINED: 'application:focus:gained',

  DEBUG_FORCE_REFRESH_LEADERBOARD: 'debug:ad:force_refresh:leaderboard',
  DEBUG_FORCE_REFRESH_HPTO: 'debug:ad:force_refresh:hpto',
  DEBUG_SET_BILLBOARD_TIMEOUT: 'debug:ad:set:billboard_timeout',
  DEBUG_FORCE_REFRESH_BILLBOARD: 'debug:ad:force_refresh:billboard',
  DEBUG_OVERRIDE_AD_LEADERBOARD_HTML: 'debug:ad:override:leaderboard:html',
  DEBUG_RECEIVED_AD_LEADERBOARD_HTML: 'debug:received:ad:leaderboard:html',
  DEBUG_OVERRIDE_AD_LEADERBOARD_FLAGS: 'debug:ad:override:leaderboard:flags',
  DEBUG_OVERRIDE_AD_LEADERBOARD_REFRESH_INTERVAL: 'debug:ad:override:leaderboard:refreshinterval'
};

},{}],97:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var comscore = exports.comscore = 'http://b.scorecardresearch.com/p?c1=2&c2=15654041&c7=http%3A%2F%2Fwww.spotify-desktop.com&cv=2.0&cj=1';

},{}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cosmosConnector = require('../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cosmosConnector = new _cosmosConnector2.default();
var emitter = new _events.EventEmitter();

// EVENTS
var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var adId = null;
var element = null;
var isActive = false;
var isEnabled = false;
var isInitialized = false;

/**
 * @module AudioCompanionAd
 */
var AudioCompanionAd = {};

/**
 * @param {Object} opts
 * @param {HTMLElement} opts.element
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.init = function (opts) {
  if (isInitialized) throwErrorMsg('already initialized');
  element = opts && opts.element;
  isInitialized = true;
  return AudioCompanionAd;
};

/**
 * @param {String} id
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.setAdId = function (id) {
  adId = id;
  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.enable = function () {
  if (!isEnabled) {
    element.addEventListener('click', onCompanionClick);
    emitter.emit(ENABLED);
  }

  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.disable = function () {
  if (isEnabled) {
    element.removeEventListener('click', onCompanionClick);
    emitter.emit(DISABLED);
  }

  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return AudioCompanionAd;
};

/**
 * @param {String} eventName
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return AudioCompanionAd;
};

/**
 * @return {Boolean} isEnabled
 */
AudioCompanionAd.isEnabled = function () {
  return isEnabled;
};

/**
 * @return {Boolean} isActive
 */
AudioCompanionAd.isActive = function () {
  return isActive;
};

AudioCompanionAd.EVENTS = {
  ENABLED: ENABLED,
  DISABLED: DISABLED,
  ACTIVE: ACTIVE,
  INACTIVE: INACTIVE
};

emitter.on(ENABLED, function () {
  isEnabled = true;
  emitter.emit(ACTIVE);
});

emitter.on(DISABLED, function () {
  isEnabled = false;
  emitter.emit(INACTIVE);
});

emitter.on(ACTIVE, function () {
  isActive = true;
});

emitter.on(INACTIVE, function () {
  isActive = false;
});

function throwErrorMsg(errMsg) {
  throw new Error('AudioCompanionAd: ' + errMsg);
}

function postEvent(eventName) {
  if (!adId) throwErrorMsg('adId not set');
  cosmosConnector.postEvent(adId, eventName).catch(function (err) {
    console.error(err);
  });
}

function onCompanionClick(e) {
  e.preventDefault();
  postEvent('clicked');
}

exports.default = AudioCompanionAd;

},{"../cosmos-connector":90,"events":371}],99:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require('events');

var _spotifyAbbaMini = require('../../../../spotify-abba-mini');

var _spotifyAbbaMini2 = _interopRequireDefault(_spotifyAbbaMini);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _audioCompanionAd = require('../audio-companion-ad');

var _audioCompanionAd2 = _interopRequireDefault(_audioCompanionAd);

var _view = require('./view');

var _view2 = _interopRequireDefault(_view);

var _formatEvents = require('../format-events');

var _formatEvents2 = _interopRequireDefault(_formatEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emitter = new _events.EventEmitter();
var debug = require('debug')('saf:billboard-ad');

var cosmosConnector = new _cosmosConnector2.default();

var PREVIEW_SLOT_ID = 'preview';
var SLOT_ID = 'billboard';
var INVENTORY_TYPE = 'video';
var SLOT_URI = 'sp://ads/v1/adslots/' + SLOT_ID;

var BLACKLISTED_URIS = ['ad', 'browse', 'charts', 'discover', 'hub'];

var MINUTES_MS = 1000 * 60;
var DEFAULT_FOCUS_TIMEOUT_MS = 3 * MINUTES_MS;

var overrideTimeoutMs = null;
var view = null;
var timerSetupView = null;
var timerFetchRetry = null;
var pageIsBlackListed = false;

var clientState = {
  audioAdIsPlaying: false,
  videoAdIsPlaying: false,
  isActive: true,
  hasFocus: true
};

var containerEl = null;
var isInitialized = false;
var isActive = false;
var isEnabled = false;
var videoEnabled = false;

/**
 * @module BillboardAd
 */
var BillboardAd = {};
BillboardAd.EVENTS = _formatEvents2.default;

/**
 * @param {Object} opts
 * @param {HTMLElement} opts.element
 * @return {BillboardAd}
 */
BillboardAd.init = function (opts) {
  if (!isInitialized) {
    containerEl = opts && opts.element;
    isInitialized = true;
  }
  return BillboardAd;
};

/**
 * @return {BillboardAd}
 */
BillboardAd.enable = function () {
  if (!isInitialized) throw new Error('Not initialized yet');

  if (!isEnabled) {
    addListeners();

    cosmosConnector.subscribeToSlot(SLOT_URI, onCoreMessage);

    emitter.emit(BillboardAd.EVENTS.ENABLED);
    debug('enabled');
  }

  return BillboardAd;
};

/**
 * Disable the billboard component inside the container.
 * @return {BillboardAd}
 */
BillboardAd.disable = function () {
  if (isEnabled) {
    removeListeners();
    finish();

    emitter.emit(BillboardAd.EVENTS.DISABLED);
    debug('disabled');
  }

  return BillboardAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {BillboardAd}
 */
BillboardAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return BillboardAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {BillboardAd}
 */
BillboardAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return BillboardAd;
};

/**
 * @return {Boolean} isEnabled
 */
BillboardAd.pageIsBlackListed = function () {
  return pageIsBlackListed;
};

/**
 * @return {Boolean} isEnabled
 */
BillboardAd.isEnabled = function () {
  return isEnabled;
};

/**
 * @return {Boolean} isEnabled
 */
BillboardAd.isActive = function () {
  return isActive;
};

/**
 * @private For testing only
 * @param {EventEmitter} _emitter
 * @return {void}
 */
BillboardAd._setEmitter = function (_emitter) {
  emitter = _emitter;
};

// TODO move responsibility to activitytracker
BillboardAd.setApplicationInactive = function () {
  clearTimeout(timerSetupView);

  if (view && view.activated) {
    return;
  }

  fetchFromDFPWhenPossible();

  clientState.isActive = false;
};

function getFocusTimeoutMs() {
  if (overrideTimeoutMs) {
    debug('use overrideTimeoutMs: %o', overrideTimeoutMs);
    return Promise.resolve(overrideTimeoutMs);
  }
  return cosmosConnector.getSlotConfiguration(SLOT_ID, 'display_time_interval').then(function (triggerAfterFocusLostS) {
    if (triggerAfterFocusLostS && triggerAfterFocusLostS > 0) {
      debug('using billboard slot config focus time (seconds): %o', triggerAfterFocusLostS);
      return triggerAfterFocusLostS * 1000;
    }
    throw new Error('triggerAfterFocusLostS is not a positive integer: ' + triggerAfterFocusLostS);
  }).catch(function (err) {
    debug('error getting display time interval: %o', err);
    return DEFAULT_FOCUS_TIMEOUT_MS;
  });
}
BillboardAd.getFocusTimeoutMs = getFocusTimeoutMs;

emitter.on(BillboardAd.EVENTS.ENABLED, function () {
  isEnabled = true;
});

emitter.on(BillboardAd.EVENTS.DISABLED, function () {
  isEnabled = false;
});

emitter.on(BillboardAd.EVENTS.ACTIVE, function () {
  isActive = true;
});

emitter.on(BillboardAd.EVENTS.INACTIVE, function () {
  isActive = false;
});

/**
 * Initialize format with listeners / subscriptions
 * @return {Promise}
 */
function addListeners() {
  _view2.default.on('INACTIVE', function () {
    emitter.emit(BillboardAd.EVENTS.INACTIVE);
    debug('inactive');
  });

  _audioCompanionAd2.default.on(_audioCompanionAd2.default.EVENTS.ACTIVE, onAudioAdChange.bind(null, true));

  _audioCompanionAd2.default.on(_audioCompanionAd2.default.EVENTS.INACTIVE, onAudioAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_VIDEO_STARTED, onVideoAdChange.bind(null, true));

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_VIDEO_FINISHED, onVideoAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_BILLBOARD_FINISHED, onBillboardAdFinished);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_BILLBOARD_FOCUS_RECEIVED, onBillboardAdFocused);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_SET_BILLBOARD_TIMEOUT, onBillboardSetOverrideTimeout);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_BILLBOARD, fetchFromDFP);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.APPLICATION_FOCUS_LOST, onApplicationFocusLost);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.APPLICATION_FOCUS_GAINED, onApplicationFocusGained);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, onNavigationStateChanged);

  BillboardAd._abbaVideoFlag().then(function (isEnabled) {
    debug('abbaCheck: videoEnabled=%o', isEnabled);
    videoEnabled = isEnabled;
  });

  cosmosConnector.subscribeToSlotType(PREVIEW_SLOT_ID, function (data) {
    if (!data.ad.companion_ad) {
      return; // Preview for a leaderboard, just ignore
    }
    switch (data.event) {
      case 'available':
        cosmosConnector.postToSlot(PREVIEW_SLOT_ID, {
          intent: 'now' // This will trigger a "play" event
        });
        break;
      case 'play':
        debug('play: data=%o', data);
        BillboardAd._render(data);
        emitter.emit(BillboardAd.EVENTS.ACTIVE);
        break;
      default:
        throw new Error('Unknown core event from preview slot: ' + data.event);
    }
  });

  cosmosConnector.addNewSlot(SLOT_ID, INVENTORY_TYPE);

  return;
}

BillboardAd._abbaVideoFlag = function () {
  return new Promise(function (resolve) {
    (0, _spotifyAbbaMini2.default)('ad_video_billboard', function (err, cell) {
      resolve(cell === 'Enabled');
    });
  });
};

/**
 * @return {void}
 */
function removeListeners() {
  _audioCompanionAd2.default.off(_audioCompanionAd2.default.EVENTS.ACTIVE, onAudioAdChange.bind(null, true));

  _audioCompanionAd2.default.off(_audioCompanionAd2.default.EVENTS.INACTIVE, onAudioAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_VIDEO_STARTED, onVideoAdChange.bind(null, true));

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_VIDEO_FINISHED, onVideoAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_BILLBOARD_FINISHED, onBillboardAdFinished);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_BILLBOARD_FOCUS_RECEIVED, onBillboardAdFocused);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.DEBUG_SET_BILLBOARD_TIMEOUT, onBillboardSetOverrideTimeout);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_BILLBOARD, fetchFromDFP);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.APPLICATION_FOCUS_LOST, onApplicationFocusLost);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.APPLICATION_FOCUS_GAINED, onApplicationFocusGained);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, onNavigationStateChanged);
}

/**
 * Callback for ad slot messages from ads core.
 * @private
 * @param  {data} data Event data.
 * @return {void}
 */
function onCoreMessage(data) {
  switch (data.event) {
    case 'available':
      debug('available & active', data);
      onAvailable(data);
      break;
    case 'play':
      debug('play: data=%o', data);
      onPlay(data);
      break;
    case 'discard':
      debug('discard: data=%o', data);
      onDiscard();
      break;
    default:
      throw '[Billboard] Unsupported event type: ' + data.event;
  }
}

function onAvailable(data) {
  var canRender = canShow() && (!clientState.hasFocus || !clientState.isActive);

  // TODO abba flag - remove after 100% rollout
  if (data.format === 'video' && !videoEnabled) {
    clearSlot().then(function () {
      setTimeout(fetchFromDFP, 10000);
    });
  } else if (canRender) {
    BillboardAd._render(data);
    emitter.emit(BillboardAd.EVENTS.ACTIVE);
    debug('active');
  } else {
    clearSlot();
  }
}

function onPlay() {
  view.play();
}

/**
 * Handles discard message from core
 * This happens on two occasions:
 *  1) When we fire an intent 'clear' message
 *  2) When click url expires, core sends a discard message
 * @private
 * @return {void}
 */
function onDiscard() {
  if (view) {
    (function () {
      var requestNewAd = !view.activated;

      view.destroy().then(function () {
        // Refetch because click url expired
        if (requestNewAd) {
          setTimeout(fetchFromDFP, 10000);
        }
      });

      view = null;
    })();
  }
}

/**
 * Render an ad retrieved from core
 * @param  {Object} ad The ad from core
 * @return {void}
 */
BillboardAd._render = function (data) {
  view = new _view2.default(containerEl, data);
  view.setup();
};

/**
 * Tell core to fetch a new ad from DFP
 * @private
 * @return {void}
 */
function fetchFromDFP() {
  debug('fetchFromDFP');
  cosmosConnector.postToSlot(SLOT_ID, { intent: 'fetch' }).catch(logError);
}

/**
 * Fetch a new billboard ad from DFP whenever one is allowed to show.
 * @private
 * @return {void}
 */
function fetchFromDFPWhenPossible() {
  clearTimeout(timerFetchRetry);
  if (canShow()) {
    fetchFromDFP();
  } else {
    debug('cannot show, retrying in 5s');
    timerFetchRetry = setTimeout(function () {
      fetchFromDFPWhenPossible();
    }, 5000);
  }
}

/* --------------- *
 * Event callbacks *
 * --------------- */

/**
 * Callback for when the navigation history has changed
 * (when user visits a new page in the client)
 * @param {Event} e - dispatcher event.
 */
function onNavigationStateChanged(e) {
  var uri = _spotifyLiburi2.default.from(e.params.uri);
  if (uri && BLACKLISTED_URIS.indexOf(uri.id) > -1) {
    pageIsBlackListed = true;
    finish();
  } else {
    pageIsBlackListed = false;
    minimize();
  }
}

/**
 * Callback for when the app has received focus
 */
function onApplicationFocusGained() {
  clientState.hasFocus = true;
  clearTimeout(timerFetchRetry);
  clearTimeout(timerSetupView);
  if (view) {
    if (canShow()) {
      view.onFocusReceived();
    } else {
      finish();
    }
  }
}

/**
 * Callback for when the app has lost focus.
 */
function onApplicationFocusLost() {
  debug('applicationFocusLost');
  if (view && view.activated) {
    debug('view already active');
    return;
  }

  clientState.hasFocus = false;
  clearTimeout(timerSetupView);
  getFocusTimeoutMs().then(function (timeoutMs) {
    debug('set fetch timeout (ms): %o', timeoutMs);
    timerSetupView = setTimeout(fetchFromDFPWhenPossible, timeoutMs);
  });
}

/**
 * @param  {Boolean} isPlaying
 * @return {void}
 */
function onAudioAdChange(isPlaying) {
  clientState.audioAdIsPlaying = isPlaying;
  updateOnClientChange();
}

/**
 * @param  {Boolean} isPlaying
 * @return {void}
 */
function onVideoAdChange(isPlaying) {
  clientState.videoAdIsPlaying = isPlaying;
  updateOnClientChange();
}

function updateOnClientChange() {
  if (!view) return; // No need to do anything

  if (canShow()) {
    // Ad break ended
    view.fadeIn();
  } else {
    // Ad break started
    if (view.isUserMaximized()) {
      finish(); // Prevent it from flashing between ads in an ad break
    } else {
      view.fadeOut();
    }
  }
}

/**
 * Set new timeout from devtools
 * @param  {Event} e - dispatcher event
 * @return {void}
 */
function onBillboardSetOverrideTimeout(e) {
  overrideTimeoutMs = e.params.timeout;
}

/**
 * Callback for when the billboard ad view has received focus.
 * @param {Event} e The event triggered.
 */
function onBillboardAdFocused() {
  clientState.isActive = true;
}

/**
 * Callback for when billboard is finished
 */
function onBillboardAdFinished() {
  view = null;
}

/* ---------------- *
 * Helper functions *
 * ---------------- */

function logError(err) {
  debug(err.message);
}

function clearSlot() {
  return cosmosConnector.postToSlot(SLOT_ID, { intent: 'clear' }).catch(logError);
}

function finish() {
  if (view) {
    view.finish();
  }
}

function minimize() {
  if (view) {
    view.minimize();
  }
}

function canShow() {
  return !clientState.audioAdIsPlaying && !clientState.videoAdIsPlaying && !pageIsBlackListed;
}

exports.default = BillboardAd;

},{"../../../../spotify-abba-mini":63,"../../../../spotify-event-dispatcher":146,"../../cosmos-connector":90,"../../event-types":96,"../audio-companion-ad":98,"../format-events":103,"./view":102,"debug":369,"events":371,"spotify-liburi":563}],100:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "\n    <video autoplay muted loop></video>\n  ";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <img src=\"";
  if (helper = helpers.mediaSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.mediaSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n  ";
  return buffer;
  }

  buffer += "<div class=\"countdown\"></div>\n<button class=\"minimizer spoticon-x-24\"></button>\n<div class=\"footer\">\n  <a class=\"maximizer spoticon-chevron-up-16\"></a>\n  <a class=\"companion\" href=\"";
  if (helper = helpers.clickUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <img src=\"";
  if (helper = helpers.companionSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.companionSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n  </a>\n</div>\n<a class=\"billboard\" href=\"";
  if (helper = helpers.clickUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <span class=\"disclaimer\">";
  if (helper = helpers.disclaimer) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.disclaimer); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVideo), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</a>\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],101:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyVideoManager = require('../../../../spotify-video-manager');

var _spotifyVideoManager2 = _interopRequireDefault(_spotifyVideoManager);

var _eventLogger = require('../../event-logger');

var _vastEvents = require('../../vast-events');

var _vastEvents2 = _interopRequireDefault(_vastEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BillboardAdVideo = {};

BillboardAdVideo.create = function (opts) {
  var _logEvent = new _eventLogger.EventLogger(opts.adId).logEvent;
  var videoNode = opts.videoNode;
  var videoSrc = opts.videoSrc;
  var videoId = _spotifyVideoManager2.default.createVideo(videoNode, {
    'url': videoSrc,
    'type': opts.isDash ? 'dash' : null
  });

  var unsubscribeToVast = null;

  var video = {};

  function isActiveVideo() {
    var video = _spotifyVideoManager2.default.getVideo(videoId);
    var isActiveVideo = video === _spotifyVideoManager2.default.getActiveVideo();
    return video && isActiveVideo || false;
  }

  function deactivate() {
    if (isActiveVideo()) {
      unsubscribeToVast();
      _spotifyVideoManager2.default.clearActiveVideo();
    }
  }

  /**
   * @return {BillboardAdVideo} video
   */
  video.activate = function () {
    if (!isActiveVideo()) {
      _spotifyVideoManager2.default.setActiveVideo(videoId);
      unsubscribeToVast = _vastEvents2.default.subscribe(videoNode, _logEvent);
    }

    return video;
  };

  /**
   * @return {Promise} promise
   */
  video.restart = function () {
    return new Promise(function (resolve) {
      if (videoNode.currentTime === 0) {
        resolve();
        return;
      }

      function onSeeked() {
        videoNode.removeEventListener('seeked', onSeeked);
        resolve();
      }

      videoNode.addEventListener('seeked', onSeeked);
      videoNode.currentTime = 0;
    });
  };

  /**
   * @return {BillboardAdVideo} video
   */
  video.destroy = function () {
    deactivate();
    _spotifyVideoManager2.default.destroy(videoId);
    return video;
  };

  /**
   * @param  {Function} cb
   * @return {BillboardAdVideo} video
   */
  video.subscribe = function (cb) {
    _spotifyVideoManager2.default.subscribe(videoId, cb);
    return video;
  };

  return video;
};

exports.default = BillboardAdVideo;

},{"../../../../spotify-video-manager":354,"../../event-logger":95,"../../vast-events":131}],102:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _events = require('events');

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _template = require('./template.hbs');

var _template2 = _interopRequireDefault(_template);

var _countDownAnimation = require('../../count-down-animation');

var _countDownAnimation2 = _interopRequireDefault(_countDownAnimation);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _video = require('./video');

var _video2 = _interopRequireDefault(_video);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug')('saf:billboard-ad-view');

var emitter = new _events.EventEmitter();

var cosmosConnector = new _cosmosConnector2.default();

var AUTO_MINIMIZE_AFTER_MS = 2000; // 2 seconds after focus received
var AUTO_TEAR_DOWN_AFTER_MS = 30000; // 30 seconds after focus received
var FADE_OUT_ANIMATION_LENGTH = 500;
var SKINNY_BILLBOARD_WIDTH = 970;

var TEMPLATE_MANIFEST_URL = 'video-manifest-url';
var STREAMING_TYPE = 'dash+webm';

// EVENTS
var VIEWED = 'viewed';
var CLICKED = 'clicked';
var EXPANDED = 'expanded';
var ENDED = 'ended';

function parseData(data) {
  var metaData = data.ad.metadata || {};
  var ret = {
    id: data.ad.id,
    isDash: false,
    isVideo: false,
    clickUrl: data.ad.click_url,
    mediaSrc: null,
    isValid: true,
    disclaimer: _i18n2.default.get('Sponsored'),
    accountUpgradeTracking: metaData.accountUpgradeTracking,
    accountUpgrade: metaData.accountUpgrade
  };

  switch (data.format) {
    case 'video':
      ret.isVideo = true;
      ret.companionSrc = data.ad.companion_ad.url;
      ret.mediaSrc = manifestUrlForSourceID(data.ad.metadata.videoPlaylistID);
      break;
    case 'banner':
      ret.companionSrc = data.ad.companion_ad.url;
      ret.mediaSrc = data.ad && data.ad.images && data.ad.images[0] && data.ad.images[0].url;
      break;
    case 'unknown':
      // its a dummy ad - used to measure billboard opportunity
      break;
    default:
      ret.isValid = false;
      break;
  }

  return ret;
}

var BillboardAdView = function () {
  function BillboardAdView(container, data) {
    var _this = this;

    _classCallCheck(this, BillboardAdView);

    // Properties
    this.container = container;
    this.activated = false;
    this.state = parseData(data);
    this.isDummyAd = !this.state.mediaSrc;

    // Timers
    this.timerAutoMinimize = null;
    this.timerAutoTearDown = null;

    // To keep track of first and second click on video overlay
    this.clicked = false;

    // Bind event listeners to correct context
    // Bind event listeners to correct context
    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(function (key) {
      var method = _this[key];
      if (typeof method === 'function' && key !== 'constructor') {
        _this[key] = method.bind(_this);
      }
    });
  }

  /**
   * Setup method, renders the dom and adds event listeners.
   */


  _createClass(BillboardAdView, [{
    key: 'setup',
    value: function setup() {
      var _this2 = this;

      this.container.classList.remove('minimized');

      if (!this.state.isValid) {
        this.finish();
        return;
      }

      if (this.isDummyAd) {
        // todo handle dummy ad better
        this.container.classList.add('dummy');
        debug('Dummy billboard ad rendered');
      } else {
        this.container.innerHTML = (0, _template2.default)(this.state);

        var billboard = this.container.querySelector('.billboard');
        var companion = this.container.querySelector('.companion');
        var maximizer = this.container.querySelector('.maximizer');

        this.container.addEventListener('click', this._onContainerClicked);
        billboard.addEventListener('click', this._onBillboardClicked);
        companion.addEventListener('click', this._onCompanionClicked);
        maximizer.addEventListener('click', this._onMaximizerClicked);

        this.countdown = new _countDownAnimation2.default(this.container.querySelector('.countdown'), 2000);

        if (this.state.isVideo) {
          this.container.classList.add('video');
          this._media = billboard.querySelector('video');
          this._video = _video2.default.create({
            adId: this.state.id,
            videoNode: this._media,
            videoSrc: this.state.mediaSrc,
            isDash: true
          });

          this._video.subscribe(function (err) {
            if (err) {
              debug(err);
              _this2.finish();
            }
          });

          this._media.addEventListener('canplay', (0, _once2.default)(this.fadeIn));
          this._media.addEventListener('error', this._onError);
        } else {
          this._media = billboard.querySelector('img');
          this._media.addEventListener('load', (0, _once2.default)(this.fadeIn));
          this._media.addEventListener('error', this._onError);
        }
      }

      window.addEventListener('mousemove', this._onWindowMouseMoved);
      this._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_STARTED);
    }

    /**
     * Start the animations, should be called when the application receives
     * focus again.
     */

  }, {
    key: 'onFocusReceived',
    value: function onFocusReceived() {
      var self = this;

      if (this.activated) return; // Prevent multiple starts

      this.activated = true;

      window.removeEventListener('mousemove', this._onWindowMouseMoved);

      this.timerAutoMinimize = setTimeout(self.minimize, AUTO_MINIMIZE_AFTER_MS);

      if (this.countdown) {
        this.countdown.start();
      }

      this._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_FOCUS_RECEIVED);

      // Dummy ad impressions get tracked on intent 'now'
      if (!this.isDummyAd) {
        this.triggerViewed();
      }

      if (!this.state.isVideo) {
        this._postIntent('now');
      }
    }

    /**
     * Finish this billboard ad.
     * @return {Promise}
     */

  }, {
    key: 'finish',
    value: function finish() {
      var _this3 = this;

      // vast logger handles logging ended/skipped events
      if (!this.state.isVideo) this._logEvent(ENDED);

      return this.destroy().then(function () {
        _this3._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_FINISHED);
        _this3._postIntent('clear');
      });
    }

    /**
     * @return {Promise}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var _this4 = this;

      return new Promise(function (resolve) {
        if (_this4._isDestroyed) {
          resolve();
          return;
        }
        _this4._isDestroyed = true;
        _this4._tearDown().then(resolve);
      });
    }
  }, {
    key: '_postIntent',
    value: function _postIntent(type) {
      switch (type) {
        case 'now':
        case 'clear':
          return cosmosConnector.postToSlot('billboard', { intent: type }).catch(function (e) {
            debug('error posting intent: ' + type, e);
          });
        default:
          throw new Error('intent not supported: ' + type);
      }
    }

    /**
     * Tear down this billboard ad view.
     * @return {Promise}
     */

  }, {
    key: '_tearDown',
    value: function _tearDown() {
      var _this5 = this;

      return new Promise(function (resolve) {
        _this5.container.removeEventListener('click', _this5._onContainerClicked);
        window.removeEventListener('mousemove', _this5._onWindowMouseMoved);

        clearTimeout(_this5.timerAutoMinimize);
        clearTimeout(_this5.timerAutoTearDown);

        if (_this5.state.isVideo) {
          _this5._media.removeEventListener('ended', _this5.finish);
          _this5._media.removeEventListener('error', _this5._onError);
          _this5._video.destroy();
          _this5._dispatchEvent(_eventTypes2.default.AD_CLICK_VIDEO_ENDED);
        }

        _this5.fadeOut().then(function () {
          _this5.container.innerHTML = '';
          _this5.container.classList.remove('dummy');
          _this5.container.classList.remove('minimized');
          _this5.container.classList.remove('has-been-minimized');
          _this5.container.classList.remove('has-been-maximized');
          _this5.container.classList.remove('video');
          _this5._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_DISCARDED);
          emitter.emit('INACTIVE');
          resolve();
        });
      });
    }

    /**
     * Fade the ad in
     * @return {Promise}
     */

  }, {
    key: 'fadeIn',
    value: function fadeIn() {
      var self = this;
      debug('fadeIn');
      // fadeIn occurs once on load, so the naturalWidth of the image media will be available
      // at this point.
      self.isSkinny = !self.state.isVideo && self._media.naturalWidth === SKINNY_BILLBOARD_WIDTH;
      return new Promise(function (resolve) {
        var billboard = self.container.querySelector('.billboard');
        self.container.classList.add('visible');
        // Class added to expand the modal to take 100% of the client
        self.container.classList.add('modal-expanded');
        if (self.isSkinny) {
          self.container.classList.add('skinny-overlay');
        }
        setTimeout(function () {
          // El needs to be visible first in order to animate
          self.container.classList.add('ready'); // Triggers the fade
          setTimeout(function () {
            // Fade in animation takes 0.5 seconds
            self._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_VISIBLE);
            resolve();
          }, FADE_OUT_ANIMATION_LENGTH);
        }, 100);
      });
    }

    /**
     * Fade the ad out
     * @return {Promise}
     */

  }, {
    key: 'fadeOut',
    value: function fadeOut() {
      var self = this;
      debug('fadeOut');
      return new Promise(function (resolve) {
        self.container.classList.remove('ready'); // Triggers the fade

        setTimeout(function () {
          // Fade out animation takes 0.5 seconds
          self.container.classList.remove('visible'); // Hides it
          self.container.classList.remove('modal-expanded');
          self._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_HIDDEN);
          resolve();
        }, FADE_OUT_ANIMATION_LENGTH);
      });
    }

    /**
     * Minimize this billboard ad view.
     */

  }, {
    key: 'minimize',
    value: function minimize() {
      var _this6 = this;

      this._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_MINIMIZED);
      if (this.state.isVideo && this.isUserMaximized()) {
        this.finish();
        return;
      }

      if (this.isSkinny) {
        this._ifImagePresent(function (img) {
          img.classList.add('blurred');
        });
      }

      this.container.classList.add('has-been-minimized');
      this.container.classList.add('minimized');
      this.container.classList.remove('modal-expanded');
      this.timerAutoTearDown = setTimeout(function () {
        _this6.finish();
      }, AUTO_TEAR_DOWN_AFTER_MS);
    }

    /**
     * Maximize this billboard ad.
     */

  }, {
    key: 'maximize',
    value: function maximize() {
      this._ifImagePresent(function (img) {
        img.classList.remove('blurred');
      });
      this.container.classList.add('has-been-maximized');
      this.container.classList.add('modal-expanded');
      this.container.classList.remove('minimized');
      clearTimeout(this.timerAutoTearDown);
      this.timerAutoTearDown = null;
      this._logEvent(EXPANDED);

      if (this.state.isVideo) {
        this._postIntent('now');
      }
    }
  }, {
    key: 'play',
    value: function play() {
      var _this7 = this;

      if (!this.state.isVideo) return;

      this._media.pause();
      this._video.restart().then(function () {
        _this7._video.activate();
        _this7._media.play();
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.AD_CLICK_VIDEO_STARTED
        });
        _this7._media.addEventListener('ended', _this7.finish);
        _this7._media.loop = false;
      });
    }

    /**
     * Is the billboard in a state where it has been maximized by the user?
     * @return {Boolean}
     */

  }, {
    key: 'isUserMaximized',
    value: function isUserMaximized() {
      return this.container.classList.contains('has-been-maximized') && !this.container.classList.contains('minimized');
    }
  }, {
    key: 'triggerViewed',
    value: function triggerViewed() {
      this._logEvent(VIEWED);
      return this;
    }
  }, {
    key: '_onError',
    value: function _onError() {
      debug('Failed to load billboard ' + this.state.mediaSrc);
      this.finish();
    }
  }, {
    key: '_dispatchEvent',
    value: function _dispatchEvent(type) {
      _spotifyEventDispatcher2.default.dispatchEvent({
        type: type,
        params: {
          id: this.state.id,
          isDummyAd: this.isDummyAd,
          isFullscreenAd: this.isSkinny
        },
        extra: {}
      });
    }
  }, {
    key: '_logEvent',
    value: function _logEvent(eventType) {
      var adId = this.state.id;

      cosmosConnector.postEvent(adId, eventType).catch(function (err) {
        debug('error logging event: ' + eventType, err);
      });
    }

    /**
     * Callback for when the mouse has been moved over the window,
     * used as a fallback to trigger the animations if the application focus
     * event hasn't been triggered properly.
     */

  }, {
    key: '_onWindowMouseMoved',
    value: function _onWindowMouseMoved() {
      this.onFocusReceived();
    }

    /**
     * Event listener for when the maximizer icon has been clicked.
     * @param {Event} e The event triggered.
     */

  }, {
    key: '_onMaximizerClicked',
    value: function _onMaximizerClicked(e) {
      e.stopPropagation();
      this.maximize();
    }
  }, {
    key: '_onBillboardOnClickOpenUrl',
    value: function _onBillboardOnClickOpenUrl() {
      if (this.state.accountUpgrade) {
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.NAVIGATION_UPGRADE,
          params: {
            tracking: this.state.accountUpgradeTracking
          }
        });
      } else {
        window.open(this.state.clickUrl);
      }
    }
  }, {
    key: '_onBillboardOnClickKeepMaximized',
    value: function _onBillboardOnClickKeepMaximized() {
      clearTimeout(this.timerAutoMinimize);
      this.container.classList.add('has-been-maximized');
      this.play();
    }

    /**
     * Event listener for when the billboard has been clicked.
     * Clicks on the billboard when minimized should just maximize it.
     * @param {Event} e The event triggered.
     */

  }, {
    key: '_onBillboardClicked',
    value: function _onBillboardClicked(e) {
      e.stopPropagation();
      e.preventDefault();

      // This was added to change the behavior of Video Overlay on initial click so
      // that when the user clicks on the ad before the timer stops the ad will then
      // restart and play. Then on the second click the user will be directed to
      // the advertiser's landing page.
      if (this.state.isVideo && !this.isMinimized() && !this.clicked) {
        this._onBillboardOnClickKeepMaximized();
        this.container.querySelector('.countdown').style.display = 'none';
        this.clicked = true;
      } else {
        this._onBillboardOnClickOpenUrl();
      }

      // Default behavior if not a Video ad
      if (this.container.classList.contains('minimized')) {
        e.preventDefault();
        this.maximize();
      } else {
        this._logEvent(CLICKED);
      }
    }

    /**
     * Is the billboard in a state where it has been minimized by the user?
     * @return {Boolean}
     */

  }, {
    key: 'isMinimized',
    value: function isMinimized() {
      return this.container.classList.contains('has-been-minimized');
    }

    /**
     * Event listener for when the companion banner has been clicked.
     * @param {Event} e The event triggered.
     */

  }, {
    key: '_onCompanionClicked',
    value: function _onCompanionClicked(e) {
      e.stopPropagation();
      this._logEvent(CLICKED);
    }

    /**
     * Event listener for when the container has been clicked.
     */

  }, {
    key: '_onContainerClicked',
    value: function _onContainerClicked() {
      if (this.container.classList.contains('has-been-maximized')) {
        this.finish();
      }
    }

    /**
     * If the billboard has an image element, execute the provided function
     * with the element provided as an argument.
     * @return {Boolean} true if image is present, false otherwise.
     */

  }, {
    key: '_ifImagePresent',
    value: function _ifImagePresent(callback) {
      var img = this.container.querySelector('.billboard').querySelector('img');
      if (img) {
        callback(img);
        return true;
      }
      return false;
    }
  }], [{
    key: 'on',
    value: function on(eventName, callback) {
      emitter.on(eventName, callback);
    }
  }]);

  return BillboardAdView;
}();

function manifestUrlForSourceID(sourceID) {
  return global.__spotify.product_state[TEMPLATE_MANIFEST_URL].replace(/\{type\}/i, STREAMING_TYPE).replace(/\{source_id\}/i, encodeURIComponent(sourceID));
}

exports.default = BillboardAdView;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../spotify-event-dispatcher":146,"../../../i18n":74,"../../cosmos-connector":90,"../../count-down-animation":91,"../../event-types":96,"./template.hbs":100,"./video":101,"debug":369,"events":371,"lodash/once":456}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

},{}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:hpto-response');

function getKeyByValue(v, obj) {
  return Object.keys(obj).find(function (k) {
    return obj[k] === v;
  });
}

/**
 * Rename image banner mode field to 'image'
 * (Historically has been set to 'html')
 *
 * @api private
 * @param  {Object} data - response from dfp
 * @return {Object} normalized data
 */

function _renameImageBannerField(data) {
  var oldBannerKey = getKeyByValue('html', data);
  delete data[oldBannerKey];

  return Object.assign({}, data, {
    bannerMode: 'image'
  });
}

/**
 * Normalize native elem data
 *
 * @api private
 * @param  {Object} data - response from dfp
 * @return {Object} normalized data
 */

function _handleNativeEl(data) {
  var doc = document.implementation.createHTMLDocument('');
  doc.documentElement.innerHTML = data.html;
  var badge = '';
  var nativeElNode = doc.getElementById('native-elements');
  var oldBannerKey = getKeyByValue('html', data);
  var badges = ['data-is-spotlight', 'data-is-exclusive', 'data-is-sponsored'];

  badges.some(function (b) {
    if (nativeElNode.hasAttribute(b)) {
      badge = b;
    }
    return badge;
  });

  badge = badge.split('-').pop() || '';

  delete data[oldBannerKey];

  return Object.assign({}, data, {
    version: 2,
    badge: badge,
    bannerMode: 'native',
    blurb: nativeElNode.getAttribute('data-blurb'),
    targetUri: nativeElNode.getAttribute('data-uri'),
    playButtonUri: nativeElNode.getAttribute('data-track-override')
  });
}

/**
 * Wrapper around normalizing data coming from DFP.
 *
 * @api public
 * @param {Object} data
 */

function parseHptoResponse(data) {
  debug('parseHptoResponse data=%o', data);
  var parsed = null;

  var isNativeEl = data.html && data.html.search(/id=\"native\-elements\"/) !== -1;

  var isImageEl = !data.html && _utils2.default.getProp('banner mode', data) === 'html';

  if (isNativeEl) {
    parsed = _handleNativeEl(data);
  } else if (isImageEl) {
    parsed = _renameImageBannerField(data);
  }

  parsed = parsed || data;
  parsed.bannerMode = _utils2.default.getProp('banner mode', parsed);

  if (!parsed.bannerMode) {
    throw new TypeError('hpto data looks invalid');
  }

  debug('parseHptoResponse result=%o', parsed);
  return parsed;
}

exports.default = parseHptoResponse;

},{"../../utils":130,"debug":369}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _curry = require('lodash/curry');

var _curry2 = _interopRequireDefault(_curry);

var _events = require('events');

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _center = require('../../../../spotify-events/center');

var _center2 = _interopRequireDefault(_center);

var _spotifyLive = require('../../../../spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _targeter = require('../../targeter');

var _targeter2 = _interopRequireDefault(_targeter);

var _adEventLogger = require('../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _dfp = require('../../dfp');

var _dfp2 = _interopRequireDefault(_dfp);

var _hptoResponse = require('./hpto-response');

var _hptoResponse2 = _interopRequireDefault(_hptoResponse);

var _nativeHptoView = require('./views/native-hpto-view');

var _nativeHptoView2 = _interopRequireDefault(_nativeHptoView);

var _htmlHptoView = require('./views/html-hpto-view');

var _htmlHptoView2 = _interopRequireDefault(_htmlHptoView);

var _imageHptoView = require('./views/image-hpto-view');

var _imageHptoView2 = _interopRequireDefault(_imageHptoView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:hpto-ad');

var emitter = new _events.EventEmitter();
var cosmosConnector = new _cosmosConnector2.default();

var VIEW_MAP = {
  'native': _nativeHptoView2.default,
  'html': _htmlHptoView2.default,
  'image': _imageHptoView2.default
};

var fetchAd = (0, _curry2.default)(_fetchAd);
var addCreativeIdTo = (0, _curry2.default)(_addCreativeIdTo);

// EVENTS
var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var isActive = false;
var isEnabled = false;

var containerEl = document.createElement('div');
containerEl.id = 'hpto-container';

/**
 * @module HptoAd
 */
var HptoAd = {};

/**
 * @param  {HTMLElement} mountNode
 * @return {HptoAd}
 */
HptoAd.appendTo = function (mountNode) {
  mountNode.appendChild(containerEl);
  return HptoAd;
};

/**
 * @return {HptoAd}
 */
HptoAd.enable = function () {
  if (containerEl.parentNode === null) {
    throw new Error('Hpto hasn\'t been mounted yet');
  }

  if (!isEnabled) {
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_HPTO, handleForceRefresh);

    // returns true if is preview uri
    if (!subscribeToAppUpdates()) {
      (function () {
        var sessionData = _session2.default.get();

        _settings2.default.getHidePref(sessionData.platform, sessionData.isPremium).then(function (isHidden) {
          emitter.emit(ENABLED);

          if (!isHidden) {
            containerEl.classList.remove('hpto-closed');
            _render(sessionData, containerEl).then(emitter.emit.bind(emitter, ACTIVE));
          } else {
            _center2.default.emit(_eventTypes2.default.AD_HPTO_HIDDEN);
          }
        });
      })();
    }
  }

  return HptoAd;
};

/**
 * @return {HptoAd}
 */
HptoAd.disable = function () {
  if (isEnabled) {
    _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_HPTO, handleForceRefresh);

    // workaround since we persist container now
    containerEl.style.backgroundImage = '';

    containerEl.innerHTML = '';
    emitter.emit(DISABLED);
  }

  return HptoAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {HptoAd}
 */
HptoAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return HptoAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {HptoAd}
 */
HptoAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return HptoAd;
};

/**
 * @return {Boolean} isEnabled
 */
HptoAd.isEnabled = function () {
  return isEnabled;
};

/**
 * @return {Boolean} isEnabled
 */
HptoAd.isActive = function () {
  return isActive;
};

HptoAd.EVENTS = {
  ENABLED: ENABLED,
  DISABLED: DISABLED,
  ACTIVE: ACTIVE,
  INACTIVE: INACTIVE
};

emitter.on(ENABLED, function () {
  isEnabled = true;
});

emitter.on(DISABLED, function () {
  isEnabled = false;
  emitter.emit(INACTIVE);
});

emitter.on(ACTIVE, function () {
  isActive = true;
});

emitter.on(INACTIVE, function () {
  isActive = false;
});

/**
 * @private Exposed for testing
 * @param {Object} dfpData
 * @param {HTMLElement} domEl
 * @return {Promise}
 */
HptoAd._renderAd = function (domEl, isPremium, adData) {
  debug('renderAd isPremium=%o, adData=%o', isPremium, adData);
  var View = VIEW_MAP[adData.bannerMode];
  if (adData.accountUpgrade) {
    domEl.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();
      window.parent.postMessage({
        type: _eventTypes2.default.NAVIGATION_UPGRADE,
        data: { tracking: adData.accountUpgradeTracking }
      }, '*');
    });
  }
  return View.render({
    domEl: domEl,
    adData: adData,
    isPremium: isPremium
  });
};

/**
* @param  {Object} data
* @param  {String} data.platform
* @param  {Boolean} data.isPremium
* @param  {HTMLElement} domEl
* @return {Promise}
*/
function _render(data, domEl) {
  var inventoryUnit = _dfp2.default.inventoryUnit(data.platform, data.isPremium);

  return _targeter2.default.getTargeting(inventoryUnit).then(appendDefaultProps).then(fetchAd(domEl)).then(parseAdResponse).then(addCreativeIdTo(domEl)).then(HptoAd._renderAd.bind(null, domEl, data.isPremium)).catch(logError);
}

function handleForceRefresh() {
  HptoAd.disable();
  HptoAd.enable();
}

function subscribeToAppUpdates() {
  var app = (0, _spotifyLive2.default)('spotify:application');
  var args = app.get('arguments');
  var isPreview = _isPreview(app.get('arguments'));
  app.on('update', onAppUpdate);
  // handle preview initial preview
  if (isPreview) handlePreviewUri(args);
  return isPreview;
}

function onAppUpdate(e) {
  if (e.hasOwnProperty('active')) handleBrowseNavChange(e.active);else if (_isPreview(e.arguments)) handlePreviewUri(e.arguments);
}

function _isPreview(args) {
  return !!(args && _utils2.default.parseGID(args));
}

/**
  * Decides when to render HPTO after clicking on a
  * different app or different tab
  * @private
  * @param {Boolean} active - if browse view is active or not
  */
function handleBrowseNavChange(active) {
  debug('handleBrowseNavChange active=%o', active);
  if (active) HptoAd.enable();else HptoAd.disable();
}

function handlePreviewUri(arg) {
  var gid = _utils2.default.parseGID(arg);

  HptoAd.disable();

  cosmosConnector.getPreviewAd(gid).then(function (res) {
    return res.ad;
  }).then(parseAdResponse).then(addCreativeIdTo(containerEl)).then(HptoAd._renderAd.bind(null, containerEl, false)).then(emitter.emit.bind(emitter, ENABLED)).then(emitter.emit.bind(emitter, ACTIVE)).catch(function (e) {
    debug('preview error: %o', e);
    console.error(e);
  });
}

/**
 * Append ad dimensions / inventory type
 * @param  {Object} data - session data
 * @param  {String} data.platform
 * @param  {Boolean} data.isPremium
 * @return {Object}
 */
function appendDefaultProps(data) {
  return Object.assign({}, data, {
    inventoryType: 'hpto',
    width: 1200,
    height: 270
  });
}

/**
 * Wrapper for fetching ad from ad server
 * @param {Object} targetingData
 * @param {HTMLElement} domEl
 */
function _fetchAd(domEl, targetingData) {
  debug('fetchAd targetingData=%o', targetingData);
  return _dfp2.default.fetchHptoAd(domEl, targetingData);
}

/**
 * @param  {Object} dfpData
 * @return {Promise}
 */
function parseAdResponse(dfpData) {
  var hptoData = dfpData.hpto ? dfpData.hpto : dfpData;
  return (0, _hptoResponse2.default)(hptoData);
}

/**
 * @param  {HTMLElement} element
 * @param  {Object} data
 * @param  {String} data.creativeId
 * @return {void}
 */
function _addCreativeIdTo(element, data) {
  debug('add creativeId from data: %o', data);
  element.setAttribute('data-id', data.creativeId);
  return data;
}

function logError() {
  var message = {};
  message[_adEventLogger2.default.keys.EVENT] = 'event_errored';
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'hpto';
  message[_adEventLogger2.default.keys.JSONDATA] = JSON.stringify({
    'dfp_returned_empty': true
  });
  debug('logError message=%o', message);
  return _adEventLogger2.default.log(message);
}

HptoAd.AD_HPTO_HIDDEN = _eventTypes2.default.AD_HPTO_HIDDEN;
HptoAd.AD_HPTO_RENDERED = _eventTypes2.default.AD_HPTO_RENDERED;

exports.default = HptoAd;

},{"../../../../spotify-event-dispatcher":146,"../../../../spotify-events/center":150,"../../../../spotify-live":312,"../../ad-event-logger":87,"../../cosmos-connector":90,"../../dfp":93,"../../event-types":96,"../../session":127,"../../settings":128,"../../targeter":129,"../../utils":130,"./hpto-response":104,"./views/html-hpto-view":109,"./views/image-hpto-view":110,"./views/native-hpto-view":111,"debug":369,"events":371,"lodash/curry":446}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  nativeEl: require('./native_element_ad_tpl.hbs'),
  sponsored: require('./sponsored_hpto_tpl.hbs')
};

},{"./native_element_ad_tpl.hbs":107,"./sponsored_hpto_tpl.hbs":108}],107:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "verified";
  }

function program3(depth0,data) {
  
  
  return "?action=browse";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n                ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                  <div class=\"mo-image-background-color\">\n	      <div class=\"mo-image-background\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n                  </div>\n                ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n            <img src=\"";
  if (helper = helpers.sponsoredLogo) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.sponsoredLogo); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n            <p>Presents</p>\n          ";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"ne-attrib\">\n    <a href=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"  id=\"ne-attrib-link\">";
  if (helper = helpers.attribution) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attribution); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        </div>\n        ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Saved", options) : helperMissing.call(depth0, "loc", "Saved", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "</div>\n            ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Following", options) : helperMissing.call(depth0, "loc", "Following", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "</div>\n            ";
  return buffer;
  }

  buffer += "<header class=\"header header-album ne-header\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-contextmenu>\n\n  <div class=\"ne-left-fade\"></div>\n\n  <section class=\"h-main-content container clearfix ne-container\">\n    <div class=\"ne-container-center\">\n      <div class=\"h-media\">\n        <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVerified), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-context=\"\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-context=\"media-object\">\n          <div class=\"mo-image-wrapper\">\n            <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" id=\"ne-image-link\">\n              <svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n                <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"album-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"user-placeholder\" x=\"5\" y=\"9.8\"></text>\n              </svg>\n              ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "album", "playlist", "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "album", "playlist", "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	<div class=\"mo-image\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\">\n                <span class=\"mo-verified\">\n                  <span class=\"spoticon-check-16\"></span>\n                </span>\n              </div>\n            </a>\n          </div>\n        </div>\n      </div>\n      <div class=\"h-data\">\n        <div class=\"h-label ";
  if (helper = helpers.badgeType) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeType); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n          ";
  if (helper = helpers.typeLabel) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.typeLabel); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sponsoredLogo), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n  <h1 class=\"h-title ne-title\" data-contextmenu>\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-name-link\">\n            <span class=\"ne-underline\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n          </a>\n        </h1>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.attribution), {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"h-description\">\n          ";
  if (helper = helpers.blurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.blurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </div>\n\n        <div class=\"h-controllers\" data-context data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <button class=\"button button-green button-play\" data-context data-button=\"play\" id=\"ne-play-button\" data-uri=\"";
  if (helper = helpers.playBtnUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.playBtnUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n            <div class=\"b-play-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Play", options) : helperMissing.call(depth0, "loc", "Play", options)))
    + "</div>\n            <div class=\"b-pause-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Pause", options) : helperMissing.call(depth0, "loc", "Pause", options)))
    + "</div>\n          </button>\n          <button class=\"button button-with-stroke button-add\" data-button=\"add\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-save-button\">\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </button>\n          <button class=\"button button-icon-with-stroke spoticon-more-16\" data-button=\"contextmenu\" data-tooltip=\"More\" id=\"ne-more-button\"></button>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <div class=\"ne-right-fade\"></div>\n  <div class=\"ne-bottom-fade\"></div>\n  <div class=\"ne-bg-image bg-centered blurred ne-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" style=\"background-image: url('";
  if (helper = helpers.backgroundImage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.backgroundImage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "');\"></div>\n</header>\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],108:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "verified";
  }

function program3(depth0,data) {
  
  
  return "?action=browse";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n                ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                  <div class=\"mo-image-background-color\">\n                    <div class=\"mo-image-background\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n                  </div>\n                ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"ne-attrib\">\n          <a href=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"  id=\"ne-attrib-link\">";
  if (helper = helpers.attribution) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attribution); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        </div>\n        ";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Saved", options) : helperMissing.call(depth0, "loc", "Saved", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "</div>\n            ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Following", options) : helperMissing.call(depth0, "loc", "Following", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "</div>\n            ";
  return buffer;
  }

  buffer += "<header class=\"header-album\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-contextmenu>\n  <div class=\"ne-left-fade\" style=\"width:590px\"></div>\n\n  <section class=\"h-main-content container clearfix ne-container sponsored\" style=\"padding:16px\">\n    <div class=\"ne-container-center\" style=\"overflow:auto; margin:0\">\n      <div class=\"sponsorship\" style=\"overflow:auto;margin-bottom:48px\">\n        <div class=\"h-label\">\n          <p style=\"margin:0\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "PresentedBy", options) : helperMissing.call(depth0, "loc", "PresentedBy", options)))
    + "</p>\n          <img src=\"";
  if (helper = helpers.sponsoredLogo) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.sponsoredLogo); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"margin:4px 0;height:40px\"/>\n          <p style=\"text-transform:none;margin-top:2px\">";
  if (helper = helpers.logoBlurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.logoBlurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n        </div>\n      </div>\n      <div class=\"h-media\" style=\"width:172px\">\n        <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVerified), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-context=\"\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-context=\"media-object\">\n          <div class=\"mo-image-wrapper\">\n            <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" id=\"ne-image-link\">\n              <svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n                <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"album-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"user-placeholder\" x=\"5\" y=\"9.8\"></text>\n              </svg>\n              ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "album", "playlist", "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "album", "playlist", "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              <div class=\"mo-image\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\">\n                <span class=\"mo-verified\">\n                  <span class=\"spoticon-check-16\"></span>\n                </span>\n              </div>\n            </a>\n          </div>\n        </div>\n      </div>\n      <div class=\"h-data\">\n        <div class=\"h-label\">\n          ";
  if (helper = helpers.typeLabel) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.typeLabel); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n        <h1 class=\"h-title ne-title\" data-contextmenu>\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-name-link\">\n            <span class=\"ne-underline\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n          </a>\n        </h1>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.attribution), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"h-description\">\n          ";
  if (helper = helpers.blurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.blurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </div>\n\n        <div class=\"h-controllers\" data-context data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"bottom:16px\">\n          <button class=\"button button-green button-play\" data-context data-button=\"play\" id=\"ne-play-button\" data-uri=\"";
  if (helper = helpers.playBtnUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.playBtnUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n            <div class=\"b-play-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Play", options) : helperMissing.call(depth0, "loc", "Play", options)))
    + "</div>\n            <div class=\"b-pause-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Pause", options) : helperMissing.call(depth0, "loc", "Pause", options)))
    + "</div>\n          </button>\n          <button class=\"button button-with-stroke button-add\" data-button=\"add\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-save-button\">\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </button>\n          <button class=\"button button-icon-with-stroke spoticon-more-16\" data-button=\"contextmenu\" data-tooltip=\"More\" id=\"ne-more-button\"></button>\n        </div>\n      </div>\n    </div>\n    <img class=\"sponsored-credits\" src=\"";
  if (helper = helpers.credits) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.credits); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n  </section>\n\n  <div class=\"ne-bottom-fade\"></div>\n  <div class=\"ne-bg-image ne-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" style=\"background-image: url('";
  if (helper = helpers.backgroundImage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.backgroundImage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "');\"></div>\n</header>\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],109:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _curry = require('lodash/curry');

var _curry2 = _interopRequireDefault(_curry);

var _center = require('../../../../../spotify-events/center');

var _center2 = _interopRequireDefault(_center);

var _eventTypes = require('../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _utils = require('../../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _externalTags = require('../../../external-tags');

var _adEventLogger = require('../../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _viewUtils = require('./view-utils');

var _viewUtils2 = _interopRequireDefault(_viewUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Curried functions
var appendBackgroundImage = (0, _curry2.default)(_appendBackgroundImage);
var fireThirdPartyImp = (0, _curry2.default)(_viewUtils2.default.fireThirdPartyImp);
var appendHideBtn = (0, _curry2.default)(_viewUtils2.default.appendHideBtn);

var HtmlHptoView = {};

/**
 * @param  {Object} opts
 * @param  {Object} opts.adData
 * @param  {String} opts.adData.backgroundImage
 * @param  {String} opts.adData.html
 * @param  {HTMLElement} opts.domEl
 * @param  {Boolean} opts.isPremium
 * @return {Promise}
 */
HtmlHptoView.render = function (opts) {
  var adData = opts.adData;
  var domEl = opts.domEl;
  var isPremium = opts.isPremium;

  // Throw if missing both bg image and html data
  if (!!adData.html === false && !_utils2.default.getProp('background image', adData)) {
    throw new Error('[Html HPTO] Missing image / html tag');
  }

  return Promise.resolve(appendAd(domEl, adData)).then(appendBackgroundImage(domEl)).then(fireThirdPartyImp(domEl)).then(logViewed).then(appendHideBtn(domEl, isPremium)).catch(function (e) {
    console.error(e.message);
  });
};

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.html
 * @return {Object}
 */
function appendAd(domEl, data) {
  var iframe = _utils2.default.createInteractiveIframe(data.html);
  var bgUrl = _utils2.default.getProp('background url', data);

  domEl.classList.add('min-width');

  // Fire comscore pixel
  _utils2.default.appendTrackingPixel(_externalTags.comscore, domEl);

  if (bgUrl) {
    var anchorTag = document.createElement('a');
    anchorTag.classList.add('hpto-interactive');
    anchorTag.href = bgUrl;

    anchorTag.addEventListener('click', function () {
      _utils2.default.appendTrackingPixel(data.click, domEl);
    });

    anchorTag.appendChild(iframe);
    domEl.appendChild(anchorTag);
  } else {
    domEl.appendChild(iframe);
  }

  _center2.default.emit(_eventTypes2.default.AD_HPTO_RENDERED);

  return data;
}

/**
 * Add background
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.backgroundImage
 * @return {Object}
 */
function _appendBackgroundImage(domEl, data) {
  var bgImg = _utils2.default.getProp('background image', data);
  var bgColor = _utils2.default.getProp('background color', data);

  if (bgImg) {
    domEl.style.backgroundImage = 'url(' + _viewUtils2.default.getImageLink(bgImg) + ')';
  }

  if (bgColor) {
    domEl.style.backgroundColor = (bgColor[0] === '#' ? '' : '#') + bgColor;
  }

  return data;
}

/**
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {Object}
 */
function logViewed(data) {
  var message = {};
  message[_adEventLogger2.default.keys.EVENT] = 'event_viewed';
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = data.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = data.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = data.creativeId;
  _adEventLogger2.default.log(message);
  return data;
}

exports.default = HtmlHptoView;

},{"../../../../../spotify-events/center":150,"../../../ad-event-logger":87,"../../../event-types":96,"../../../external-tags":97,"../../../utils":130,"./view-utils":112,"lodash/curry":446}],110:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _curry = require('lodash/curry');

var _curry2 = _interopRequireDefault(_curry);

var _spotifyLive = require('../../../../../spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _center = require('../../../../../spotify-events/center');

var _center2 = _interopRequireDefault(_center);

var _adEventLogger = require('../../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _eventTypes = require('../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _utils = require('../../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _viewUtils = require('./view-utils');

var _viewUtils2 = _interopRequireDefault(_viewUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Curried functions
var appendAd = (0, _curry2.default)(_appendAd);
var fireThirdPartyImp = (0, _curry2.default)(_viewUtils2.default.fireThirdPartyImp);
var appendHideBtn = (0, _curry2.default)(_viewUtils2.default.appendHideBtn);

var ImageHptoView = {};

/**
 * @param  {Object} opts
 * @param  {Object} opts.adData
 * @param  {String} opts.adData.backgroundImage
 * @param  {String} opts.adData.html
 * @param  {HTMLElement} opts.domEl
 * @param  {Boolean} opts.isPremium
 * @return {Promise}
 */
ImageHptoView.render = function (opts) {
  var adData = opts.adData;
  var domEl = opts.domEl;
  var isPremium = opts.isPremium;

  if (!_utils2.default.getProp('background image', adData)) {
    throw new Error('[Image HPTO] Missing background image');
  }

  return getAttributes(adData).then(appendAd(domEl)).then(fireThirdPartyImp(domEl)).then(logViewed).then(appendHideBtn(domEl, isPremium));
};

/**
 * @param  {Object} data
 * @return {Promise}
 */
function getAttributes(data) {
  return new Promise(function (resolve) {
    var props = {};
    props.bgImg = _utils2.default.getProp('background image', data);
    props.bgColor = _utils2.default.getProp('background color', data);
    props.url = _utils2.default.getProp('background url', data);
    props.clickThrough = props.url && props.url.replace(/&amp;/g, '&');

    resolve(Object.assign({}, props, data));
  });
}

/**
 * @param {String} data.creativeId
 * @param {String} data.bgImg
 * @param {String} data.clickThrough
 */
function _appendAd(domEl, data) {
  domEl.style.backgroundImage = 'url(' + _viewUtils2.default.getImageLink(data.bgImg) + ')';

  if (data.bgColor) {
    // Shouldn't know about parent - should find better approach
    domEl.parentNode.style.backgroundColor = (data.bgColor[0] === '#' ? '' : '#') + data.bgColor;
  }

  var image = document.createElement('a');
  image.classList.add('hpto-interactive');
  image.setAttribute('data-id', 'dfp-' + Date.now());

  domEl.appendChild(image);

  _center2.default.emit(_eventTypes2.default.AD_HPTO_RENDERED);

  setClickTracking(image, data);

  return data;
}

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @return {void}
 */
function setClickTracking(domEl, data) {
  domEl.addEventListener('click', _onAdClick.bind(null, domEl, data));
}

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.clickThrough
 * @param  {String} data.click
 * @param  {Event} e The click event which triggered this function.
 */
function _onAdClick(domEl, data, e) {
  e.preventDefault();
  _utils2.default.appendTrackingPixel(data.click, domEl);
  logClicked(data);
  window.open(data.clickThrough);
}

/**
 * @param  {String} clickEvent
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logClicked(data) {
  var message = {};
  message[_adEventLogger2.default.keys.EVENT] = 'event_clicked';
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = data.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = data.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = data.creativeId;
  _adEventLogger2.default.log(message);
}

/**
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logViewed(data) {
  var message = {};
  message[_adEventLogger2.default.keys.EVENT] = 'event_viewed';
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = data.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = data.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = data.creativeId;

  _adEventLogger2.default.log(message);

  return data;
}

exports.default = ImageHptoView;

},{"../../../../../spotify-events/center":150,"../../../../../spotify-live":312,"../../../ad-event-logger":87,"../../../event-types":96,"../../../utils":130,"./view-utils":112,"lodash/curry":446,"spotify-liburi":563}],111:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _curry = require('lodash/curry');

var _curry2 = _interopRequireDefault(_curry);

var _spotifyLive = require('../../../../../spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _center = require('../../../../../spotify-events/center');

var _center2 = _interopRequireDefault(_center);

var _eventTypes = require('../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _adEventLogger = require('../../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _utils = require('../../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _viewUtils = require('./view-utils');

var _viewUtils2 = _interopRequireDefault(_viewUtils);

var _nativeTpl = require('../native-tpl');

var _nativeTpl2 = _interopRequireDefault(_nativeTpl);

var _configuration = require('../../../configuration');

var _configuration2 = _interopRequireDefault(_configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:native-hpto-view');

// Curried functions
var appendAd = (0, _curry2.default)(_appendAd);
var fireThirdPartyImp = (0, _curry2.default)(_viewUtils2.default.fireThirdPartyImp);
var onBtnClick = (0, _curry2.default)(_onBtnClick);
var appendHideBtn = (0, _curry2.default)(_viewUtils2.default.appendHideBtn);
var mergeProps = (0, _curry2.default)(_mergeProps);

var NativeHptoView = {};

/**
 * @param  {Object} opts
 * @param  {HTMLElement} opts.domEl
 * @param  {Object} opts.adData
 * @param  {String} opts.adData.targetUri
 * @param  {String} opts.adData.backgroundImage - sponsored playlist hpto only
 * @param  {String} opts.adData.badge
 * @param  {String} opts.adData.nativeHptoType
 * @param  {Boolean} opts.isPremium
 * @return {Promise}
 */
NativeHptoView.render = function (opts) {
  var adData = opts.adData;
  var domEl = opts.domEl;
  var isPremium = opts.isPremium;

  if (!_utils2.default.getProp('target uri', adData)) {
    throw new Error('[Native HPTO] Missing a target uri');
  }

  return getAttributes(adData).then(appendAd(domEl)).then(fireThirdPartyImp(domEl)).then(logViewed).then(appendHideBtn(domEl, isPremium)).catch(function (e) {
    // General render error
    debug(e);
    throw e;
  });
};

/**
 * @param  {Object} data
 * @return {Promise}
 */
function getAttributes(data) {
  var dfpProps = parseDfpProps(data);

  return NativeHptoView.getLiveProps(dfpProps.uri, dfpProps.type).then(mergeProps(dfpProps));
}

/**
 * @param  {Object} data
 * @param  {String} data.targetUri
 * @param  {String} data.backgroundImage
 * @param  {String} data.badge
 * @param  {String} data.blurb
 * @param  {String} data.nativeHptoType
 * @return {Object}
 */
function parseDfpProps(data) {
  var TYPE_LABELS = {
    'track': 'single',
    'album': 'album',
    'artist': 'artist',
    'playlist': 'playlist'
  };
  var props = {};

  props.uri = _utils2.default.getProp('target uri', data);
  props.playBtnUri = _utils2.default.getProp('play btn uri', data) || props.uri;
  props.type = _utils2.default.getType(props.uri);
  props.blurb = data.blurb;
  props.bgImage = _utils2.default.getProp('background image', data) || '';
  props.badgeType = data.badge.toLowerCase();
  props.typeLabel = typeLabel(props.badgeType) || TYPE_LABELS[props.type];

  return Object.assign({}, data, props);
}

function typeLabel(badge) {
  var label = void 0;

  switch (badge) {
    case 'exclusive':
      label = 'spotify exclusive';
      break;
    case 'spotlight':
      label = _configuration2.default.getSpotlightSvg();
      break;
  }

  return label;
}

/**
 * @param  {String} uri
 * @param  {String} uriType
 * @return {Promise}
 */
NativeHptoView.getLiveProps = function (uri, uriType) {
  var LIVE_QUERY_PARAMS = {
    'playlist': 'name, image, annotatedImage',
    'album': 'name, image, artists(name, uri)',
    'track': 'name, image, artists(uri)',
    'artist': 'name, image'
  };

  return new Promise(function (res, rej) {
    (0, _spotifyLive2.default)(uri).query(LIVE_QUERY_PARAMS[uriType], function (err, data) {
      if (err) rej(err);

      for (var key in data) {
        if (!data[key]) {
          debug('Returned empty field for:', key);
        }
      }

      res(data);
    });
  });
};

function _mergeProps(dfpProps, liveProps) {
  var PLAYLIST_BG = 'http://i.scdn.co/image/03fa7db6aae8ffb4a936d0fe5a4f419199c313a9';
  var props = {};

  props.isVerified = !!(dfpProps.type === 'artist' && liveProps.name);
  props.name = liveProps.name;

  var preferredImage = liveProps.annotatedImage || liveProps.image;
  props.smallImageUri = preferredImage;
  props.backgroundImage = preferredImage;

  switch (dfpProps.type) {
    case 'track':
      props.attribution = liveProps.name;
      props.attributionUri = liveProps.artists[0].uri;
      break;
    case 'album':
      props.attribution = liveProps.artists[0].name;
      props.attributionUri = liveProps.artists[0].uri;
      break;
    case 'playlist':
      props.backgroundImage = dfpProps.bgImage || preferredImage || PLAYLIST_BG;
      break;
    default:
      console.error('Bad type: ' + dfpProps.type);
  }

  return Object.assign({}, dfpProps, props);
}

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.nativeHptoType
 * @return {Object} data
 */
function _appendAd(domEl, data) {
  var tpl = void 0;

  switch (data.nativeHptoType) {
    case 'original':
      tpl = _nativeTpl2.default.nativeEl;
      break;
    case 'sponsored':
      tpl = _nativeTpl2.default.sponsored;
      break;
    default:
      throw new Error('Invalid hpto type: ' + data.nativeHptoType);
  }

  domEl.innerHTML = tpl(data);

  _center2.default.emit(_eventTypes2.default.AD_HPTO_RENDERED);

  setClickTracking(domEl, data);

  return data;
}

/**
 * @param {[type]} domEl [description]
 * @param {Object} data
 * @param {String} data.click
 */
function setClickTracking(domEl, data) {
  var playBtn = domEl.querySelector('#ne-play-button');
  var saveBtn = domEl.querySelector('#ne-save-button');
  var moreBtn = domEl.querySelector('#ne-more-button');
  var imageLink = domEl.querySelector('#ne-image-link');
  var nameLink = domEl.querySelector('#ne-name-link');
  var attribLink = domEl.querySelector('#ne-attrib-link');

  imageLink.addEventListener('click', onBtnClick('ne_image_link_clicked', data));

  nameLink.addEventListener('click', onBtnClick('ne_name_link_clicked', data));

  playBtn.addEventListener('click', function (e) {
    var btn = e.target.getAttribute('data-log-click').split('-')[0];
    onBtnClick('ne_' + btn + '_btn_clicked', data, e);
  });

  saveBtn.addEventListener('click', onBtnClick('ne_save_btn_clicked', data));

  moreBtn.addEventListener('click', onBtnClick('ne_more_btn_clicked', data));

  if (attribLink) {
    attribLink.addEventListener('click', onBtnClick('ne_attrib_link_clicked', data));
  }
}

/**
 * @param  {String} clickEvent
 * @param  {Object} data
 * @param  {String} data.click
 * @param  {MouseEvent} e
 * @return {void}
 */
function _onBtnClick(clickEvent, data, e) {
  _utils2.default.appendTrackingPixel(data.click, e.target);
  logClicked(clickEvent, data);
}

/**
 * @param  {String} clickEvent
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logClicked(clickEvent, data) {
  var message = {};
  message[_adEventLogger2.default.keys.EVENT] = 'event_clicked';
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = data.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = data.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = data.creativeId;
  message[_adEventLogger2.default.keys.JSONDATA] = JSON.stringify({ 'element_clicked': clickEvent });
  _adEventLogger2.default.log(message);

  debug('adEvent', clickEvent, data);
}

/**
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logViewed(data) {
  var message = {};
  message[_adEventLogger2.default.keys.EVENT] = 'event_viewed';
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = data.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = data.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = data.creativeId;

  _adEventLogger2.default.log(message);

  debug('adEvent log viewed');

  return data;
}

exports.default = NativeHptoView;

},{"../../../../../spotify-events/center":150,"../../../../../spotify-live":312,"../../../ad-event-logger":87,"../../../configuration":89,"../../../event-types":96,"../../../utils":130,"../native-tpl":106,"./view-utils":112,"debug":369,"lodash/curry":446}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _center = require('../../../../../spotify-events/center');

var _center2 = _interopRequireDefault(_center);

var _spotifyPreferences = require('../../../../../spotify-preferences');

var _spotifyPreferences2 = _interopRequireDefault(_spotifyPreferences);

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _adEventLogger = require('../../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _utils = require('../../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _eventTypes = require('../../../event-types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uiPref = new _spotifyPreferences2.default('ui');

var CDN_URL = 'http://d3rt1990lpmkn.cloudfront.net/unbranded/';

var viewUtils = {};

/**
 * @param {HTMLElement} domEl
 * @param {Object} data
 * @param {Object} data.trackingUrl
 * @return {Object} data
 */
viewUtils.fireThirdPartyImp = function (domEl, data) {
  var url = _utils2.default.getProp('tracking url', data);

  if (url) {
    _utils2.default.appendTrackingPixel(url, domEl);
  }

  return data;
};

/**
 * Returns a platform specific image URL
 * This returns a CDN URL when on web rather than the play.spotify.com URL
 * returned by .toSpotifyLink()
 *
 * @param  {String} param
 * @return {String}
 */
viewUtils.getImageLink = function (link) {
  if (/^[a-zA-Z0-9]{40}$/.test(link)) {
    link = 'spotify:image:' + link;
  } else if (!/^http(s)?:\/\/.*$/.test(link)) {
    link = CDN_URL + link;
  }

  return link;
};

/**
 * @param  {HTMLElement} domEl
 * @param  {Boolean} isPremium
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {Object}
 */
viewUtils.appendHideBtn = function (domEl, isPremium, data) {
  // Don't show button for sponsored hptos
  if (!(_utils2.default.getProp('native hpto type', data) === 'sponsored')) {
    var hideBtn = createHideBtn(isPremium, data);

    if (isPremium) {
      hideBtn.addEventListener('click', onHideClick.bind(null, domEl, data));
    }

    domEl.appendChild(hideBtn);
  }

  return data;
};

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function onHideClick(domEl, data) {
  domEl.classList.add('hpto-closed');

  uiPref.set('hide_hpto', true);
  window.parent.sessionStorage['ui.hide_hpto'] = true;
  logCollapsed(data);

  _center2.default.emit(_eventTypes.AD_HPTO_HIDDEN);
}

/**
 * @param  {Boolean} isPremium
 * @return {void}
 */
function createHideBtn(isPremium) {
  var hideBtn = document.createElement('span');
  hideBtn.classList.add('hpto-button');

  if (isPremium) {
    hideBtn.innerHTML = _i18n2.default.get('HideAnnouncements');
  } else {
    hideBtn.innerHTML = _i18n2.default.get('Sponsored');
    hideBtn.classList.add('no-hover');
  }

  return hideBtn;
}

/**
 * @param {Object} data
 * @param {String} data.bannerMode
 * @param {String} data.lineItemId
 * @param {String} data.creativeId
 */
function logCollapsed(data) {
  var message = {};
  message[_adEventLogger2.default.keys.EVENT] = 'event_collapsed';
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = data.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = data.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = data.creativeId;

  _adEventLogger2.default.log(message);
}

exports.default = viewUtils;

},{"../../../../../spotify-events/center":150,"../../../../../spotify-preferences":351,"../../../../i18n":74,"../../../ad-event-logger":87,"../../../event-types":96,"../../../utils":130}],113:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  REFRESH_INTERVAL_KEY: 'leaderboard_refresh_interval',
  DEFAULT_REFRESH_INTERVAL_MS: 30000,
  DEFAULT_CLOSE_LIFETIME_MS: 60 * 60 * 1000,
  DEFAULT_SANDBOX_PARAMS: ['allow-forms', 'allow-pointer-lock', 'allow-popups', 'allow-same-origin', 'allow-scripts'],
  LEADERBOARD_SLOT_ID: 'leaderboard'
};

},{}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CONSTANTS = require('./CONSTANTS');

var _CONSTANTS2 = _interopRequireDefault(_CONSTANTS);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var debug = require('debug')('saf:leaderboard');

var slice = [].slice;

/**
 * Set the innerHTML property of the given node, and then locate and
 * execute all scripts in order, with the following caveats:
 *
 * 1. The scripts MUST be asynchronous
 * 2. The html MUST come from a first-party source, given the security concerns.
 *
 * @param {DOM} document DOM used to generate elements.
 * @param {Element} node Element which will have its innerHTML property set.
 * @param {String} html HTML content which may contain script tags.
 */
function setAndEvalTrustedHtml(doc, node, html) {
  node.innerHTML = html;
  var scripts = slice.apply(node.getElementsByTagName('script'));

  var srcs = scripts.filter(function (script) {
    return script.src;
  }).map(function (script) {
    return script.src;
  });

  srcs.forEach(function (src) {
    var newScript = doc.createElement('script');
    newScript.src = src;
    newScript.async = 1;
    node.appendChild(newScript);
  });

  var bodies = scripts.filter(function (script) {
    return !script.src;
  }).map(function (script) {
    return script.text;
  }).filter(function (text) {
    return text;
  });

  bodies.forEach(function (body) {
    var newScript = doc.createElement('script');
    newScript.text = body;
    node.appendChild(newScript);
  });
}

/**
 * Create an iframe with the given content and sandbox attributes
 *
 * @param {DOM} document
 * @param {String} html HTML to set as the content of the iframe.
 * @param {Array<String>} [sandboxParams] List of sandboxed parameters.
 *   A sensible secure default will be provided which will allow
 *   scripts and same origin, but not top navigation.
 *
 */
function iframeWithContent(document, html) {
  var sandboxParams = arguments.length <= 2 || arguments[2] === undefined ? _CONSTANTS2.default.DEFAULT_SANDBOX_PARAMS : arguments[2];

  var iframe = document.createElement('iframe');
  iframe.sandbox = sandboxParams.join(' ');
  iframe.srcdoc = html;
  iframe.scrolling = 'no';
  return iframe;
}

/**
 * Render a leaderboard iframe in the provided container element.  The contents
 * of the container will be cleared, and standard styles/ids will be added to
 * the given iframe.
 * @param {DOM} document DOM object.
 * @param {Element} containerElement Element which will contain the leaderboard.
 * @param {Element} leaderboardElement Element with the rendered leaderboard
 *   contents.
 */
function renderLeaderboard(document, containerElement, leaderboardElement, width, height) {
  debug('renderLeaderboard', containerElement, leaderboardElement);
  containerElement.innerHTML = '';
  leaderboardElement.style.display = 'block';
  leaderboardElement.id = 'leaderboard-ad-element';
  if (width && height) {
    leaderboardElement.style.width = width + 'px';
    leaderboardElement.style.height = height + 'px';
    leaderboardElement.style.overflow = 'hidden';
  }
  var wrapper = document.createElement('div');
  wrapper.id = 'leaderboard-ad-wrapper';
  wrapper.appendChild(leaderboardElement);
  containerElement.appendChild(wrapper);
}

/**
 * Render a close button into the leaderboard container element.
 *
 * @param {DOM} doc The document object
 * @param {Element} containerElement The containing element for the leaderboard
 * @param {Function} onClose Event handler for when the close button is clicked
 * @param {Integer} [activeAfterMs] If provided, sets the "active" class on the
 *   close button after the given number of milliseconds.
 */
function renderCloseButton(doc, containerElement, onClose, activeAfterMs) {
  var closeContainer = doc.createElement('div');
  closeContainer.className = 'close-button-container';
  var button = doc.createElement('a');
  button.setAttribute('data-ta-id', 'leaderboard-close-button');
  button.href = '#';
  if (activeAfterMs) {
    button.className = 'close';
    setTimeout(function () {
      button.className = 'close active';
    }, activeAfterMs);
  } else {
    button.className = 'close active';
  }
  button.setAttribute('aria-hidden', 'true');
  button.innerHTML = '&times;';
  button.addEventListener('click', onClose);
  closeContainer.appendChild(button);
  if (containerElement.firstChild) {
    containerElement.insertBefore(closeContainer, containerElement.firstChild);
  } else {
    containerElement.appendChild(closeContainer);
  }
}

/**
 * Subscribe to leaderboard preview requests delivered via cosmos, and render
 * into the provided DOM element.
 *
 * @param {CosmosConnector} cosmosConnector An instance of cosmos connector
 * @param {DOM} document Root document for generating elements
 * @param {Element} domElement Leaderboard DOM element for setting TA attributes
 * @param {Function} onPreview Executed after a preview has been injected.
 */
function subscribeToPreview(cosmosConnector, document, domElement, onPreview) {
  cosmosConnector.subscribeToFormat('banner', function (data) {
    if (data.ad.display && data.ad.display[0].width !== 728) {
      return;
    }
    var html = data.ad.display[0].media;
    var uri = data.ad.uri;
    var iframe = iframeWithContent(document, html);
    domElement.setAttribute('data-ta-preview-uri', uri);
    renderLeaderboard(document, domElement, iframe);
    onPreview();
  });
}

function logEvent(adEventLogger, eventType, jsonData, messageExtra) {
  var message = {};
  message[adEventLogger.keys.AD_FORMAT] = 'banner';
  message[adEventLogger.keys.SLOT] = _CONSTANTS2.default.LEADERBOARD_SLOT_ID;
  message[adEventLogger.keys.EVENT] = eventType;
  if (jsonData) {
    message[adEventLogger.keys.JSONDATA] = JSON.stringify(jsonData);
  }
  if (messageExtra) {
    Object.assign(message, messageExtra);
  }
  return adEventLogger.log(message);
}

/**
 * Generates a handler for leaderboard messages generated by the code
 * injected into the leaderboard iframe.  These messages are expected to
 * have the following shape:
 * {
 *   data: {
 *     type: oneOf(
 *       'ads-leaderboard-failed',
 *       'ads-leaderboard-rendered',
 *       'ads-upgrade-account'
 *     ),
 *     data: {
 *       lineItemId: string,
 *       creativeId: string,
 *     },
 *     click: string,
 *   })
 * }
 *
 * @param {AdEventLogger} adEventLogger Used to log events in the backend.
 * @param {EventDispatcher} eventDispatcher Event dispatcher for UI rendering
 *   purposes.
 * @param {Element} domElement Container element of leaderboard, used to
 *   set attributes for TA systems tests.
 */
function leaderboardMessageHandler(adEventLogger, eventDispatcher, domElement, leaderboardVersion) {
  var currentUuid = null;
  var onCleanup = null;
  var renderedAdProps = null;

  var handler = function onLeaderboardMessage(e) {
    var _renderedAdProps;

    if (!e.data || !e.data.type) {
      return; // Not interested in the message
    }
    switch (e.data.type) {
      case 'ads-leaderboard-failed':
        debug('ads-leaderboard-failed: %o', e.data);
        renderedAdProps = null;

        eventDispatcher.dispatchEvent({
          type: _eventTypes2.default.AD_LEADERBOARD_PLACEMENT,
          params: {
            isEmpty: true
          }
        });

        logEvent(adEventLogger, 'event_errored', {
          dfp_returned_empty: true
        });
        break;

      case 'ads-leaderboard-rendered':
        debug('ads-leaderboard-rendered: %o', e.data);
        renderedAdProps = (_renderedAdProps = {}, _defineProperty(_renderedAdProps, adEventLogger.keys.LINE_ITEM_ID, e.data.data.lineItemId), _defineProperty(_renderedAdProps, adEventLogger.keys.CREATIVE_ID, e.data.data.creativeId), _defineProperty(_renderedAdProps, adEventLogger.keys.AD_ID, e.data.data.creativeId), _renderedAdProps);
        var jsonData = { leaderboardVersion: leaderboardVersion };
        logEvent(adEventLogger, 'event_viewed', jsonData, renderedAdProps).then(function (data) {
          debug('Banner impression logged!', data);
        });

        domElement.setAttribute('data-ta-rendered-at', new Date().getTime());
        domElement.setAttribute('data-ta-creative-id', e.data.data.creativeId);
        domElement.setAttribute('data-ta-line-item-id', e.data.data.lineItemId);

        eventDispatcher.dispatchEvent({
          type: _eventTypes2.default.AD_LEADERBOARD_PLACEMENT,
          params: {
            isEmpty: false
          }
        });
        break;

      case 'ads-upgrade-account':
        debug('ads-upgrade-account: %o', e.data);
        var match = e.data.click.match(/\?(.*)$/);
        var params = match && match[1] ? match[1] : '';
        eventDispatcher.dispatchEvent({
          type: _eventTypes2.default.NAVIGATION_UPGRADE,
          params: {
            tracking: params
          }
        });
        break;

      case 'spotify:ad:leaderboard:cleanup:done':
        onCleanup && onCleanup(e.data);
        break;

      case 'spotify:ad:leaderboard:init':
        // Note: we assume that there will only be one leaderboard initialized at
        // any given moment.  If this changes, we will want to keep track of all
        // initialized uuids and use the appropriate uuid on the cleanup routine.
        currentUuid = e.data.uuid;
        renderedAdProps = null;
        break;

      default:
        break;
    }
    if (e.data.type.match(/spotify:ad:leaderboard/)) {
      debug('Received leaderboard message: %o', e.data);
    }
  };

  handler.cleanup = function (leaderboardWindow, timeoutMs) {
    if (!currentUuid) {
      return Promise.resolve(true);
    }
    var cleanupDone = false;
    return Promise.race([new Promise(function (resolve) {
      onCleanup = function onCleanup(eventData) {
        if (eventData.uuid === currentUuid) {
          cleanupDone = true;
          resolve(true);
        }
      };
      debug('sending cleanup message to leaderboard with uuid: ' + currentUuid);
      leaderboardWindow.postMessage({
        uuid: currentUuid,
        type: 'spotify:ad:leaderboard:cleanup'
      }, '*');
    }), new Promise(function (resolve) {
      setTimeout(function () {
        if (currentUuid && !cleanupDone) {
          debug('warning: timed out on cleanup routine after ' + timeoutMs + 'ms');
        }
        resolve(true);
      }, timeoutMs);
    })]);
  };

  handler.logClosed = function (jsonData) {
    logEvent(adEventLogger, 'event_closed', jsonData, renderedAdProps);
  };

  return handler;
}

exports.default = {
  iframeWithContent: iframeWithContent,
  renderLeaderboard: renderLeaderboard,
  renderCloseButton: renderCloseButton,
  setAndEvalTrustedHtml: setAndEvalTrustedHtml,
  subscribeToPreview: subscribeToPreview,
  leaderboardMessageHandler: leaderboardMessageHandler,
  logEvent: logEvent
};

},{"../../event-types":96,"./CONSTANTS":113,"debug":369}],115:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _targeter = require('../../targeter');

var _targeter2 = _interopRequireDefault(_targeter);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _adEventLogger = require('../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _adFeedbackButton = require('../../ad-feedback-button');

var _adFeedbackButton2 = _interopRequireDefault(_adFeedbackButton);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _CONSTANTS = require('./CONSTANTS');

var _dfp = require('../../dfp');

var _dfp2 = _interopRequireDefault(_dfp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cosmosConnector = new _cosmosConnector2.default();

var DEFAULT_LEADERBOARD_REFRESH_INTERVAL = 30000;

var LeaderboardAd = {};

LeaderboardAd.create = function (el) {
  var state = {
    INVENTORY_TYPE: 'banner',
    HEIGHT: 90,
    WIDTH: 728,
    el: el,
    timer: null,
    refreshInterval: DEFAULT_LEADERBOARD_REFRESH_INTERVAL,
    inventoryUnit: '',
    platform: _session2.default.get().platform
  };

  var instance = {};

  /**
   * Enable the leaderboard component inside the container.
   * @return {Promise}
   */
  instance.enable = function () {
    subscribeToPreviewUri(state.INVENTORY_TYPE, state.el);

    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_LEADERBOARD, function () {
      instance.disable();
      instance.enable();
    });

    instance.enableRefresh();

    return instance._render();
  };

  /**
   * Disable the leaderboard component
   * @return void
   */
  instance.disable = function () {
    window.removeEventListener('message', handleHouseAdMessage);
    instance.removeContent();
    instance.disableRefresh();
  };

  /**
   * Clear container innerHTML
   * @return {void}
   */
  instance.removeContent = function () {
    state.el.innerHTML = '';
  };

  /**
   * Enable refreshing of leaderboard
   * @return {void}
   */
  instance.enableRefresh = function () {
    window.clearInterval(state.timer);
    state.timer = window.setInterval(instance._render, state.refreshInterval);
    console.log('scheduled timer', state.timer, 'for interval', state.refreshInterval);
  };

  /**
   * Disable refreshing of leaderboard
   * @return {void}
   */
  instance.disableRefresh = function () {
    if (state.timer) {
      window.clearInterval(state.timer);
      state.timer = null;
    }
  };

  /**
   * Test helper to check internal state of instance
   * @private
   * @param {String} key - key in state obj
   * @return {any}
   */
  instance._get = function (key) {
    return state[key];
  };

  /**
   * Test helper to check internal state of instance
   * @private
   * @param {String} value - value to set
   * @param {String} key - key in state obj
   * @return {void}
   */
  instance._set = function (value, key) {
    state[key] = value;
  };

  /**
   * Wrapper for getting targeting and rendering ad
   * @private (Exposed only for testing)
   * @return {Promise}
   */
  instance._render = function () {
    var inventoryUnit = _dfp2.default.inventoryUnit(state.platform, false);

    return _targeter2.default.getTargeting(inventoryUnit).then(updateRefreshInterval).then(appendTargetingData).then(function (data) {
      var iframe = _utils2.default.createSandboxedIframe();
      iframe.style.display = 'none';

      instance._renderView({
        i: iframe,
        gpt: _dfp2.default.renderGPT(data)
      });
    });
  };

  /**
   * @private (Exposed only for testing)
   * @param {Object} opt
   * @param {HTMLElement} opt.i - iframe
   * @param {String} opt.gpt - gpt string
   */
  instance._renderView = function (opt) {
    var iframe = opt.i;

    buildView(iframe, opt.gpt, state.el);

    var iframeDoc = iframe.contentDocument;

    iframeDoc.addEventListener('placementReady', function () {
      // Grab details about the line item, creative id, and slot
      var impressionData = iframe.contentWindow.slotRenderEndedObj;

      deleteOldLeaderboard(state.el);

      iframeDoc.body.style.overflow = 'hidden';
      iframe.style.display = 'block';

      logViewed(impressionData);

      attachAdFeedbackButton(impressionData, state.el);

      dispatchPlacementEvent(false);
    });

    iframeDoc.addEventListener('eventEmpty', function () {
      dispatchPlacementEvent(true);
      logError();
    });
  };

  function updateRefreshInterval(data) {
    var REFRESH_KEY = 'leaderboard_refresh_interval';
    var targetingInterval = data.targetingData[REFRESH_KEY];

    if (targetingInterval && state.refreshInterval !== targetingInterval) {
      state.refreshInterval = targetingInterval;
    }

    return data;
  }

  function appendTargetingData(data) {
    return Object.assign({}, data, {
      inventoryType: state.INVENTORY_TYPE,
      width: state.WIDTH,
      height: state.HEIGHT
    });
  }

  /**
   * Listen for post message from leaderboard creative template
   * and dispatch event to router for login token in order to be
   * autologged in on spotify website
   */
  window.addEventListener('message', handleHouseAdMessage, false);

  return instance;
};

/**
 * Listen for and render preview uris
 * @private
 * @return {void}
 */
function subscribeToPreviewUri(inventoryType, domEl) {
  cosmosConnector.subscribeToFormat(inventoryType, function (data) {
    // Only handle leaderboard previews
    if (data.ad.display && data.ad.display[0].width !== 728) return;

    var jsonAd = data.ad.display[0];
    var iframe = _utils2.default.createSandboxedIframe();

    domEl.innerHTML = '';

    buildView(iframe, jsonAd.media, domEl);

    iframe.style.display = 'block';
  });
}

/**
 * Parse url params and dispatches event to router
 * @private
 * @return {void}
 */
function handleHouseAdMessage(e) {
  if (e.data && e.data.type === 'ads-upgrade-account') {
    var url = e.data.click;
    var params = url.match(/\?(.*)$/)[1];

    _spotifyEventDispatcher2.default.dispatchEvent({
      type: _eventTypes2.default.NAVIGATION_UPGRADE,
      params: { tracking: params }
    });
  }
}

function buildView(iframe, content, domEl) {
  iframe.id = 'leaderboard-ad-element';

  var divWrapper = document.createElement('div');
  divWrapper.id = 'leaderboard-ad-wrapper';
  divWrapper.appendChild(iframe);
  domEl.appendChild(divWrapper);

  var iframeDoc = iframe.contentDocument;
  iframeDoc.open();
  iframeDoc.write(content);
  iframeDoc.close();
}

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logViewed(props) {
  var message = {};
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'banner';
  message[_adEventLogger2.default.keys.EVENT] = 'event_viewed';
  message[_adEventLogger2.default.keys.SLOT] = _CONSTANTS.LEADERBOARD_SLOT_ID;
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = props.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = props.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = props.creativeId;
  message[_adEventLogger2.default.keys.JSONDATA] = JSON.stringify({
    leaderboardVersion: 1
  });

  _adEventLogger2.default.log(message);
}

/**
 * @private
 */
function logError() {
  var message = {};
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'banner';
  message[_adEventLogger2.default.keys.EVENT] = 'event_errored';
  message[_adEventLogger2.default.keys.SLOT] = _CONSTANTS.LEADERBOARD_SLOT_ID;
  message[_adEventLogger2.default.keys.JSONDATA] = JSON.stringify({
    'dfp_returned_empty': true
  });
  _adEventLogger2.default.log(message);
}

function attachAdFeedbackButton(data, domEl) {
  _adFeedbackButton2.default.checkFeatureFlag().then(function () {
    (0, _adFeedbackButton2.default)(data.creativeId).appendTo(domEl);
  }).catch(function () {});
}

function dispatchPlacementEvent(isEmpty) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    type: _eventTypes2.default.AD_LEADERBOARD_PLACEMENT,
    params: { isEmpty: isEmpty }
  });
}

/**
  * If there is more than 1 existing leaderboard wrapper div, delete older ones
  * @private
  * @return void
  */
function deleteOldLeaderboard(domEl) {
  var len = void 0;

  if (domEl.children.length > 1) {
    len = domEl.children.length - 1;

    for (len; len > 0; len--) {
      domEl.removeChild(domEl.children[0]);
    }
  }
}

exports.default = LeaderboardAd;

},{"../../../../spotify-event-dispatcher":146,"../../ad-event-logger":87,"../../ad-feedback-button":88,"../../cosmos-connector":90,"../../dfp":93,"../../event-types":96,"../../session":127,"../../targeter":129,"../../utils":130,"./CONSTANTS":113}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _adEventLogger = require('../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _CONSTANTS = require('./CONSTANTS');

var _CONSTANTS2 = _interopRequireDefault(_CONSTANTS);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug')('saf:leaderboard');

var DEFAULT_AD_WIDTH = 728;
var DEFAULT_AD_HEIGHT = 90;

/**
 * Version 3 of the leaderboard ad, which makes hm://ads/ requests
 * to retrieve configuration details and display ads.
 */

var LeaderboardAdV3 = function () {
  function LeaderboardAdV3(domElement) {
    var _this = this;

    _classCallCheck(this, LeaderboardAdV3);

    debug('init leaderboard v3');
    this.domElement = domElement;
    this.cosmosConnector = new _cosmosConnector2.default();
    this.refreshInterval = _CONSTANTS2.default.DEFAULT_REFRESH_INTERVAL_MS;
    this.sandboxParams = _CONSTANTS2.default.DEFAULT_SANDBOX_PARAMS;
    this.appBlacklist = null;
    this.appWhitelist = null;
    this.refreshTimer = undefined;
    this.closeLifetimeMs = _CONSTANTS2.default.DEFAULT_CLOSE_LIFETIME_MS;
    var leaderboardVersion = 3;

    this.onLeaderboardMessage = _util2.default.leaderboardMessageHandler(_adEventLogger2.default, _spotifyEventDispatcher2.default, domElement, leaderboardVersion);

    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_HTML, function (e) {
      _this._overrideAdHtml = e.params.html;
    });
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_LEADERBOARD, function () {
      _this.disable();
      _this.enable();
    });
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_FLAGS, function (e) {
      _this._adSlotFlags = e.params.flags;
    });
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_REFRESH_INTERVAL, function (e) {
      _this._overrideRefreshInterval = e.params.interval;
      _this.enableRefresh();
    });

    this.renderNext.bound = this.renderNext.bind(this);

    // Subscribe to preview events from core
    _util2.default.subscribeToPreview(this.cosmosConnector, document, this.domElement, this.disableRefresh.bind(this));

    // Used to defer enable() of leaderboard that is waiting to cleanup.
    this._cleanupGate = Promise.resolve(true);
  }

  /**
   * Enable the leaderboard component inside the container.
   *
   * @api public
   */


  _createClass(LeaderboardAdV3, [{
    key: 'enable',
    value: function enable() {
      var _this2 = this;

      if (this._disabling) {
        return Promise.reject(new Error('cannot enable while disabling leaderboard'));
      }
      if (this._closed) {
        return Promise.reject(new Error('cannot enable while leaderbard in a closed state'));
      }
      debug('enable leaderboard');
      this._enabled = true;
      return this._cleanupGate.then(function () {
        if (_this2._enabled) {
          window.addEventListener('message', _this2.onLeaderboardMessage);
          _this2.enableRefresh();
          return _this2.renderNext();
        }
      });
    }

    /**
     * Disable the leaderboard component inside the container.
     * @return Promise resolving when disabling is complete.
     * @api public
     */

  }, {
    key: 'disable',
    value: function disable() {
      var _this3 = this;

      debug('disable leaderboard');
      this._enabled = false;
      this.disableRefresh();
      this._disabling = true;
      return this.removeContent().then(function () {
        _this3._disabling = false;
        window.removeEventListener('message', _this3.onLeaderboardMessage);
      });
    }

    /**
     * Enable refreshing the ad, for example, if the user is in focus.
     *
     * @api public
     */

  }, {
    key: 'enableRefresh',
    value: function enableRefresh() {
      this.disableRefresh();
      var refreshInterval = this._overrideRefreshInterval || this.refreshInterval;
      debug('set refresh interval=%o', refreshInterval);
      this.refreshTimer = window.setInterval(this.renderNext.bound, refreshInterval);
    }

    /**
     * Disable refreshing the ad.
     *
     * @api public
     */

  }, {
    key: 'disableRefresh',
    value: function disableRefresh() {
      window.clearInterval(this.refreshTimer);
    }
  }, {
    key: 'onClose',
    value: function onClose() {
      var _this4 = this;

      this._closed = true;
      debug('closing for %o ms', this.closeLifetimeMs);
      setTimeout(function () {
        _this4._closed = false;
      }, this.closeLifetimeMs);
      this.onLeaderboardMessage.logClosed({
        closeLifetimeMs: this.closeLifetimeMs
      });
      return this.disable();
    }

    /**
     * Clear the content.
     *
     * @return Promise resolving when removing the content is complete.
     * @api public
     */

  }, {
    key: 'removeContent',
    value: function removeContent() {
      var _this5 = this;

      debug('removeContent');
      return this.cleanup().then(function () {
        debug('clearInnerHTML');
        _this5.domElement.innerHTML = '';
      });
    }

    /**
     * Perform cleanup operations on a leaderboard which will be imminently removed.
     *
     * @return Promise resolving when cleanup operation is complete.  This may be immediately
     *   invoked on the job queue if the cleanup_timeout_ms value was never provided by
     *   the backend.
     */

  }, {
    key: 'cleanup',
    value: function cleanup() {
      if (this._cleanup_timeout_ms) {
        this._cleanupGate = this.onLeaderboardMessage.cleanup(window, this._cleanup_timeout_ms);
      }
      return this._cleanupGate;
    }

    /**
     * Handle the config response from spotify-ad-service
     *
     * @api private
     */

  }, {
    key: 'handleConfig',
    value: function handleConfig(config) {
      if (config.request_when && config.request_when.focus_time_elapsed_ms) {
        this.refreshInterval = config.request_when.focus_time_elapsed_ms;
        this.enableRefresh();
      }
      if (config.iframe_sandboxed_attrs) {
        this.sandboxParams = config.iframe_sandboxed_attrs;
      }
      if (config.app_blacklist) {
        this.appBlacklist = config.app_blacklist;
      }
      if (config.app_whitelist) {
        this.appWhitelist = config.app_whitelist;
      }
      if (config.close_lifetime_ms) {
        var closeLifetimeMs = parseInt(config.close_lifetime_ms, 10);
        if (closeLifetimeMs) {
          this.closeLifetimeMs = closeLifetimeMs;
        }
      }
    }

    /**
     * Fetch targeting parameters and render the iframe that loads gpt that
     * fetches and renders an ad.
     *
     * @api private
     * @return {Promise}
     */

  }, {
    key: 'renderNext',
    value: function renderNext() {
      var self = this;
      this._renderIter = this._renderIter || 0;
      var renderIter = ++this._renderIter;
      return this.cosmosConnector.getAdSlotConfig(_CONSTANTS2.default.LEADERBOARD_SLOT_ID).then(function (config) {
        self.handleConfig(config);
        debug('received config', config);
      }).catch(function (e) {
        var mesg = e.message ? e.message : String(e);
        _adEventLogger2.default.logError('leaderboard:on:config', mesg);
        debug('renderNext:config error: ' + mesg);
      }).then(function () {
        return self.cosmosConnector.getAdForSlot(_CONSTANTS2.default.LEADERBOARD_SLOT_ID, self._adSlotFlags);
      }).then(function (ad) {
        debug('received ad', ad);
        if (!self._enabled) {
          throw new Error('leaderboard-unit-disabled');
        }
        // If renderNext has been called again before the final render, discard
        // this ad as being expired.
        if (self._renderIter !== renderIter) {
          throw new Error('leaderboard-expired');
        }
        if (ad.cleanup_timeout_ms) {
          self._cleanup_timeout_ms = ad.cleanup_timeout_ms;
        }

        var adDisplay = ad.display.filter(function (display) {
          return display.mimetype === 'text/html';
        })[0];

        var metadata = ad.metadata || {};
        var closeableAfterMs = metadata.closeable_after_ms ? parseInt(metadata.closeable_after_ms, 10) : null;

        var html = adDisplay ? adDisplay.media_file : ad.html;
        var width = adDisplay ? adDisplay.width : DEFAULT_AD_WIDTH;
        var height = adDisplay ? adDisplay.height : DEFAULT_AD_HEIGHT;

        if (!html) {
          throw new Error("ad has no html");
        }

        if (ad.same_frame) {
          self.renderSameFrameAd(html, width, height, closeableAfterMs);
        } else {
          self.render(_util2.default.iframeWithContent(document, self._overrideAdHtml || html, self.sandboxParams), width, height, closeableAfterMs);
        }

        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.DEBUG_RECEIVED_AD_LEADERBOARD_HTML,
          params: { html: ad.html },
          extra: {}
        });
      }).catch(function (e) {
        var mesg = e.message ? e.message : String(e);
        _adEventLogger2.default.logError('leaderboard:on:ad', mesg);
        debug('renderNext error: ' + mesg);
      });
    }

    /**
     * Render an ad in the top-level frame
     */

  }, {
    key: 'renderSameFrameAd',
    value: function renderSameFrameAd(html, width, height, closeableAfterMs) {
      var _this6 = this;

      this.cleanup().then(function () {
        var leaderboardDiv = document.createElement('div');
        _this6.render(leaderboardDiv, width, height, closeableAfterMs);
        _util2.default.setAndEvalTrustedHtml(document, leaderboardDiv, _this6._overrideAdHtml || html);
      });
    }

    /**
     * Render an iframe with given src attribute.
     *
     * @api private
     * @param {Element} node The DOM element containing the leaderboard
     * @param {Integer} width The styled width of the generated ad element
     * @param {Integer} width The styled height of the generated ad element
     * @param {Integer} [closeableAfterMs] If set, will render a close button
     */

  }, {
    key: 'render',
    value: function render(node, width, height, closeableAfterMs) {
      debug('render');
      _util2.default.renderLeaderboard(document, this.domElement, node, width, height);
      if (closeableAfterMs) {
        _util2.default.renderCloseButton(document, this.domElement, this.onClose.bind(this), closeableAfterMs);
      }
    }
  }]);

  return LeaderboardAdV3;
}();

exports.default = LeaderboardAdV3;

},{"../../../../spotify-event-dispatcher":146,"../../ad-event-logger":87,"../../cosmos-connector":90,"../../event-types":96,"./CONSTANTS":113,"./util":114,"debug":369}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _logoTemplate = require('./logo-template.hbs');

var _logoTemplate2 = _interopRequireDefault(_logoTemplate);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _adEventLogger = require('../../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:sponsored-playlist');

var cosmosConnector = new _cosmosConnector2.default();


var SponsoredPlaylist = {};

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logClicked(props) {
  var message = {};
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'sponsored playlist';
  message[_adEventLogger2.default.keys.EVENT] = 'event_clicked';
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = props.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = props.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = props.creativeId;

  _adEventLogger2.default.log(message);
  debug('logClicked message=%o', message);
}

/**
 * @private
 * @param  {String} reason
 */
function logError(reason) {
  var message = {};
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'sponsored playlist';
  message[_adEventLogger2.default.keys.EVENT] = 'event_errored';
  message[_adEventLogger2.default.keys.JSONDATA] = JSON.stringify({
    reason: reason
  });

  _adEventLogger2.default.log(message);
  debug('logError message=%o', message);
}

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logViewed(props) {
  var message = {};
  message[_adEventLogger2.default.keys.AD_FORMAT] = 'sponsored playlist';
  message[_adEventLogger2.default.keys.EVENT] = 'event_viewed';
  message[_adEventLogger2.default.keys.LINE_ITEM_ID] = props.lineItemId;
  message[_adEventLogger2.default.keys.CREATIVE_ID] = props.creativeId;
  message[_adEventLogger2.default.keys.AD_ID] = props.creativeId;

  _adEventLogger2.default.log(message);
  debug('logViewed message=%o', message);
}

/**
 * @private
 * @param {Object} props
 * @param {String} props.clickTracking
 * @param {String} props.clickThrough
 * @param {String} props.logoUrl
 * @param {String} props.impression
 * @param {String} props.thirdPartyImpression
 * @param {String} props.creativeId
 * @param {String} props.lineItemId
 * @return {HTMLElement} el
 */
function createLogoEl(props) {
  var el = document.createElement('div');

  el.className = 'sponsored-logo';

  el.innerHTML = (0, _logoTemplate2.default)({
    clickSrc: props.clickThrough,
    logoSrc: props.logoUrl,
    impSrc: props.impression,
    thirdPartyImpSrc: props.thirdPartyImpression
  });

  el.addEventListener('click', function () {
    logClicked(props);
    _utils2.default.appendTrackingPixel(props.clickTracking, el);
    debug('Logo clicked');
  });

  return el;
}

/**
 * @private
 * @param {HTMLElement} container
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 * @param {String} props.clickTracking
 * @param {String} props.clickThrough
 * @param {String} props.label
 * @param {String} props.logoUrl
 * @param {String} props.impression
 * @param {String} props.thirdPartyImpression
 * @param {String} props.advertiserName
 * @return {Object} sponsoredPlaylist
 */
function create(_props) {
  var sponsoredPlaylist = {};
  var props = parseProps(_props);
  var logoEl = createLogoEl(props);
  var hasStarted = false;

  sponsoredPlaylist.appendLogoTo = function (el) {
    if (!hasStarted) {
      hideLeaderboard();
      logViewed(props);
      debug('active');
      logoEl.classList.add('fade-in');
    } else {
      logoEl.classList.remove('fade-in');
    }

    el.appendChild(logoEl);

    hasStarted = true;
    return sponsoredPlaylist;
  };

  sponsoredPlaylist.getLabel = function () {
    return props.label;
  };

  return sponsoredPlaylist;
}

/**
 * @param  {Object} opts
 * @param  {String} opts.uri
 * @return {Promise}
 */
SponsoredPlaylist.fetch = function (opts) {
  var uri = opts.uri;
  debug('fetch on uri=%o', uri);

  return cosmosConnector.getSponsoredUris().then(function (res) {
    debug('sponsored uri response=%o', res);
    if (!checkIfSponsored(uri, res.sponsorships)) {
      debug('Playlist not sponsored');
      return false;
    }

    return cosmosConnector.getSponsorshipAd(uri).then(create).catch(logError.bind(null, 'ad_failed_to_retrieve'));
  });
};

/**
 * @param  {Function} cb
 * @return {void}
 */
SponsoredPlaylist.subscribeToPreviewUri = function (cb) {
  cosmosConnector.subscribeToFormat('banner', function (data) {
    // Only handle leaderboard previews
    if (data.ad.display && data.ad.display[0].width !== 300) return;

    var regex = /\{(.|\s)+\}/;

    var adData = JSON.parse(data.ad.display[0].media.match(regex)[0]).sponsoredPlaylist;

    var sponsorship = create(Object.assign({}, adData, { logoUrl: adData.logo }));

    cb(sponsorship);
  });
};

/**
 * Check uri
 * @param  {String}   uri
 * @param  {Object[]} sponsorships
 * @return {Boolean}
 */
function checkIfSponsored(uri, sponsorships) {
  var time = Date.now() / 1000;

  return sponsorships.some(function (sponsorship) {
    var endTime = sponsorship.endTime || time + 1;

    return sponsorship.spotifyUri === uri && time >= sponsorship.startTime && time < endTime;
  });
}

function hideLeaderboard() {
  // todo revisit this
  debug('hideLeaderboard');
  window.parent.postMessage({ type: _eventTypes2.default.AD_SPONSORSHIP_ACTIVE }, 'http://zlink.app.spotify.com');
}

function parseProps(props) {
  return {
    lineItemId: props.lineItemId,
    creativeId: props.creativeId,
    clickTracking: props.clickTracking,
    clickThrough: props.clickThrough,
    logoUrl: props.logoUrl,
    impression: props.impression,
    thirdPartyImpression: props.thirdPartyImpression,
    advertiserName: props.advertiserName,
    label: [_i18n2.default.get('PresentedBy'), props.advertiserName].join(' ')
  };
}

exports.default = SponsoredPlaylist;

},{"../../../i18n":74,"../../ad-event-logger":87,"../../cosmos-connector":90,"../../event-types":96,"../../utils":130,"./logo-template.hbs":118,"debug":369}],118:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <img class=\"3p-imp-pixel\" style=\"display:none;width:1px;height:1px;\" src=\"";
  if (helper = helpers.thirdPartyImpSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.thirdPartyImpSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n";
  return buffer;
  }

  buffer += "<a href=\"";
  if (helper = helpers.clickSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <img src=\"";
  if (helper = helpers.logoSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.logoSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n</a>\n  <img class=\"imp-pixel\" style=\"display:none;width:1px;height:1px;\" src=\"";
  if (helper = helpers.impSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.impSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.thirdPartyImpSrc), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],119:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyVideoManager = require('../../../../spotify-video-manager');

var _spotifyVideoManager2 = _interopRequireDefault(_spotifyVideoManager);

var _vastEvents = require('../../vast-events');

var _vastEvents2 = _interopRequireDefault(_vastEvents);

var _eventLogger = require('../../event-logger');

var _moatLogger = require('../../moat-logger');

var _moatLogger2 = _interopRequireDefault(_moatLogger);

var _videoUtils = require('../../video-utils');

var _videoUtils2 = _interopRequireDefault(_videoUtils);

var _template = require('./template.hbs');

var _template2 = _interopRequireDefault(_template);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:video:view');


var STARTED = 'STARTED';
var DESTROYING = 'DESTROYING';
var DESTROYED = 'DESTROYED';

var BUFFERING_FAIL_TIMEOUT = 5000;
var FAILURE_BUFFER_TIMEOUT = 'video_error_buffer_timeout';
var FAILURE_NOT_IN_FOCUS = 'video_error_not_in_focus';
var FAILURE_GENERAL = 'video_error_general_error';

var maxContainer = null;
var minContainer = null;

var isBetamaxEnabled = global.__spotify && global.__spotify.product_state && global.__spotify.product_state['ad-betamax-video'] === '1';

debug('isBetamaxEnabled: %o', isBetamaxEnabled);
var isBetamaxFlatEnabled = global.__spotify && global.__spotify.product_state && global.__spotify.product_state['ad-betamax-flat-video'] === '1';

debug('isBetamaxFlatEnabled: %o', isBetamaxFlatEnabled);

var View = {
  create: function create(ad) {
    debug('create: %o', ad);
    var el = createEl();
    var videoContainerEl = getVideoContainerEl(el);
    var emitter = new _events.EventEmitter();
    var EVENT = 'EVENT';
    var logEvent = new _eventLogger.EventLogger(ad.id).logEvent;
    var videoSrc = null;
    var videoEl = null;
    var videoId = null;
    var fireOnStart = ad.metadata && ad.metadata.fireImpressionOnStart;
    var clickUrl = ad.click_url;
    var _nowPlaying = parseNowPlaying(ad);
    var isEnded = false;
    var isResizing = false;
    var _isBetamax2 = isBetamaxEnabled && (_isBetamax(ad) || isBetamaxFlatEnabled);
    var isStarted = false;
    var _isDestroyed = false;
    var destroyPromise = null;
    var ignoreVastEvents = false;
    var unsubscribeVast = null;
    var logMoatEvent = function logMoatEvent() {};

    var view = {
      nowPlaying: function nowPlaying() {
        return _nowPlaying;
      },
      isBetamax: function isBetamax() {
        return _isBetamax2;
      },
      isDestroyed: function isDestroyed() {
        return _isDestroyed;
      },
      start: function start() {
        debug('start: isStarted=%o err=%o', isStarted, videoEl.error);
        if (isStarted) return view;

        if (!hasFocus()) return view.fail(FAILURE_NOT_IN_FOCUS);
        if (videoEl.error) return view.fail();

        videoContainerEl.appendChild(videoEl);
        if (videoId) _spotifyVideoManager2.default.setActiveVideo(videoId);
        startListening();
        videoEl.play();
        maximize(true);
        isStarted = true;
        if (fireOnStart) logEvent('viewed');
        return view;
      },
      destroy: function destroy(silent) {
        debug('destroy');
        if (!destroyPromise) {
          emitter.emit(EVENT, DESTROYING);

          destroyPromise = new Promise(function (resolve) {
            if (isStarted) stopListening();
            if (el.parentNode) el.parentNode.removeChild(el);
            if (videoId) destroyVideoPlayer(videoId);
            resolve();
          }).then(function () {
            if (silent || _isBetamax2) return null;
            isEnded = isEnded || videoEl.currentTime === videoEl.duration;
            if (!isEnded) return logEvent('skipped');
            if (!fireOnStart) logEvent('viewed');
            return logEvent('ended');
          }).then(function () {
            _isDestroyed = true;
            emitter.emit(EVENT, DESTROYED);
            return view;
          });
        }

        return destroyPromise;
      },
      fail: function fail(reason) {
        debug('fail: reason=%o', reason);
        return logEvent('errored', {
          'event_version': reason || FAILURE_GENERAL
        }).then(function () {
          return view.destroy(true);
        });
      },
      minimize: function minimize(silent) {
        _minimize(silent);
        return view;
      },
      setVideoEl: function setVideoEl(_videoEl) {
        if (videoEl) throw new Error('videoEl already set');
        videoEl = _videoEl;
        return view;
      },
      logClick: function logClick() {
        logEvent('clicked');
        return view;
      },
      subscribe: function subscribe(callback) {
        emitter.on(EVENT, callback);
        return emitter.removeListener.bind(emitter, EVENT, callback);
      },


      EVENTS: {
        STARTED: STARTED,
        DESTROYING: DESTROYING,
        DESTROYED: DESTROYED
      }
    };

    if (!_isBetamax2) {
      videoSrc = getPreferredVideoUrl(ad.videos);
      videoEl = createVideoEl();
      videoId = createVideoPlayer(videoEl, videoSrc);
    }

    function startListening() {
      videoEl.addEventListener('ended', onEnded);
      videoEl.addEventListener('error', onError);
      el.addEventListener('click', onClick);
      if (videoId) _spotifyVideoManager2.default.subscribe(videoId, onVideoPlayerChange);

      if (ad.metadata['moat.enabled'] === 'true') {
        var ids = {
          level1: ad.metadata.advertiser_id,
          level2: ad.metadata.order_id,
          level3: ad.metadata.lineitem_id,
          level4: ad.metadata.creative_id
        };

        var moatIds = void 0;

        if (ad.metadata.dealId) {
          // SpotXChange ad
          moatIds = Object.assign({}, ids, {
            dealId: ad.metadata.dealId,
            domain: ad.metadata.domain,
            channelId: ad.metadata.channelId
          });
        } else if (ad.metadata.zMoatVF) {
          // Videology ad
          moatIds = Object.assign({}, ids, {
            zMoatCLUSTERID: ad.metadata.zMoatCLUSTERID,
            zMoatLOne: ad.metadata.zMoatLOne,
            zMoatLThree: ad.metadata.zMoatLThree,
            zMoatLTwo: ad.metadata.zMoatLTwo,
            zMoatSOne: ad.metadata.zMoatSOne,
            zMoatSTwo: ad.metadata.zMoatSTwo,
            zMoatVADID: ad.metadata.zMoatVADID,
            zMoatVCP: ad.metadata.zMoatVCP
          });
        } else {
          moatIds = ids;
        }

        logMoatEvent = _moatLogger2.default.create({
          container: el,
          videoNode: videoEl,
          ids: moatIds
        });
      }

      unsubscribeVast = _vastEvents2.default.subscribe(videoEl, onVastEvent);
    }

    function stopListening() {
      videoEl.removeEventListener('ended', onEnded);
      videoEl.removeEventListener('error', onError);
      el.removeEventListener('click', onClick);
      if (videoId) _spotifyVideoManager2.default.unsubscribe(videoId, onVideoPlayerChange);
      if (unsubscribeVast) unsubscribeVast();
    }

    function onClick(e) {
      e.preventDefault();
      e.stopPropagation();

      if (e.target === videoEl) openUrl();else if (e.target.dataset.click === 'maximize') maximize();else if (e.target.dataset.click === 'minimize') _minimize();

      function openUrl() {
        logEvent('clicked');
        window.open(clickUrl);
      }
    }

    function onEnded() {
      isEnded = true;
      view.destroy();
    }

    function onError() {
      view.fail();
    }

    function onVastEvent(eventName) {
      var EVENTS = _vastEvents2.default.EVENTS;
      console.log('vast', EVENTS);

      if (ignoreVastEvents) return;

      logMoatEvent(_moatLogger2.default.EVENTS[eventName]);

      if (_isBetamax2 && eventName === EVENTS.STARTED) return;

      if (eventName === EVENTS.SKIPPED || eventName === EVENTS.ENDED) {
        logMoatEvent(_moatLogger2.default.EVENTS.stopped);
      } else {
        // skipped and ended are logged later
        logEvent(eventName);
      }
    }

    function isMinimized() {
      return el.parentNode === minContainer;
    }

    function isMaximized() {
      return el.parentNode === maxContainer;
    }

    function _minimize(silent) {
      if (isResizing || isMinimized()) return;
      isResizing = true;

      el.classList.add('will-minimize');

      setTimeout(function () {
        el.classList.add('minimize');
        setTimeout(function () {
          moveTo(minContainer, function () {
            el.classList.remove('will-minimize', 'minimize');
            isResizing = false;
            if (!silent) logEvent('collapsed');
          });
        }, 300);
      }, 0);
    }

    function maximize(silent) {
      if (isResizing || isMaximized()) return;
      isResizing = true;

      el.classList.add('will-maximize');

      moveTo(maxContainer, function () {
        setTimeout(function () {
          el.classList.add('maximize');
          setTimeout(function () {
            el.classList.remove('will-maximize', 'maximize');
            isResizing = false;
            if (!silent) logEvent('expanded');
          }, 300);
        }, 0);
      });
    }

    function moveTo(parentEl, callback) {
      var wasPlaying = !videoEl.paused;
      ignoreVastEvents = true;
      parentEl.appendChild(el);

      if (!wasPlaying || !videoEl.paused) {
        done();
        return;
      }

      videoEl.addEventListener('play', function onPlay() {
        videoEl.removeEventListener('play', onPlay);
        done();
      });

      videoEl.play();

      function done() {
        ignoreVastEvents = false;
        if (callback) callback();
      }
    }

    function onVideoPlayerChange(err, p, c) {
      if (err) view.fail();
      // todo support betamax videos
      // todo refactor buffering logic
      if (c.isBuffering && c.timeBuffering >= BUFFERING_FAIL_TIMEOUT) {
        view.fail(FAILURE_BUFFER_TIMEOUT);
      }

      if (c.volume !== p.volume) {
        logMoatEvent(_moatLogger2.default.EVENTS.volumechange);
      }
    }

    return view;
  },
  appendMaxTo: function appendMaxTo(parentEl) {
    if (!maxContainer) maxContainer = createDiv('saf-video-takeover-max');
    parentEl.appendChild(maxContainer);
    return View;
  },
  appendMinTo: function appendMinTo(parentEl) {
    if (!minContainer) minContainer = createDiv('saf-video-takeover-min');
    parentEl.appendChild(minContainer);
    return View;
  }
};

function createEl() {
  var el = createDiv('saf-video-takeover');
  el.innerHTML = (0, _template2.default)();
  return el;
}

function createDiv(className) {
  var div = createElement('div');
  div.className = className;
  return div;
}

function getVideoContainerEl(el) {
  return el.getElementsByClassName('saf-video-takeover-video')[0];
}

function createVideoEl() {
  var videoEl = createElement('video');
  videoEl.muted = true;
  videoEl.preload = 'auto';
  return videoEl;
}

function createVideoPlayer(videoEl, url) {
  var videoId = _spotifyVideoManager2.default.createVideo(videoEl, {
    url: url,
    isAd: true,
    volume: 0,
    startPaused: true
  });

  return videoId;
}

function destroyVideoPlayer(videoId) {
  var videoPlayer = _spotifyVideoManager2.default.getVideo(videoId);
  if (!videoPlayer) return;
  var activeVideoPlayer = _spotifyVideoManager2.default.getActiveVideo();
  if (videoPlayer === activeVideoPlayer) _spotifyVideoManager2.default.clearActiveVideo();
  _spotifyVideoManager2.default.destroy(videoId, true);
}

function getPreferredVideoUrl(videos) {
  var preferredVideo = _videoUtils2.default.getPreferredVideoMetadata(videos || []);
  return preferredVideo && preferredVideo.url;
}

function parseNowPlaying(ad) {
  var WIDTH = 300;
  var HEIGHT = 250;
  var mimeType = /^image\/(jpeg|png)$/;

  return {
    id: ad.id,
    title: ad.title,
    advertiser: ad.advertiser,
    clickUrl: ad.click_url,
    companionAd: getPreferredCompanionAd(ad)
  };

  function getPreferredCompanionAd() {
    var companionAd = void 0;
    var companionAds = ad.companion_ads;
    var l = companionAds && companionAds.length || 0;

    for (var i = 0; i < l; i++) {
      if (!companionAd && companionAds[i].url) {
        companionAd = companionAds[i];
      }

      if (isPreferred(companionAds[i])) {
        companionAd = companionAds[i];
        break;
      }
    }

    return {
      url: companionAd && companionAd.url,
      width: companionAd && companionAd.width,
      height: companionAd && companionAd.height
    };

    function isPreferred(props) {
      return props.width === WIDTH && props.height === HEIGHT && mimeType.test(props.mime_type);
    }
  }
}

function hasFocus() {
  return document.hasFocus();
}

function createElement(tagName) {
  return document.createElement(tagName);
}

function _isBetamax(ad) {
  var videos = ad && ad.videos || [];

  for (var i = 0; i < videos.length; i++) {
    if (videos[i].video_hex_id) return true;
  }

  return false;
}

exports.default = View;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../spotify-video-manager":354,"../../event-logger":95,"../../moat-logger":125,"../../vast-events":131,"../../video-utils":132,"./template.hbs":122,"debug":369,"events":371}],120:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _hasFocus2 = require('../../hasFocus');

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emitter = new _events.EventEmitter();
var EVENT = 'EVENT';
var debug = require('debug')('saf:video:core');
var cosmosConnector = new _cosmosConnector2.default();
var initOnce = (0, _once2.default)(init);

function init() {
  cosmosConnector.addNewSlot('stream', 'video').then(function (placementUri) {
    return cosmosConnector.subscribeToSlot(placementUri, onCoreMessage);
  }).catch(debug);

  function onFocusChange(_hasFocus) {
    cosmosConnector.patchTargeting('adbreak', _hasFocus ? 'video,adscore' : 'adscore');
  }

  _hasFocus2.hasFocus.subscribe(onFocusChange);
  onFocusChange((0, _hasFocus2.hasFocus)());

  function onCoreMessage(data) {
    debug('core message: ', data);
    emitter.emit(EVENT, data);
  }
}

var core = {
  subscribe: function subscribe(callback) {
    initOnce();
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  }
};

exports.default = core;

},{"../../cosmos-connector":90,"../../hasFocus":123,"debug":369,"events":371,"lodash/once":456}],121:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _View = require('./View');

var _View2 = _interopRequireDefault(_View);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:video:index');

var initOnce = (0, _once2.default)(init);

var emitter = new _events.EventEmitter();
var EVENT = 'EVENT';
var views = {};
var currentView = null;

var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var _isEnabled = false;
var _isActive = false;

var VideoTakeoverAd = {
  appendMaxTo: function appendMaxTo(parentEl) {
    _View2.default.appendMaxTo(parentEl);
    return VideoTakeoverAd;
  },
  appendMinTo: function appendMinTo(parentEl) {
    _View2.default.appendMinTo(parentEl);
    return VideoTakeoverAd;
  },
  enable: function enable() {
    debug('enable');
    if (!_isEnabled) {
      initOnce();
      _isEnabled = true;
      emitter.emit(EVENT, ENABLED);
    }

    return VideoTakeoverAd;
  },
  disable: function disable() {
    debug('disable');
    if (_isEnabled) {
      if (currentView) currentView.destroy();
      _isEnabled = false;
      emitter.emit(EVENT, DISABLED);
    }

    return VideoTakeoverAd;
  },
  subscribe: function subscribe(callback) {
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  },
  playBetamaxVideo: function playBetamaxVideo(opts) {
    debug('playBetamaxVideo: %o', opts);
    var adId = opts.adId;
    var videoEl = opts.videoEl;
    var onDestroyed = opts.onDestroyed;
    var view = views[adId];

    var unsubscribe = view.subscribe(function (eventName) {
      if (eventName !== view.EVENTS.DESTROYED) return;
      unsubscribe();
      onDestroyed();
    });

    view.setVideoEl(videoEl);
    playView(view);

    return VideoTakeoverAd;
  },
  getPreferredVideo: function getPreferredVideo(videos) {
    var targetBitRate = 640;
    var mimeTypes = ['video/webm'];

    var preferredVideo = videos && videos.filter(function (video) {
      return mimeTypes.indexOf(video.mimeType) > -1;
    }).sort(function (a, b) {
      var x = Math.abs(a.bitrate - targetBitRate);
      var y = Math.abs(b.bitrate - targetBitRate);
      if (x > y) return 1;
      if (y < x) return -1;
      return 0;
    })[0];

    debug('preferred video selected: videos=%o, preferred=%o', videos, preferredVideo);
    return preferredVideo && preferredVideo.url;
  },
  nowPlaying: function nowPlaying() {
    return currentView && currentView.nowPlaying();
  },
  logClick: function logClick(clickUrl) {
    debug('logClick: %o', clickUrl);
    if (_isActive) currentView.logClick(clickUrl);
    return VideoTakeoverAd;
  },
  isEnabled: function isEnabled() {
    return _isEnabled;
  },
  isActive: function isActive() {
    return _isActive;
  },


  EVENTS: {
    ENABLED: ENABLED,
    DISABLED: DISABLED,
    ACTIVE: ACTIVE,
    INACTIVE: INACTIVE
  }
};

function init() {
  proxyEventsToEventDispatcher();
  _core2.default.subscribe(onCoreMessage);
  subscribeToNavChanges();

  function subscribeToNavChanges() {
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, onNavigationChange);
  }

  // for backwards compatability
  function proxyEventsToEventDispatcher() {
    VideoTakeoverAd.subscribe(function (eventName) {
      if (eventName === ACTIVE) {
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.AD_VIDEO_STARTED
        });
      } else if (eventName === INACTIVE) {
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.AD_VIDEO_FINISHED
        });
      }
    });
  }
}

function onNavigationChange() {
  if (_isActive) currentView.minimize();
}

function onCoreMessage(data) {
  debug('onCoreMessage: %o', data);
  var view = views[data.ad.id];

  if (data.event === 'available' || data.event === 'play') {
    if (!view || view.isDestroyed()) {
      view = views[data.ad.id] = _View2.default.create(data.ad);
    }
  }

  if (data.event === 'play') {
    debug('play isEnabled=%o haveView=%o isBetamax=%o', _isEnabled, !!view, view.isBetamax());
    if (!_isEnabled) view.destroy();else if (!view.isBetamax()) playView(view);
  }

  if (data.event === 'discard') {
    if (view) view.destroy(true);
    views[data.ad.id] = null;
  }
}

function playView(view) {
  debug('playView view=%o', view);
  if (_isActive) currentView.destroy();

  var unsubscribe = view.subscribe(function (eventName) {
    if (eventName !== view.EVENTS.DESTROYING) return;
    unsubscribe();
    if (currentView === view) currentView = null;
    if (!_isActive) return;
    _isActive = false;
    emitter.emit(EVENT, INACTIVE);
  });

  currentView = view;

  _isActive = true;
  emitter.emit(EVENT, ACTIVE);
  view.start();
}

exports.default = VideoTakeoverAd;

},{"../../../../spotify-event-dispatcher":146,"../../event-types":96,"./View":119,"./core":120,"debug":369,"events":371,"lodash/once":456}],122:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"saf-video-takeover-video\" data-qa=\"saf-video-takeover-video\"></div>\n\n<button\n  type=\"button\"\n  class=\"saf-video-takeover-btn-min\"\n  data-qa=\"saf-video-takeover-btn-min\"\n  data-click=\"maximize\"\n>\n  <i class=\"spoticon-chevron-right-16\" data-click=\"maximize\"></i>\n</button>\n\n<button\n  type=\"button\"\n  class=\"saf-video-takeover-btn-max\"\n  data-qa=\"saf-video-takeover-btn-max\"\n  data-click=\"minimize\"\n>\n  <i class=\"spoticon-x-24\" data-click=\"minimize\"></i>\n</button>\n";
  });

},{"hbsfy/runtime":403}],123:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasFocus = undefined;
exports.factory = factory;

var _events = require('events');

var _once2 = require('lodash/once');

var _once3 = _interopRequireDefault(_once2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function factory(_ref) {
  var document = _ref.document;
  var setInterval = _ref.setInterval;
  var EventEmitter = _ref.EventEmitter;
  var once = _ref.once;

  var emitter = new EventEmitter();
  var EVENT = 'EVENT';
  var _hasFocus = void 0;

  var initOnce = once(function () {
    _hasFocus = document.hasFocus();

    setInterval(function () {
      var hadFocus = _hasFocus;
      _hasFocus = document.hasFocus();
      if (hadFocus !== _hasFocus) {
        emitter.emit(EVENT, _hasFocus);
      }
    }, 500);
  });

  function hasFocus() {
    initOnce();
    return _hasFocus;
  }

  hasFocus.subscribe = function (callback) {
    initOnce();
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  };

  return hasFocus;
}

var hasFocus = exports.hasFocus = factory({
  document: typeof document !== 'undefined' && document,
  setInterval: setInterval,
  EventEmitter: _events.EventEmitter,
  once: _once3.default
});

},{"events":371,"lodash/once":456}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SponsoredPlaylistAd = exports.AudioCompanionAd = exports.VideoTakeoverAd = exports.HptoAd = exports.LeaderboardAdV3 = exports.LeaderboardAdV1 = exports.BillboardAd = undefined;

var _billboardAd = require('./formats/billboard-ad');

Object.defineProperty(exports, 'BillboardAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_billboardAd).default;
  }
});

var _v = require('./formats/leaderboard-ad/v1');

Object.defineProperty(exports, 'LeaderboardAdV1', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_v).default;
  }
});

var _v2 = require('./formats/leaderboard-ad/v3');

Object.defineProperty(exports, 'LeaderboardAdV3', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_v2).default;
  }
});

var _hptoAd = require('./formats/hpto-ad');

Object.defineProperty(exports, 'HptoAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_hptoAd).default;
  }
});

var _videoTakeoverAd = require('./formats/video-takeover-ad');

Object.defineProperty(exports, 'VideoTakeoverAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_videoTakeoverAd).default;
  }
});

var _audioCompanionAd = require('./formats/audio-companion-ad');

Object.defineProperty(exports, 'AudioCompanionAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioCompanionAd).default;
  }
});

var _sponsoredPlaylistAd = require('./formats/sponsored-playlist-ad');

Object.defineProperty(exports, 'SponsoredPlaylistAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sponsoredPlaylistAd).default;
  }
});

var _configuration = require('./configuration');

var _configuration2 = _interopRequireDefault(_configuration);

var _helpers = require('../../spotify-handlebars/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _debuggingUtils = require('./debugging-utils');

var _debuggingUtils2 = _interopRequireDefault(_debuggingUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var glueStrings = _i18n2.default.glueStrings();
var appStrings = _i18n2.default.appStrings();

// Temporary workaround while translation workflow gets worked out
glueStrings = glueStrings.strings || glueStrings;
appStrings = appStrings.strings || appStrings;

_helpers2.default.loc.register(glueStrings);
_helpers2.default.loc.register(appStrings);

// Inject configuration
_configuration2.default.setSpotlightSvg(require('../images/logo_spotlight.svg'));

// Public exports

window.Ads = _debuggingUtils2.default;

},{"../../spotify-handlebars/helpers":246,"../i18n":74,"../images/logo_spotlight.svg":84,"./configuration":89,"./debugging-utils":92,"./formats/audio-companion-ad":98,"./formats/billboard-ad":99,"./formats/hpto-ad":105,"./formats/leaderboard-ad/v1":115,"./formats/leaderboard-ad/v3":116,"./formats/sponsored-playlist-ad":117,"./formats/video-takeover-ad":121}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyAbbaMini = require('../../../spotify-abba-mini');

var _spotifyAbbaMini2 = _interopRequireDefault(_spotifyAbbaMini);

var _vendorMoatInit = require('./vendor-moat-init');

var _vendorMoatInit2 = _interopRequireDefault(_vendorMoatInit);

var _vastEvents = require('../vast-events');

var _vastEvents2 = _interopRequireDefault(_vastEvents);

var _adEventLogger = require('../ad-event-logger');

var _adEventLogger2 = _interopRequireDefault(_adEventLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:moat');

var PARTNER_CODE = 'spotifynativeapp525794473702';

var moatLogger = {};

// maps various events to VPAID events
var events = {};
events[_vastEvents2.default.EVENTS.STARTED] = 'AdVideoStart';
events[_vastEvents2.default.EVENTS.FIRST_QUARTILE] = 'AdVideoFirstQuartile';
events[_vastEvents2.default.EVENTS.MIDPOINT] = 'AdVideoMidpoint';
events[_vastEvents2.default.EVENTS.THIRD_QUARTILE] = 'AdVideoThirdQuartile';
events[_vastEvents2.default.EVENTS.PAUSED] = 'AdPaused';
events[_vastEvents2.default.EVENTS.RESUMED] = 'AdPlaying';
events[_vastEvents2.default.EVENTS.ENDED] = 'AdVideoComplete';
events.stopped = 'AdStopped';
events.volumechange = 'AdVolumeChange';

moatLogger.EVENTS = events;

var abbaFlag = new Promise(function (resolve, reject) {
  (0, _spotifyAbbaMini2.default)('ads_desktop_moat_analytics', function (err, cell) {
    if (err) reject(err);
    if (cell === 'Enabled') resolve();
  });
});

/**
 * Wrapper around vendor code
 * @param {HTMLElement} container
 * @param {HTMLVideoElement} videoNode
 * @param {Object} ids
 * @return {Object} logMoatEvent
 */
moatLogger.create = function (opts) {
  var container = opts.container;
  var ids = opts.ids;
  var videoNode = opts.videoNode;

  var getMoat = new Promise(function (resolve) {
    if (videoNode.readyState >= videoNode.HAVE_METADATA) {
      resolveMoat();
      return;
    }

    videoNode.addEventListener('loadedmetadata', function onMetaData() {
      videoNode.removeEventListener('loadedmetadata', onMetaData);
      resolveMoat();
    });

    function resolveMoat() {
      var moat = (0, _vendorMoatInit2.default)(container, ids, videoNode.duration, PARTNER_CODE);

      resolve(moat);
    }
  });

  return function logMoatEvent(eventType) {
    return abbaFlag.then(function () {
      return getMoat;
    }).then(function (moat) {
      var ev = {
        type: eventType,
        adVolume: videoNode.volume
      };

      debug(ev, ids);

      return moat.dispatchEvent(ev);
    }).catch(function (err) {
      debug(err);
      _adEventLogger2.default.logError('moat:log-moat-event', err.message);
    });
  };
};

exports.default = moatLogger;

},{"../../../spotify-abba-mini":63,"../ad-event-logger":87,"../vast-events":131,"./vendor-moat-init":126,"debug":369}],126:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Vendor code - don't alter
 */

/*eslint-disable */
function initMoatTracking(container, ids, duration, partnerCode, url) {
  var protocol = 'https:';
  var sub = protocol === 'https:' ? 'z' : 'js';
  var script = document.createElement("script");
  var events = [];

  var moatapi = {
    "adData": {
      "ids": ids,
      "duration": duration,
      "url": url
    },
    "dispatchEvent": function dispatchEvent(ev) {
      if (this.sendEvent) {
        if (events) {
          events.push(ev);
          ev = events;
          events = false;
        }
        this.sendEvent(ev);
      } else {
        events.push(ev);
      }
    }
  };

  var moatApiName = '_moatApi' + Math.floor(Math.random() * 100000000);

  window[moatApiName] = moatapi;

  script.type = 'text/javascript';
  container && container.insertBefore(script, container.childNodes[0] || null);
  script.src = protocol + '//' + sub + '.moatads.com/' + partnerCode + '/moatvideo.js#' + moatApiName;

  return moatapi;
}
exports.default = initMoatTracking;

},{}],127:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var PLATFORMS = {
  desktop: 'html5_desktop'
};

var session = {};

session.get = function () {
  var platform = PLATFORMS[window.__spotify.platform];
  var isPremium = window.__spotify.product_state.ads === '0';

  return {
    platform: platform,
    isPremium: isPremium
  };
};

exports.default = session;

},{}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _spotifyPreferences = require('../../spotify-preferences');

var _spotifyPreferences2 = _interopRequireDefault(_spotifyPreferences);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uiPref = new _spotifyPreferences2.default('ui');

var settings = {};

settings.getHidePref = function (device, isPremium) {
	return new Promise(function (res, rej) {
		if (!isPremium) {
			res(false);
		} else {
			switch (device) {
				case 'html5_desktop':
					res(getZeldaPref());
					break;
				case 'web':
					res(getWebPref());
					break;
				default:
					rej(new Error('[HPTO] No valid device detected'));
			}
		}
	});
};

function getZeldaPref() {
	return new Promise(function (res, rej) {
		uiPref.get('hide_hpto', function (err, isHidden) {
			if (err) return rej(err);

			res(isHidden);
		});
	});
}

function getWebPref() {
	return new Promise(function (res, rej) {
		var hideState = false;

		switch (window.parent.localStorage['ui.hide_hpto']) {
			case 'true':
				hideState = true;
				break;
			case 'false':
				hideState = false;
				break;
			case undefined:
				// Set default hide hpto preference
				window.parent.localStorage['ui.hide_hpto'] = false;
				hideState = false;
				break;
			default:
				rej(new Error('[HPTO] Invalid hide state'));
		}

		res(hideState);
	});
}

exports.default = settings;

},{"../../spotify-preferences":351}],129:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cosmosConnector = new _cosmosConnector2.default();

var targeter = {};

/**
 * Get user targeting from lasertag
 * @param {String} inventoryUnit
 * @return {Promise}
 */
targeter.getTargeting = function (inventoryUnit) {
	function parseTargetData(data) {
		var obj = {};

		obj.ppid = data.ppid || data.aduserid;
		obj.inventoryUnit = inventoryUnit;
		obj.targetingData = data;

		return obj;
	}

	return cosmosConnector.getTargeting().then(parseTargetData);
};

exports.default = targeter;

},{"./cosmos-connector":90}],130:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var utils = {
  /**
   * Checks if various connected word strings exist in an object
   *
   * @param {String} prop - space separated words to be connected
   * @param {Object} obj - object to check prop in
   * @return {String}
   */

  getProp: function getProp(prop, obj) {
    prop = prop.trim().toLowerCase();
    var snakeCase = prop.replace(/\s+/g, '-');

    var camelCase = prop.replace(/\s+([a-z])/g, function (str, char) {
      return char.toUpperCase();
    });

    var paramCase = prop.replace(/\s+/g, '_');

    return obj[snakeCase] || obj[camelCase] || obj[paramCase];
  },


  /**
   * Returns type part of a URI
   *
   * @api public
   * @param {String} uri
   * @return {String} type
   */

  getType: function getType(uri) {
    var parts = uri.split(':');
    var type = null;

    if (parts[1] !== 'user') {
      type = parts[1];
    } else if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
      type = 'playlist';
    }

    return type;
  },


  /**
   * Creates an HTML document from a
   * given HTML string
   *
   * @api public
   * @param {String} html
   */

  makeDocument: function makeDocument(html) {
    var doc = document.implementation.createHTMLDocument('');
    doc.documentElement.innerHTML = html;
    return doc;
  },
  appendTrackingPixel: function appendTrackingPixel(url, domEl) {
    var pixel = this.createTrackingPixel(url);
    domEl.appendChild(pixel);
  },


  /**
   * Creates a tracking pixel img
   *
   * @param {String} trackingUrl
   * @return {DOMElement} - img element
   */

  createTrackingPixel: function createTrackingPixel(trackingUrl) {
    var img = document.createElement('img');

    img.style.display = 'none';
    img.width = '1px';
    img.height = '1px';
    img.classList.add('pixel');

    // parse tracking url
    var dec = decodeURIComponent(trackingUrl.replace(/&amp;/g, '&'));
    img.src = decodeURIComponent(dec);

    return img;
  },


  /**
   * Creates an interactive iframe from given data
   * TODO: Deprecate after sandbox hpto rolls out 100%
   *
   * @api public
   * @param {String} html
   */

  createInteractiveIframe: function createInteractiveIframe(html) {
    var enc = encodeURIComponent(html);
    var iframe = document.createElement('iframe');
    iframe.className = 'ad-iframe';
    iframe.src = 'data:text/html;charset=utf-8,' + enc;
    iframe.srcdoc = html;
    iframe.scrolling = 'no';
    iframe.marginWidth = 0;
    iframe.marginHeight = 0;
    iframe.hspace = 0;
    iframe.vspace = 0;
    return iframe;
  },
  createSandboxedIframe: function createSandboxedIframe() {
    var iframe = document.createElement('iframe');
    var sandboxParams = ['allow-forms', 'allow-pointer-lock', 'allow-popups', 'allow-same-origin', 'allow-scripts'];

    iframe.sandbox = sandboxParams.join(' ');
    return iframe;
  },
  createSandboxedHptoIframe: function createSandboxedHptoIframe(url) {
    var iframe = this.createSandboxedIframe();
    iframe.className = 'ad-iframe';
    iframe.src = url;
    iframe.scrolling = 'no';
    iframe.marginWidth = 0;
    iframe.marginHeight = 0;
    iframe.hspace = 0;
    iframe.vspace = 0;
    return iframe;
  },


  /**
   * Sets data URL on a given element
   * from given data
   *
   * @api public
   * @param {Element} hptoElem
   * @param {Object} adData
   */
  setDataUrlOnElement: function setDataUrlOnElement(hptoElem, adData) {
    var bgUrl = utils.getProp('background url', adData);
    if (bgUrl) {
      bgUrl = bgUrl.replace(/&amp;/g, '&');
      hptoElem.setAttribute('data-url', bgUrl);
    }
  },


  /**
   * Delete array of nodes
   * @param  {Array} nodes - array of nodes to be deleted
   * @return {void}
   */
  deleteNodes: function deleteNodes(nodes) {
    var i = void 0,
        len = void 0;

    if (nodes.length === 0) return;

    for (i = 0, len = nodes.length; i < len; i++) {
      var node = nodes[i];
      var parent = node.parentNode;

      parent.removeChild(node);
    }
  },


  /**
   * Parse spotify ad preview uri to get GID only
   * @param  {String} uri
   * @return {String}
   */
  parseGID: function parseGID(uri) {
    var parts = uri.split(':');
    if (parts.length >= 2 && parts[parts.length - 2] === 'ad') {
      return parts[parts.length - 1];
    }
  }
};

exports.default = utils;

},{}],131:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var STARTED = 'started';
var RESUMED = 'resumed';
var PAUSED = 'paused';
var MUTED = 'muted';
var UNMUTED = 'unmuted';
var FIRST_QUARTILE = 'first_quartile';
var MIDPOINT = 'midpoint';
var THIRD_QUARTILE = 'third_quartile';
var ENDED = 'ended';
var SKIPPED = 'skipped';

var VastEvents = {};

/**
 * @param {HTMLVideoElement} videoNode
 * @param {Function} callback
 */
VastEvents.subscribe = function (videoNode, callback) {
  var isStarted = false;
  var isEnded = false;
  var isMuted = videoNode.muted || videoNode.volume === 0;
  var emitFirstQuartile = (0, _once2.default)(emit.bind(null, FIRST_QUARTILE));
  var emitMidpoint = (0, _once2.default)(emit.bind(null, MIDPOINT));
  var emitThirdQuartile = (0, _once2.default)(emit.bind(null, THIRD_QUARTILE));
  var videoEvents = {};

  var unsubscribe = (0, _once2.default)(function () {
    isEnded = isEnded || videoNode.currentTime === videoNode.duration;
    removeListeners();
    emit(isEnded ? ENDED : SKIPPED);
  });

  function start() {
    isStarted = true;
    emit(STARTED);
  }

  function emit(eventName) {
    callback(eventName);
  }

  function addEventListener(name, listener) {
    videoEvents[name] = listener;
    videoNode.addEventListener(name, listener);
  }

  function removeListeners() {
    for (var x in videoEvents) {
      if (videoEvents.hasOwnProperty(x)) {
        videoNode.removeEventListener(x, videoEvents[x]);
      }
    }
  }

  if (!videoNode.paused) start();

  addEventListener('play', function () {
    if (!isStarted) {
      start();
      return;
    }

    emit(RESUMED);
  });

  addEventListener('pause', function (e) {
    // if paused on ended then do nothing
    if (e.target.currentTime === e.target.duration) return;
    emit(PAUSED);
  });

  addEventListener('ended', function () {
    isEnded = true;
    unsubscribe();
  });

  addEventListener('timeupdate', (0, _throttle2.default)(function (e) {
    var progress = e.target.currentTime / e.target.duration;
    if (progress >= 0.25) emitFirstQuartile();
    if (progress >= 0.50) emitMidpoint();
    if (progress >= 0.75) emitThirdQuartile();
  }, 500));

  addEventListener('volumechange', function (e) {
    var wasMuted = isMuted;
    isMuted = e.target.muted || e.target.volume === 0;
    if (wasMuted === isMuted) return;
    emit(isMuted ? MUTED : UNMUTED);
  });

  return unsubscribe;
};

VastEvents.EVENTS = {
  STARTED: STARTED,
  RESUMED: RESUMED,
  PAUSED: PAUSED,
  MUTED: MUTED,
  UNMUTED: UNMUTED,
  FIRST_QUARTILE: FIRST_QUARTILE,
  MIDPOINT: MIDPOINT,
  THIRD_QUARTILE: THIRD_QUARTILE,
  ENDED: ENDED,
  SKIPPED: SKIPPED
};

exports.default = VastEvents;

},{"lodash/once":456,"lodash/throttle":457}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var VIDEO_MAX_WIDTH = 1280;
exports.VIDEO_MAX_WIDTH = VIDEO_MAX_WIDTH;


var VIDEO_PROGRAMMATIC_WIDTHS = [1024, 800, 640];
exports.VIDEO_PROGRAMMATIC_WIDTHS = VIDEO_PROGRAMMATIC_WIDTHS;


var VIDEO_PREFERRED_WIDTHS = [VIDEO_MAX_WIDTH].concat(VIDEO_PROGRAMMATIC_WIDTHS);
exports.VIDEO_PREFERRED_WIDTHS = VIDEO_PREFERRED_WIDTHS;


var SUPPORTED_VIDEO_FORMATS = ['video/webm'];
exports.SUPPORTED_VIDEO_FORMATS = SUPPORTED_VIDEO_FORMATS;
exports.default = {

  /**
   * Return video metadata based on preferred formats/widths
   *
   * @param {Object[]} - array of video metadata
   * @param {String[]} - array of preferred video formats
   * @param {String[]} - array of preferred video sizes
   * @return {Object} - preferred video metadata
   */

  getPreferredVideoMetadata: function getPreferredVideoMetadata(videos) {
    var formats = arguments.length <= 1 || arguments[1] === undefined ? SUPPORTED_VIDEO_FORMATS : arguments[1];
    var widths = arguments.length <= 2 || arguments[2] === undefined ? VIDEO_PREFERRED_WIDTHS : arguments[2];

    var maxPreferredWidth = Math.max.apply(null, widths);

    // Filter out unsupported mimetypes
    var supportedMimeType = function supportedMimeType(video) {
      return formats.indexOf(video.mime_type) > -1;
    };

    // Filter out widths larger than largest preferred width
    var preferredWidth = function preferredWidth(video) {
      return video.width <= maxPreferredWidth;
    };

    // Sort in descending width
    var descWidth = function descWidth(v1, v2) {
      return v2.width - v1.width;
    };

    // Return video with largest preferred width
    return videos.filter(supportedMimeType).filter(preferredWidth).sort(descWidth).shift();
  }
};

},{}],133:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (typeof opts.uri !== 'string') throw new Error('Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error('Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error('If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error('Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

module.exports = cosmosRequest;

},{}],134:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  if (global && typeof global._getSpotifyModule === 'function') {
    global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
      name: name,
      args: args
    }), {
      onSuccess: getSuccessHandler(callback),
      onFailure: getFailureHandler(callback, name, args)
    });
  }
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":133,"debug":369,"spotify-deferred":558}],135:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var EVENTS = {
  // User (primary)
  USER_IMPRESSION: 'user:impression',
  USER_HIT: 'user:hit',
  // User (secondary - only use if neccesary)
  USER_SELECT: 'user:select',
  USER_HOVER: 'user:hover',
  USER_HOLD_TIMER: 'user:hold',

  // Info
  INFO_TIMER_DEFAULT: 'info:timer',
  INFO_STATE_LOAD_TIMER: 'info:state_load_timer',
  INFO_DEFAULT: 'info:default',
  INFO_WARN: 'info:warn',

  // Error
  ERROR_DEFAULT: 'error:default',
  ERROR_USER_ACTION_FAIL: 'error:user_action_fail',
  ERROR_RENDER_FAIL: 'error:render_fail'
};

var mixin = function mixin(base, addition) {
  var prop;
  for (prop in addition) {
    if (!base[prop]) {
      base[prop] = addition[prop];
    }
  }
};

/**
 * @class Logger Constructor
 * @param {Function} optBridgeRequest used mostly for testing
 */
function Logger() {
  this.timers = {};
}

/**
 * Filters out the data that should be specific fields in the schema
 * @param {object} obj - the mutated data obj
 * @param {object} extraData - the additional data in the log
 */
Logger.prototype._filterSchemaData = function (obj, extraData) {
  ClientEvent3.schema.fields.forEach(function (field) {
    if (extraData[field.name]) {
      obj[field.name] = extraData[field.name];
      delete extraData[field.name];
    }
  });
};

/**
 * Adds the remaining jsonData to the object
 * and overrides existing values
 * @param {object} obj - object that will be mutated
 * @param {object} jsonData
 */
Logger.prototype._addJsonData = function (obj, jsonData) {
  if (obj.json_data) {
    // Override the existing keys
    Object.keys(jsonData).forEach(function (key) {
      obj.json_data[key] = jsonData[key];
    });
  } else {
    obj.json_data = jsonData;
  }
};

/**
 * Builds ordered data array for backend consumption
 * @param {string} event Must be one of CLIENT_EVENT_NAMES or null.
 * @param {string|array} logData
 * @private
 * @return {array}
 */
Logger.prototype._buildBackendData = function (event, logData) {
  var data = {
    source_vendor: 'com.spotify',
    event: event
  };
  var extra;

  if (!logData.length) {
    throw new Error('Need some data to log!');
  }

  if (this.constant) {
    mixin(data, this.constant);
  }

  if (logData.length === 1) {
    if (typeof logData[0] === 'string') {
      data.event_version = logData[0];
      return data;
    } else if (_typeof(logData[0]) === 'object') {
      extra = logData[0];
    } else {
      throw new Error(event + ' must log either an object literal or a string');
    }
  } else {
    // support for the old logging style
    // might not even be needed -- should investigate
    data.event_version = logData[0];
    data.context = logData[2];
    extra = logData[1] || {};
  }

  this._filterSchemaData(data, extra);
  this._addJsonData(data, extra);
  if (data.json_data) data.json_data = JSON.stringify(data.json_data);

  return data;
};

/**
 * Internal log function: sends log to backend.
 * @param {array} backendData
 * @private
 */
Logger.prototype._log = function (backendData) {
  ClientEvent3.log(backendData);
};

// Public Methods

/**
 * All Log Methods
 *
 * @function
 * @param {...strings} optional number of arguments
 * @param {string|object} logData - can have the following key/values
 *        event_version, context, target_uri, name, section
 *        plus any number of optional key/values
 * Example: logger.userHit({
 *           event_version: 'play_button',
 *           context: 'recommended_stations',
 *           target_uri: 'spotify:genre:rock',
 *           name: 'Rock Genre Station'
 *           section: 'Carousel',
 *           customField: 'hello'
 *        });
 * @public
 */

Logger.prototype.userImpression = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_IMPRESSION, args));
};
Logger.prototype.userHit = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HIT, args));
};
Logger.prototype.userSelect = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_SELECT, args));
};
Logger.prototype.userHover = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HOVER, args));
};
Logger.prototype.userHold = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HOLD_TIMER, args));
};
Logger.prototype.info = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_DEFAULT, args));
};
Logger.prototype.infoWarn = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_WARN, args));
};
Logger.prototype.infoStageLoadTimer = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_STATE_LOAD_TIMER, args));
};
Logger.prototype.infoTimer = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_TIMER_DEFAULT, args));
};
Logger.prototype.error = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_DEFAULT, args));
};
Logger.prototype.errorUserActionFail = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_USER_ACTION_FAIL, args));
};
Logger.prototype.errorRenderFail = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_RENDER_FAIL, args));
};
Logger.prototype.createTimer = function (eventVersion, optKey) {
  var key = eventVersion + (optKey || '');

  this.timers[key] = {
    startTime: Date.now(),
    eventVersion: eventVersion
  };

  return key;
};
Logger.prototype.logTimer = function (key, optData) {
  var timer = this.timers[key];
  var data = optData ? optData : {};

  if (!timer) {
    throw new Error('LogTimer: No record of a timer with key: ' + key);
  }
  data.event_version = timer.eventVersion;
  data.duration = Date.now() - timer.startTime;

  this._log(this._buildBackendData(EVENTS.INFO_TIMER_DEFAULT, [data]));
};

/**
 * @function
 * @param (object) - constant
 * add some data to go into every log event e.g. { featureName: featureValue };
 */

Logger.prototype.setConstant = function (constant) {
  if ((typeof constant === 'undefined' ? 'undefined' : _typeof(constant)) !== 'object') return;
  this.constant = constant;
};
module.exports = Logger;

},{"../spotify-logger/messages/ClientEvent3":322}],136:[function(require,module,exports){
'use strict';

var parser = require('../spotify-live/util/parser');

var sortMap = {
  track: {
    _replace: '',
    artists: {
      _replace: 'artist'
    },
    disc: {
      _replace: 'discNumber'
    },
    number: {
      _replace: 'trackNumber'
    },
    duration: {
      _replace: 'length'
    }
  },
  timeSinceAdded: {
    _reverse: true,
    _replace: 'addTime'
  },
  addedBy: {
    _replace: '',
    name: {
      _replace: 'addedByDisplayName'
    }
  }
};

function reverse(direction) {
  return direction === 'ASC' ? 'DESC' : 'ASC';
}

function walk(query, mapping, opt_direction, incomingCollector) {
  var results = [];
  var collector = incomingCollector && incomingCollector.slice() || [];

  for (var item, i = 0; item = query.mask[i]; i++) {
    var itemCollector = collector.slice();

    if (item.key) {
      var hasReplace = mapping && mapping[item.key] && mapping[item.key]._replace != null;

      var value = hasReplace ? mapping[item.key]._replace : item.key;
      if (value !== '') {

        // Only add the direction if there's not another sub object
        if (!item.mask) {
          var doReverse = !!(mapping && mapping[item.key] && mapping[item.key]._reverse);
          if (opt_direction) {
            opt_direction = opt_direction.toUpperCase();
            var direction = doReverse ? reverse(opt_direction) : opt_direction;
            value += ' ' + direction;
          }
        }
        itemCollector.push(value);
      }
    }

    if (item.mask) {
      var subLookUp = walk(item, mapping[item.key], opt_direction, itemCollector);
      if (subLookUp.length) {
        results.push(subLookUp);
      }
    } else {
      if (itemCollector.length) {
        results.push(itemCollector.join('.'));
      }
    }
  }
  return results;
}

function getParams(query, opt_direction, opt_map) {
  var parsed = parser(query);
  if (!query) return null;

  var map = opt_map || sortMap;
  var result = walk(parsed, map, opt_direction);

  return result.join(',');
}

module.exports = getParams;

},{"../spotify-live/util/parser":315}],137:[function(require,module,exports){
(function (global){
'use strict';

var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');
var objectAssign = require('../../vendor/object-assign');

/**
 * See README.md for documentation on how to use.
 *
 * @param {Object} options Options for the logger.
 * @param {Logger} options.logger A Logger instance used for the logging. Must be provided and
 *     should have two methods: userSelect and userHit.
 */
function DomLogger(opt_options) {
  opt_options = opt_options || {};
  this.document = opt_options.document || document;
  this.appName = (global.__spotify && global.__spotify.app_uri && global.__spotify.app_uri.match(/^spotify:app:([^:]+)/) || [null, null])[1];
  if (this.appName === null) {
    console.warn('__spotify.app_uri is null. This is needed for proper logging via spotify-dom-logger.');
  }
  this.base_json_data = {};
};

DomLogger.GATHERED_ATTRIBUTES = ['data-log-click', 'data-log-context', 'data-log-data'];

/**
 * Initializes the DOM logger.
 * @public
 */
DomLogger.prototype.init = function () {
  this.document.addEventListener('click', this._handleClick.bind(this), true);
};

/**
 * Set Constant values in the json_data field.
 * @public
 * @param {Object} data - an object literal of data you want kept constant.
 */
DomLogger.prototype.setConstantData = function (data) {
  this.base_json_data = data;
};

/**
 * Actually calls the log method from ClientEvent3.
 * @private
 */
DomLogger.prototype._logData = function (event, context, eventVersion, data) {
  var jsonData = objectAssign({}, this.base_json_data, data);
  ClientEvent3.log({
    context: context,
    event: event,
    event_version: eventVersion,
    source: this.appName,
    source_vendor: 'com.spotify',
    json_data: JSON.stringify(jsonData)
  });
};

/**
 * Log a click on the specified event.
 * @param {Node} element DOM element.
 */
DomLogger.prototype.logClick = function (clickedElement) {
  // Go up the DOM tree until an element with the "data-log-click" attribute is found.
  var element = clickedElement;
  var identifier = 'unknown-element';

  var attrs = this._gatherAttributes(DomLogger.GATHERED_ATTRIBUTES, element);

  // Use the nearest data-log-click if one was found.
  if (attrs.values['data-log-click'].length) {
    element = attrs.nodes['data-log-click'].pop();
    identifier = attrs.values['data-log-click'].pop();
  }

  // Parse and merge all data-log-data JSON strings.
  var data = attrs.values['data-log-data'] ? this._mergeJSONStrings(attrs.values['data-log-data']) : {};

  // Optionally blank.
  var context = attrs.values['data-log-context'].join('/');

  if (element.getAttribute('data-log-click-as-select')) {
    this._logData('user:select', context, identifier, data);
  } else {
    this._logData('user:hit', context, identifier, data);
  }
};

/**
 * Handles a click in the document.
 * @param  {Object} event Event data.
 */
DomLogger.prototype._handleClick = function (event) {
  this.logClick(event.target);
};

/**
 * Give an array of strings, assume each is a JSON string representing an
 * object, parse each, and merge their properties (top level only).
 * @return {Object}
 */
DomLogger.prototype._mergeJSONStrings = function (datas) {
  try {
    datas = datas.map(function (item) {
      return JSON.parse(item);
    });
  } catch (e) {
    console.log('Failed to parse data-log-data (needs to be proper JSON):', datas);
    datas = [];
  }

  return datas.reduce(function (accum, cur) {
    Object.keys(cur).forEach(function (key) {
      accum[key] = cur[key];
    });
    return accum;
  }, {});
};

/**
 * Given an array of string attribute names, recursively traverse the DOM
 * upwards, collecting the attribute values and nodes containing those values.
 *
 * @example of returned object
 * {
 *   nodes: {
 *     'data-log-click': [Node, Node]
 *   },
 *   values: {
 *     'data-log-click': ['play-button', 'track-row']
 *   }
 * }
 */
DomLogger.prototype._gatherAttributes = function (attributes, element, opt_resultMap) {
  var resultMap = opt_resultMap || {
    nodes: {},
    values: {}
  };

  if (element.parentNode && element.parentNode.getAttribute) {
    this._gatherAttributes(attributes, element.parentNode, resultMap);
  }

  for (var i = 0; i < attributes.length; i++) {
    var name = attributes[i];
    var value = element.getAttribute(name);

    // Ensure name is present in map regardless of presence on a node.
    resultMap.values[name] = resultMap.values[name] || [];
    // Same for nodes map
    resultMap.nodes[name] = resultMap.nodes[name] || [];

    if (value) {
      resultMap.values[name].push(value);
      resultMap.nodes[name].push(element);
    }
  }

  return resultMap;
};

module.exports = DomLogger;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../vendor/object-assign":608,"../spotify-logger/messages/ClientEvent3":322}],138:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":139,"mout/array/filter":467,"mout/array/forEach":470,"mout/array/indexOf":471,"mout/string/trim":510}],139:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"mout/array/every":466,"mout/array/filter":467,"mout/array/forEach":470,"mout/array/map":473,"mout/array/some":476,"prime":515}],140:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"./events":141,"./traversal":144,"prime/map":516}],141:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"./base":139,"prime/emitter":514}],142:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":138,"./base":139,"./delegation":140,"./events":141,"./insertion":143,"./traversal":144}],143:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":139}],144:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":139,"mout/array/map":473,"slick":546}],145:[function(require,module,exports){
/*
zen
*/"use strict";

var forEach = require("mout/array/forEach"),
    map = require("mout/array/map");

var parse = require("slick/parser");

var $ = require("./base");

module.exports = function (expression, doc) {

    return $(map(parse(expression), function (expression) {

        var previous, result;

        forEach(expression, function (part, i) {

            var node = (doc || document).createElement(part.tag);

            if (part.id) node.id = part.id;

            if (part.classList) node.className = part.classList.join(" ");

            if (part.attributes) forEach(part.attributes, function (attribute) {
                node.setAttribute(attribute.name, attribute.value || "");
            });

            if (part.pseudos) forEach(part.pseudos, function (pseudo) {
                var n = $(node),
                    method = n[pseudo.name];
                if (method) method.call(n, pseudo.value);
            });

            if (i === 0) {

                result = node;
            } else if (part.combinator === " ") {

                previous.appendChild(node);
            } else if (part.combinator === "+") {
                var parentNode = previous.parentNode;
                if (parentNode) parentNode.appendChild(node);
            }

            previous = node;
        });

        return result;
    }));
};

},{"./base":139,"mout/array/forEach":470,"mout/array/map":473,"slick/parser":547}],146:[function(require,module,exports){
'use strict';

function EventDispatcher() {
  // In order to not have prototype nor constructor
  this._listeners = Object.create(null);
}

/**
 * Add an event listener.
 *
 * @param {String} type What type of event to listen to.
 * @param {Function} callback Callback function to execute when triggered.
 * @param {Number?} priority The priority(?).
 */
EventDispatcher.prototype.addEventListener = function (type, callback, priority) {
  if (!type || !callback) {
    throw new Error('Both event type and callback need to be defined');
  }

  priority = priority || 0;

  if (!this._listeners[type]) {
    this._listeners[type] = [];
  }

  var handlers = this._listeners[type];
  // Check if this callback is already registered
  if (handlers.every(function (h) {
    return h.callback !== callback;
  })) {
    var newHandler = {
      callback: callback,
      priority: priority
    };

    // Insert the handler in the right position
    var pos = 0;
    while (pos < handlers.length && handlers[pos].priority > newHandler.priority) {
      pos++;
    }
    handlers.splice(pos, 0, newHandler);
  }
};

/**
 * Remove an event listener.
 *
 * @param {String} type What type of event to stop listening to.
 * @param {Function} listener The listener to remove.
 */
EventDispatcher.prototype.removeEventListener = function (type, listener) {
  var handlers = this._listeners[type] || [];
  for (var i = 0; i < handlers.length; i++) {
    if (handlers[i].callback === listener) {
      handlers.splice(i, 1);
      return;
    }
  }
};

/**
 * Dispatch an event
 *
 * @param {Object} event The event to dispatch.
 */
EventDispatcher.prototype.dispatchEvent = function (event) {
  // Iterate on a copy of the array since an event callback might
  // unbind its listener, which would mutate the listeners array and make
  // the for loop act up.
  var handlers = this._listeners[event.type] ? this._listeners[event.type].slice() : [];
  for (var i = 0, len = handlers.length; i < len; i++) {
    var evt = handlers[i];
    evt.callback(event);
  }
};

EventDispatcher.prototype.reset = function () {
  this._listeners = Object.create(null);
};

module.exports = new EventDispatcher();

},{}],147:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var forIn = require('mout/object/forIn');
var live = require('../spotify-live');
var center = require('./center');

var IS_ADDED_PROPERTY = 'added';
var FOLLOWERSCOUNT_PROPERTY = 'followersCount';
var FOLLOWINGCOUNT_PROPERTY = 'followingCount';
var BUTTON_SELECTOR = '[data-button=add]';
var JUSTCHANGED_CLASSNAME = 'just-changed';
var ADDED_CLASSNAME = 'added';

var dataPropertiesForAdd = [IS_ADDED_PROPERTY, FOLLOWERSCOUNT_PROPERTY, FOLLOWINGCOUNT_PROPERTY];

var changeHandlers = {};

function getAddedClass(node) {
  var addedClassNode = node[0].closest('data-class-added');
  return addedClassNode ? addedClassNode.getAttribute('data-class-added') : ADDED_CLASSNAME;
}

function getURIFromNode(node) {
  var stateNode = node[0].closest('[data-uri]');
  if (!stateNode) {
    return null;
  }
  return stateNode.getAttribute('data-uri');
}

var eventHandlers = {

  click: function click(event, node) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var uri = stateNode.data('uri');
    if (!uri) return;

    var addedClass = getAddedClass(node);
    var shouldBeAdded = !stateNode.hasClass(addedClass);
    var data = {
      added: shouldBeAdded
    };

    node.addClass(JUSTCHANGED_CLASSNAME);

    // using capture=true to handle buttons with inner divs (used for changing button text)
    node.on('mouseout', function mouseoutHandler(event) {
      if (event.target !== node[0]) return;
      node.off('mouseout', mouseoutHandler);
      node.removeClass(JUSTCHANGED_CLASSNAME);
    }, true);

    // Publish will trigger the update event, which will then update the UI
    live(uri).publish(data);
  },

  changeHandler: function changeHandler(key, value, uri) {
    if (key === IS_ADDED_PROPERTY) {
      var numAffectedButtons = actions.setStateForURI(uri, value);
      if (numAffectedButtons === 0) {
        live(uri).off('update', changeHandlers[uri]);
        delete changeHandlers[uri];
      }
    }

    if (dataPropertiesForAdd.indexOf(key) > -1) {
      center.emit('add-data-change', { uri: uri, model: live(uri), key: key, value: value });
    }
  }

};

var actions = {

  setStateForURI: function setStateForURI(uri, isAdded) {
    var numAffectedButtons = 0;

    var nodes = $(document).search(BUTTON_SELECTOR);
    if (!nodes) return numAffectedButtons;

    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = $(nodes[i]);
      var buttonURI = getURIFromNode(node);
      if (uri === buttonURI) {
        numAffectedButtons++;
        actions.setStateForButtonNode(node, isAdded);
      }
    }

    return numAffectedButtons;
  },

  setStateForButtonNode: function setStateForButtonNode(node, isAdded) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var addedClass = getAddedClass(node);
    actions.setVisualState(isAdded, stateNode, node, addedClass);
  },

  setVisualState: function setVisualState(isAdded, node, button, className) {
    if (isAdded) {
      if (!node.hasClass(className)) node.addClass(className);
      var tooltipRemove = button.data('tooltip-remove');
      if (tooltipRemove) {
        button.setAttribute('data-tooltip', tooltipRemove);
        button.setAttribute('aria-label', tooltipRemove);
      }
      button.setAttribute('data-log-click', 'remove-button');
    } else {
      if (node.hasClass(className)) node.removeClass(className);
      var tooltipAdd = button.data('tooltip-add');
      if (tooltipAdd) {
        button.setAttribute('data-tooltip', tooltipAdd);
        button.setAttribute('aria-label', tooltipAdd);
      }
      button.setAttribute('data-log-click', 'add-button');
    }
  },

  addListenerForNode: function addListenerForNode(node) {
    var uri = getURIFromNode(node);

    // If we have already added a change handler for this URI,
    // we don't want to add another one, so we cancel early.
    // Before cancelling though, we should update button states
    // with the current state from the live model, since there
    // might be new buttons in the DOM.
    if (changeHandlers[uri]) {
      live(uri).get('added', function (error, isAdded) {
        if (error) throw error;
        actions.setStateForButtonNode(node, isAdded);
      });
      return;
    }

    changeHandlers[uri] = function (properties) {
      for (var key in properties) {
        var value = properties[key];
        eventHandlers.changeHandler(key, value, uri);
      };
    };

    var model = live(uri);

    // Get the initial state and update the button
    model.get('added', function (error, isAdded) {
      if (error) throw error;
      actions.setStateForButtonNode(node, isAdded);

      // When the initial state is known, we listen for updates
      // so we can update all buttons for this URI later.
      model.on('update', changeHandlers[uri]);
    });
  }

};

var handleScrollShow = function handleScrollShow(data) {
  update(data.pageNode, data.nodes);
};

// Export for testing
exports._classNames = {
  ADDED: ADDED_CLASSNAME,
  JUSTCHANGED: JUSTCHANGED_CLASSNAME
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', BUTTON_SELECTOR, eventHandlers.click);

  center.on('scroll-show-before', handleScrollShow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', BUTTON_SELECTOR, eventHandlers.click);
  center.off('scroll-show-before', handleScrollShow);
};

var update = exports.update = function update(node, nodes) {
  if (!isAttached) return;

  // If the node passed in is a button node, just add listeners for that
  if (node && $(node).matches(BUTTON_SELECTOR)) {
    actions.addListenerForNode($(node));

    // Otherwise search all the children of the node (or the document
    // if node is not provided) for buttons.
  } else {

    var nodes = ($(nodes) || $(node) || $(document)).search(BUTTON_SELECTOR);
    if (!nodes) return;

    for (var i = 0, l = nodes.length; i < l; i++) {
      actions.addListenerForNode($(nodes[i]));
    }
  }
};

},{"../spotify-elements":142,"../spotify-live":312,"./center":150,"mout/object/forIn":499}],148:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var Navigator = require('../spotify-navigation/navigator');
var AppState = require('../spotify-navigation/app-state');

var SELECTOR = 'a';

var nav = new Navigator();

var handleAnchorClick = function handleAnchorClick(event, node) {
  var anchor = node[0];
  var href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }

  event.preventDefault();

  var state = new AppState(href);

  nav.requestOpenState(state);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../spotify-elements":142,"../spotify-navigation/app-state":331,"../spotify-navigation/navigator":333}],149:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var doc = $(document);
var win = $(window);

// Decides how many pixels allowed between two touchmoves to determine if it is a swipe
var SWIPE_SENSITIVITY = 1;
// Constant that sets the amount of pixels allowed to move without locking the horizontal scroll
var SCROLL_LOCK_LIMIT = 10;
// The divider used to calculate the swipe speed. A larger number will make a slower swipe
var SWIPE_LAG = 14;

var handleClickLeft = function handleClickLeft(event, node) {
  handleButtonClick(node, true);
};

var handleClickRight = function handleClickRight(event, node) {
  handleButtonClick(node, false);
};

var getCarouselInner = function getCarouselInner(node) {
  return node.search('[data-carousel-inner]');
};

var getCarouselObjectsWidth = function getCarouselObjectsWidth(carouselInner) {
  var mediaObjects = $(carouselInner).search('.media-object');
  if (!mediaObjects) {
    return;
  }
  var mediaObjectWidth = parseFloat(global.getComputedStyle(mediaObjects[0]).width);
  var carouselInnerWidth = parseFloat(global.getComputedStyle(carouselInner).width);
  var carouselTotalWidth = carouselInner.scrollWidth;

  return {
    mediaObjectWidth: mediaObjectWidth,
    carouselInnerWidth: carouselInnerWidth,
    carouselTotalWidth: carouselTotalWidth
  };
};

var calculateMinLeftPixels = function calculateMinLeftPixels(carouselInner) {
  var minLeft = 0;
  // Determine number of pages based on numbers per page and total number of objects
  var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
  var objectsPerPage = Math.round(carouselObjectsWidth.carouselInnerWidth / carouselObjectsWidth.mediaObjectWidth);
  var totalNrOfObjects = Math.round(carouselObjectsWidth.carouselTotalWidth / carouselObjectsWidth.mediaObjectWidth);
  var nrOfPages = Math.ceil(totalNrOfObjects / objectsPerPage);
  minLeft = -(carouselObjectsWidth.carouselInnerWidth * (nrOfPages - 1));
  return minLeft;
};

var handleTouchStart = function handleTouchStart(event, node) {
  // Disable swiping the carousel if scrolling down/up the page
  var scrollBlocked = false;
  doc.on('scroll', handleScroll);
  function handleScroll(event) {
    if (!scrollBlocked) {
      doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
      doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    } else {
      event.preventDefault();
    }
  }

  // Get carousel element
  var carouselInner = getCarouselInner(node);
  if (!carouselInner) {
    return;
  }
  carouselInner = carouselInner[0];
  var startX;
  var previousX;
  var deltaX;
  // minLeft is always a negative number or 0. This is the minimum LEFT position of the carousel.
  var minLeft = calculateMinLeftPixels(carouselInner);
  if (minLeft === 0) {
    return;
  }
  doc.delegate('touchmove', '[data-carousel]', handleTouchMove);
  doc.delegate('touchend', '[data-carousel]', handleTouchEnd);

  // Get start coordinates
  if (event.touches) {
    startX = event.touches[0].pageX;
    previousX = startX;
  }

  function handleTouchMove(event) {
    if (!carouselInner) {
      return;
    }
    addDragTransition();

    if (event.touches) {
      var x = event.touches[0].pageX;
      deltaX = previousX - x;
      // Get position of carousel
      var positionLeft = carouselPosition(carouselInner);
      positionLeft = getPositionInPixels(positionLeft, carouselInner);
      // Set adjusted position
      var adjust = positionLeft - deltaX;
      // Check that carousel position doesn't exceed limits
      adjust = checkLimitsPixels(adjust, minLeft);
      carouselInner.style.left = adjust + 'px';
      previousX = x;

      if (deltaX > SCROLL_LOCK_LIMIT) {
        scrollBlocked = true;
      }
      if (scrollBlocked) {
        event.preventDefault();
      }
    }
  };

  function handleTouchEnd(event) {
    doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
    doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    doc.off('scroll', handleScroll);
    if (!carouselInner) {
      return;
    }
    // If considered as a swipe, swipe
    if (Math.abs(deltaX) > SWIPE_SENSITIVITY) {
      swipe(deltaX);
    }
    updateButtonsOnTouch(node);
  };

  /* Touch swipe functions */

  var swipe = function swipe(deltaX) {
    addSwipeTransition();
    // Get position of carousel
    var leftValue = carouselPosition(carouselInner);
    leftValue = getPositionInPixels(leftValue, carouselInner);

    var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
    // Get width of one mediaobject to us as an interval in the calculation for setting the swipe speed
    var mediaObjectWidth = parseInt(carouselObjectsWidth.mediaObjectWidth);
    if (!mediaObjectWidth) {
      return;
    }
    // Calculate position to swipe to based on value of deltaX (e.g. swipe acceleration) and SWIPE_LAG
    // SWIPE_LAG can be changed to a lower/higher value to increase/decrease speed.
    var adjust = leftValue + mediaObjectWidth * (-deltaX / SWIPE_LAG);
    // Check that carousel position doesn't exceed limits
    adjust = checkLimitsPixels(adjust, minLeft);
    carouselInner.style.left = adjust + 'px';
  };

  var updateButtonsOnTouch = function updateButtonsOnTouch(node) {
    var carouselId = node.data('carousel');
    var positionLeft = carouselPosition(carouselInner);
    positionLeft = getPositionInPixels(positionLeft, carouselInner);
    var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
    var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');

    if (Math.round(positionLeft) <= Math.round(minLeft)) {
      carouselRight.setAttribute('disabled', 'disabled');
    } else {
      carouselRight.removeAttribute('disabled');
    }

    if (positionLeft >= 0) {
      carouselLeft.setAttribute('disabled', 'disabled');
    } else {
      carouselLeft.removeAttribute('disabled');
    }
  };

  var addSwipeTransition = function addSwipeTransition() {
    if (!carouselInner) {
      return;
    }
    // Add swipe transition and remove drag + click transition
    $(carouselInner).addClass('crsl-inner-swipe').removeClass('crsl-inner-drag');
  };

  var addDragTransition = function addDragTransition() {
    if (!carouselInner) {
      return;
    }
    // Add drag transition and remove swipe + click transition
    $(carouselInner).addClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
  };
};

var resetTransitions = function resetTransitions(carouselInner) {
  if (!carouselInner) {
    return;
  }
  // Add click transition and remove drag + swipe transition
  $(carouselInner).removeClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
};

var checkLimitsPixels = function checkLimitsPixels(adjust, minLeft) {
  adjust = Math.min(adjust, 0);
  adjust = Math.max(adjust, minLeft);
  return adjust;
};

var carouselPosition = function carouselPosition(carouselInner) {
  return carouselInner.style.left || '0';
};

var getPositionInPixels = function getPositionInPixels(positionLeft, carouselInner) {
  var isInPx = positionLeft.endsWith('px');
  positionLeft = parseFloat(positionLeft);
  // If current unit isn't px, change to px
  if (!isInPx) {
    var currentPage = Math.abs(positionLeft / 100);
    // var carouselInnerWidth = carouselInner.clientWidth;
    var carouselInnerWidth = getCarouselObjectsWidth(carouselInner).carouselInnerWidth;
    positionLeft = -carouselInnerWidth * currentPage;
  }
  return positionLeft;
};

var getNextPageInPercent = function getNextPageInPercent(positionLeft, carouselInner, isLeft) {
  var carouselInnerWidth = carouselInner.clientWidth;
  var minLeft = calculateMinLeftPixels(carouselInner);
  var isInPercent = positionLeft.endsWith('%');
  positionLeft = parseInt(positionLeft);
  // If current unit isn't %, change to %
  var nextPage;
  if (!isInPercent) {
    nextPage = Math.abs(positionLeft / carouselInnerWidth);
    // If position is to the end left and button is right
    if (positionLeft === 0 && !isLeft) {
      nextPage = -100;
    }
    // If position is to the end right and button is left
    else if (positionLeft === minLeft && isLeft) {
        nextPage = (nextPage - 1) * -100;
      } else {
        nextPage = isLeft ? Math.floor(nextPage) : Math.ceil(nextPage);
        nextPage = nextPage * -100;
      }
  }
  // If current unit already is in percent
  else {
      nextPage = isLeft ? positionLeft + 100 : positionLeft - 100;
    }
  return nextPage;
};

var handleButtonClick = function handleButtonClick(buttonNode, isLeft) {
  if (buttonNode.hasAttribute('disabled')) {
    return;
  }
  var carouselId = buttonNode.data('carousel');
  var carouselInner = $('[data-carousel=' + carouselId + '][data-carousel-main] [data-carousel-inner]')[0];
  var positionLeft = carouselPosition(carouselInner);

  var adjust;
  if (positionLeft) {
    // Get next page in %
    var nextPage = getNextPageInPercent(positionLeft, carouselInner, isLeft);
    adjust = nextPage;
  } else {
    adjust = isLeft ? 0 : -100;
  }
  // Reset transitions
  resetTransitions(carouselInner);
  carouselInner.style.left = adjust + '%';
  updateButtonStates(carouselId);
};

var updateButtonStates = function updateButtonStates(carouselId) {
  var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
  var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');
  var carousel = $('[data-carousel=' + carouselId + '][data-carousel-main]');
  var carouselInner = $(carousel).search('[data-carousel-inner]')[0];
  var leftAdjust = carouselInner.style.left ? parseInt(carouselInner.style.left) : 0;

  if (leftAdjust >= 0) {
    carouselLeft.setAttribute('disabled', 'disabled');
  } else {
    carouselLeft.removeAttribute('disabled');
  }

  if (carouselInner.clientWidth - leftAdjust / 100 * carouselInner.clientWidth + 10 > carouselInner.scrollWidth) {
    carouselRight.setAttribute('disabled', 'disabled');
  } else {
    carouselRight.removeAttribute('disabled');
  }
};

var updateAllButtons = function updateAllButtons(node) {
  node = $(node) || doc;
  var carousels = node.search('[data-carousel-main]');
  if (carousels) {
    carousels.forEach(function (carousel) {
      updateButtonStates($(carousel).data('carousel'));
    });
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateAllButtons(node);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.delegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.delegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.on('resize', updateAllButtons);

  // Polyfill from: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.undelegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.undelegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.off('resize', updateAllButtons);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":142}],150:[function(require,module,exports){
/*
Event Center
*/'use strict';

var Emitter = require('prime/emitter');

module.exports = new Emitter();

},{"prime/emitter":514}],151:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var selection = require('./selection');
var wrappedUriUtils = require('../spotify-live-wrapped-uri');
var cosmos = require('./util/cosmos');

var CONTEXTMENU = ['a[data-uri]', '[data-contextmenu]'].join(',');

var makeContextMenuData = function makeContextMenuData(selectionContexts, primaryIndex, uris, x, y) {
  var contexts = [];
  for (var i = 0, selectionContext; selectionContext = selectionContexts[i]; i++) {
    var keys = selectionContext.keys || [];
    var indices = selectionContext.indices || [];
    primaryIndex = primaryIndex || indices[0];
    primaryIndex = primaryIndex == null ? null : primaryIndex;

    var contextUri = selectionContext.uri;
    var liveList = live(contextUri).get('rows');

    var contextData = {
      uri: contextUri,
      keys: keys,
      indices: indices,
      primaryIndex: primaryIndex
    };

    var origin = selectionContext.origin;
    if (origin) {
      if (primaryIndex != null) {
        var wrappedList = live(contextUri).get('rows');
        var originList = live(origin.uri).get('rows');
        if (wrappedList && originList) {
          var key = wrappedList.keys[primaryIndex];
          origin.primaryIndex = originList.indexOf(key);
        }
      }
      contextData.origin = origin;
    }
    contexts.push(contextData);
  }
  return {
    contexts: contexts,
    x: x,
    y: y,
    uris: uris
  };
};

var handleContextMenuEvent = function handleContextMenuEvent(event, node) {
  event.preventDefault();
  event.stopPropagation();

  var x = event.clientX,
      y = event.clientY;

  if (node[0].tagName.toLowerCase() === 'a') {
    var uri = node.data('uri');
    if (uri) {
      showContextMenu({ uris: [uri], x: x, y: y });
    }
  } else {
    var contextNode = node.parent('[data-list]');
    var contextURI;
    if (contextNode) contextURI = contextNode.data('uri');

    var index = +node.data('index');

    var isSelected = false;
    var omitContext = false;
    var indices = selection.getIndicesPerList();

    if (contextNode) {
      isSelected = selection.isNodeSelected(node);
      // If the selection is shared between different lists, don't pass a contextURI.
      omitContext = indices.length > 1;
    }
    var uris = isSelected ? selection.getUris() : [node.data('uri')];
    showContextMenu(makeContextMenuData(indices, index, uris, x, y));
  }
};

var handleContextMenuButton = function handleContextMenuButton(event, node) {
  var parent;
  var uri = node.data('uri') || (parent = node.parent('[data-uri]')) && parent.data('uri');
  if (!uri) return;

  // The context menu can't know what to offer for a custom list.
  // In case of a sorted and/or filtered list, pass the origin list.
  uri = wrappedUriUtils.getOriginUri(uri) || uri;

  var contextURI = (parent = node.parent('[data-list][data-uri]')) && parent.data('uri');
  var contextIndex = (parent = node.parent('[data-index]')) && +parent.data('index');

  var contextMenuNode = $(node[0].closest('[data-button="contextmenu"]'));
  var relativeTo = contextMenuNode || parent || node;

  var rect = relativeTo[0].getBoundingClientRect();
  var x = rect.left + rect.width / 2;
  var y = rect.top + rect.height;

  // The coordinate must be within the app viewport
  if (y > window.innerHeight) y = window.innerHeight - 1;
  if (x > window.innerWidth) x = window.innerWidth - 1;

  var indices = contextIndex == null ? null : [contextIndex];
  contextIndex = contextIndex == null ? null : contextIndex;

  var context;
  if (contextURI) {
    context = { uri: contextURI };

    if (indices) {
      context.indices = indices;

      var liveList = live(contextURI).get('rows');
      context.keys = liveList ? indices.map(function (selectedIndex) {
        return liveList.keys[selectedIndex];
      }) : [];
    }

    // Add originList
    var origin = wrappedUriUtils.getOriginUri(contextURI);
    if (origin) {
      context.origin = { uri: origin };

      if (indices) {
        var wrappedList = live(contextURI).get('rows');
        var originList = live(origin).get('rows');
        if (wrappedList && originList) {
          var originIndices = indices.map(function (index) {
            var key = wrappedList.keys[index];
            return originList.indexOf(key);
          });
          var originKeys = indices.map(function (index) {
            return wrappedList.keys[index];
          });
          context.origin.indices = originIndices;
          context.origin.keys = originKeys;
        }
      }
    }
  }
  showContextMenu(makeContextMenuData([context], contextIndex, [uri], x, y));
  contextMenuNode.addClass('contextmenu-active');

  var cancel = cosmos.subscribe({ url: 'sp://messages/v1/context_menu_state' }, function (error, response) {
    if (!error && response.body.state === 'hide') {
      contextMenuNode.removeClass('contextmenu-active');
      cancel();
    }
  });
};

var showContextMenu = function showContextMenu(data) {
  var application = live('spotify:application');
  application.query('appURI', function (error, application_data) {
    if (!error) {
      data.appURI = application_data.appURI;
    }
    var client = live('spotify:client');
    client.emit('show-context-menu', data);
  });
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).delegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).undelegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.update = function () {};

},{"../spotify-elements":142,"../spotify-live":312,"../spotify-live-wrapped-uri":311,"./selection":186,"./util/cosmos":200}],152:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/rootlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');

var liburi = require('spotify-liburi');
var live = require('../../../spotify-live');
var intersection = require('mout/array/intersection');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dragFolderElement = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragFolderElement = null;

  var uris = selection.getUris();
  if (uris.length > 1) return;

  var uri = uris[0];
  var uriObject = uri && liburi.fromString(uri);
  if (!uriObject) return;

  // If dragging a folder, we need to temporarily save the folder DOM node,
  // so that while dragging over items we can check whether to show the drop
  // indicator. Dropping a folder inside itself should not be allowed.
  if (uriObject.type === liburi.Type.FOLDER) {
    var selectedNodes = selection.getNodes();
    for (var i = 0, l = selectedNodes.length; i < l; i++) {
      var node = selectedNodes[i];
      if (node.getAttribute('data-uri') === uri) {
        dragFolderElement = node;
        break;
      }
    }
  }
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragFolderElement = null;
}

/**
 * Hook handler for setting drag data.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of URIs being dragged.
 * @param {string=} opt_context Optional context URI.
 */
function onSetDragData(event, uris, opt_context) {
  if (opt_context !== 'spotify:rootlist') {
    var followedPlaylistCount = 0;
    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        var isFollowing = live(uris[i]).get('added');
        if (isFollowing) followedPlaylistCount++;
      } else {
        // If the item is not a playlist, it means we are dragging either only
        // items of another type, or playlists as well as other types.
        break;
      }
    }

    // Dropping only playlists that you are following in the rootlist should
    // not be allowed. If multiple playlists are dragged and some of them are
    // not being followed, dropping is allowed (and the receiver should handle
    // only inserting the new ones). To allow telling these cases apart while
    // not having access to drag data, we set a special MIME type that can be
    // checked later.
    if (followedPlaylistCount === uris.length) {
      event.dataTransfer.setData('text/x-spotify-only-followed-playlists', '');
    }
  }
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (contextUri === 'spotify:rootlist') {

    // Dropping only already followed playlists into the rootlist should not
    // be allowed, since you can only have playlists once in the rootlist.
    if (hasOnlyFollowedPlaylists(event)) {
      result.valid = false;
      return;
    }

    // Dropping a folder inside or right below itself should not be allowed
    if (isInsideDraggedFolder(event, location)) {
      result.valid = false;
      return;
    }

    // Dropping on the bottom half of a folder should not be allowed as a list
    // target, but will be a regular target for the folder instead. However, if
    // the dragged items match the list target, dropping should be handled by
    // list code instead of target code (dragover should still not validate as
    // we want the active drop target style and not the list indicator).
    if (isInFolderBottomHalf(event)) {
      if (event.type !== 'drop' || !isMatchingTarget(event, list)) {
        result.valid = false;
        return;
      }
    }
  }
}

/**
 * Hook handler for validating a target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM node for target that matches MIME types.
 */
function onTargetValidation(result, event, target) {
  var list = target.closest(SELECTOR_LIST);
  if (list) {
    var contextUri = list.getAttribute('data-uri');
    if (contextUri === 'spotify:rootlist') {

      // Dropping only already followed playlists into the rootlist should not
      // be allowed, since you can only have playlists once in the rootlist.
      if (hasOnlyFollowedPlaylists(event)) {
        result.valid = false;
        return;
      }

      // Dropping valid rootlist items on the top half of a folder should not
      // be allowed as a regular target, but will be a list drop target instead.
      // For leave events, we need to validate the whole row as valid, so that
      // the target styling is removed correctly.
      if (event.type !== 'dragleave' && isMatchingTarget(event, list)) {
        var folderNode = getFolderNode(event);
        if (folderNode) {
          if (isBelowMiddleOfNode(event.clientY, folderNode)) {
            result.valid = true;
          } else {
            result.valid = false;
          }
          return;
        }
      }
    }
  }
}

/**
 * Hook handler for getting the indices being moved.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList Live list to be changed.
 * @param {Array.<number>} indices Array of indices in the list.
 */
function onGetMoveIndices(contextUri, liveList, indices) {
  if (contextUri === 'spotify:rootlist') {
    var firstIndex = indices[0];
    var firstRow = liveList.get(firstIndex);
    var firstItem = firstRow && firstRow.get('playlist');
    var firstUri = firstItem && firstItem.uri;
    var firstUriType = firstUri && liburi.fromString(firstUri).type;
    var isFolder = firstUriType === liburi.Type.FOLDER;

    if (isFolder) {

      // Add all indices for the folder contents and the end marker
      if (indices.length === 1) {
        var length = getFolderLength(liveList, firstUri, firstIndex);
        for (var i = 1; i <= length; i++) {
          indices.push(firstIndex + i);
        }
      }

      // Abort the move operation if it only contains moving a folder start
      // marker, since moving folders should always move the entire folder.
      // Aborting by returning zero indices.
      if (indices.length === 1) {
        indices.length = 0;
        return;
      }

      var lastRow = liveList.get(indices[indices.length - 1]);
      var lastItem = lastRow && lastRow.get('playlist');
      var lastUri = lastItem && lastItem.uri;

      // Abort the move operation if moving a folder and the last item to move
      // is not the end marker for the folder. Aborting by returning zero
      // indices.
      if (lastUri !== firstUri + ':end') {
        indices.length = 0;
        return;
      }
    }
  }
}

/**
 * Check if only dragging playlists that are being followed already.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if only followed playlists are being dragged.
 */
function hasOnlyFollowedPlaylists(event) {
  var types = event.dataTransfer.types;
  if (types.indexOf('text/x-spotify-only-followed-playlists') > -1) {
    return true;
  }

  return false;
}

/**
 * Check if dragging a folder into (or below) itself.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if dragging into the same folder being dragged.
 */
function isInsideDraggedFolder(event, location) {
  if (dragFolderElement) {
    var rowNode = location === 'below' ? getLastRowNode() : getRowNode(event);
    if (rowNode) {
      var targetIndex = +rowNode.getAttribute('data-index');
      if (location === 'inside') {
        if (!isBelowMiddleOfNode(event.clientY, rowNode)) {
          targetIndex--;
        }
      }
      if (isIndexInsideDraggedFolder(targetIndex)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if dragging onto the bottom half of a folder.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if dragging onto the bottom half.
 */
function isInFolderBottomHalf(event) {
  var folderNode = getFolderNode(event);
  if (folderNode) {
    return isBelowMiddleOfNode(event.clientY, folderNode);
  }
  return false;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the index is inside (or right below) the folder being dragged.
 *
 * @param {number} index Current target index.
 *
 * @return {boolean} True if the target index is inside the folder.
 */
function isIndexInsideDraggedFolder(index) {
  if (!dragFolderElement) return false;

  var liveList = live('spotify:rootlist').get('rows');
  if (!liveList) return false;

  var folderUri = dragFolderElement.getAttribute('data-uri');
  if (!folderUri) return false;

  var start = +dragFolderElement.getAttribute('data-index');
  var end = start + getFolderLength(liveList, folderUri, start);

  if (start > -1 && end > start && index >= start && index <= end) {
    return true;
  }

  return false;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Get the folder row node from the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} DOM node for the folder, or null if not found.
 */
function getFolderNode(event) {
  var rowNode = getRowNode(event);
  if (rowNode) {
    var uri = rowNode.getAttribute('data-uri');
    var uriObject = liburi.from(uri);
    if (uriObject && uriObject.type === liburi.Type.FOLDER) {
      return rowNode;
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the length of a folder, including the contents and end marker, but not
 * the start marker.
 *
 * @param {LiveList} liveList Live list for the rootlist.
 * @param {string} folderUri The folder URI.
 * @param {number} index The index where the folder start marker is.
 *
 * @return {number} The length of the folder.
 */
function getFolderLength(liveList, folderUri, index) {
  var rowAtIndex = liveList.get(index);
  var itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
  var uriAtIndex = itemAtIndex && itemAtIndex.uri;
  if (uriAtIndex !== folderUri) return 0;

  var folderEndUri = folderUri + ':end';
  var amount = 0;

  for (var i = index + 1, l = liveList.length; i < l; i++) {
    amount++;

    rowAtIndex = liveList.get(i);
    itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
    uriAtIndex = itemAtIndex && itemAtIndex.uri;
    if (uriAtIndex === folderEndUri) break;
  }

  return amount;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('set-drag-data', onSetDragData);
  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('target-validation', onTargetValidation);
  hooks.add('get-move-indices', onGetMoveIndices);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('set-drag-data', onSetDragData);
  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('target-validation', onTargetValidation);
  hooks.remove('get-move-indices', onGetMoveIndices);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":142,"../../../spotify-live":312,"../../selection":186,"../util/eventmodel":159,"../util/hooks":160,"mout/array/intersection":472,"spotify-liburi":563}],153:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/sortlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');
var liburi = require('spotify-liburi');
var sortUriUtils = require('../../../spotify-live-sort-uri');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var SELECTOR_LIST = '[data-list]';

var dragSelectionState = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragSelectionState = selection.getIndicesPerList();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragSelectionState = null;
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Dropping in sorted lists should not allow specific drop positions,
  if (sortUriUtils.isValid(contextUri) && event.type !== 'drop') {
    result.valid = false;
  }
}

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListTargetValidation(result, list) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Bail on all invalid uris
  if (!sortUriUtils.isValid(contextUri)) return;

  // We should support incoming drag and drops as well, like from the
  // now playing view for example
  if (!dragSelectionState) {
    result.valid = true;
    return;
  }

  // Dropping in sorted lists should be allowed as a regular target
  if (dragSelectionState.length === 1) {
    if (dragSelectionState[0].uri !== contextUri) {
      result.valid = true;
    }
  }
}

/**
 * Hook handler for checking if a list is a track list.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect the result.
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI.
 */
function onIsListOfTracks(result, liveList, contextUri) {
  if (sortUriUtils.isValid(contextUri)) {
    var originUri = sortUriUtils.getOriginUri(contextUri);
    if (originUri) {
      var uriObject = liburi.from(originUri);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        result.valid = true;
      }
    }
  }
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('list-target-validation', onListTargetValidation);
  hooks.add('is-list-of-tracks', onIsListOfTracks);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('list-target-validation', onListTargetValidation);
  hooks.remove('is-list-of-tracks', onIsListOfTracks);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":142,"../../../spotify-live-sort-uri":310,"../../selection":186,"../util/eventmodel":159,"../util/hooks":160,"spotify-liburi":563}],154:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/dragdata
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var forOwn = require('mout/object/forOwn');

var selection = require('../selection');
var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');
var getLogContext = require('../util/get-log-context');

var SELECTOR_DRAGGABLE = 'a, [draggable]';

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length > 0) {
      var state = selection.getIndicesPerList();
      var singleContext = state.length === 1;
      var context = singleContext ? state[0] && state[0].uri : null;
      if (context) {
        setEventData(event, uris, null, context, getLogContext(target));
      } else {
        setEventData(event, uris, null, null, getLogContext(target));
      }
    }
  } else {
    var uri = target.getAttribute('data-uri');
    if (!uri) {
      var uriObject = liburi.from(target.getAttribute('href'));
      uri = uriObject ? uriObject.toURI() : '';
    }
    var dragText = itemText.getForElement(target);

    if (uri) {
      setEventData(event, [uri], [dragText], null, getLogContext(target));
    }
  }
}

/**
 * Set drag data on the event.
 * This includes regular MIME types such as plain text and html, but also custom
 * Spotify MIME types that can be used to detect the dragged content while
 * dragging (you can't access data while dragging, so there is no other way
 * to detect what kind of items are being dragged).
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 * @param {string=} opt_context Optional context URI.
 * @param {string=} opt_logContext Optional log context.
 */
function setEventData(event, uris, opt_dragTexts, opt_context, opt_logContext) {
  var urlsPerMimeType = getUrlsPerMimeType(uris);
  var urls = getUrlsForUris(uris);
  var urlList = urls.join('\n');
  var html = getLinkHTML(uris, urls, opt_dragTexts);

  // We set this before others because safari overrides any data that was set
  // before this particular mimetype was set.
  event.dataTransfer.setData('text/uri-list', urlList);

  for (var type in urlsPerMimeType) {
    var urlsForType = urlsPerMimeType[type];
    event.dataTransfer.setData(type, urlsForType.join('\n'));
  };

  event.dataTransfer.setData('text/plain', urlList);
  event.dataTransfer.setData('text/html', html);

  if (opt_context) {

    // Provide the context as drag data. This can be used in the drop event to
    // know where it came from.
    event.dataTransfer.setData('text/x-spotify-data-context', opt_context);
  }

  if (opt_logContext) {
    event.dataTransfer.setData('text/x-spotify-data-log-context', opt_logContext);
  }

  event.dataTransfer.setData('text/x-spotify-data-app-uri', global.__spotify && global.__spotify.app_uri || null);

  hooks.run('set-drag-data', event, uris, opt_context);
}

/**
 * Get URLs for the URIs organized by MIME type.
 *
 * @param  {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Object.<string, Array.<string>>} Object of arrays of URLs.
 */
function getUrlsPerMimeType(uris) {
  var urlsPerMimeType = {};
  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    var type = getMimeType(uri);
    var urlsForType = urlsPerMimeType[type] || (urlsPerMimeType[type] = []);
    urlsForType.push(getShareLink(uri));
  }
  return urlsPerMimeType;
}

/**
 * Get URLs for the URIs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Array.<string>} Array of share URLs.
 */
function getUrlsForUris(uris) {
  var urls = new Array(uris.length);
  for (var i = 0, l = uris.length; i < l; i++) {
    urls[i] = getShareLink(uris[i]);
  }
  return urls;
}

/**
 * Get a share URL from a Spotify URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The share URL.
 */
function getShareLink(uri) {
  var uriObject = liburi.from(uri);
  return uriObject ? uriObject.toOpenURL() : uri;
}

/**
 * Get the custom Spotify MIME type for a URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The MIME type.
 */
function getMimeType(uri) {
  var type = 'text/x-spotify-';

  var uriObject = liburi.from(uri);
  if (uriObject) {
    var uriType = uriObject.type;

    if (uriType === liburi.Type.TRACK || uriType === liburi.Type.LOCAL) {
      return type + 'tracks';
    }
    if (uriType === liburi.Type.ALBUM || uriType === liburi.Type.LOCAL_ALBUM) {
      return type + 'albums';
    }
    if (uriType === liburi.Type.ARTIST || uriType === liburi.Type.LOCAL_ARTIST) {
      return type + 'artists';
    }
    if (uriType === liburi.Type.USER || uriType === liburi.Type.PROFILE) {
      return type + 'users';
    }
    if (uriType === liburi.Type.PLAYLIST) {
      return type + 'playlists';
    }
    if (uriType === liburi.Type.FOLDER) {
      return type + 'folders';
    }
    if (uriType === liburi.Type.STATION) {
      return type + 'stations';
    }
  }

  return type + 'unknown';
}

/**
 * Get the HTML for links to the given URLs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>} urls Array of Spotify URLs used for sharing.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 *
 * @return {string} String of HTML.
 */
function getLinkHTML(uris, urls, opt_dragTexts) {
  var html = '';

  for (var i = 0, l = uris.length; i < l; i++) {
    var textFromArgs = opt_dragTexts && opt_dragTexts[i];
    var text = textFromArgs || itemText.getForUri(uris[i]);

    html += '<a href="' + urls[i] + '">' + text + '</a>';

    if (i < uris.length - 1) {
      html += '<br>';
    }
  }

  return html;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../selection":186,"../util/get-log-context":202,"./util/eventmodel":159,"./util/hooks":160,"./util/itemtext":161,"mout/object/forOwn":500,"spotify-liburi":563}],155:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/dragimage
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var selection = require('../selection');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');

// TODO: Actually load localized strings.
// Problem now is that we need quickstart-spotify to load @loc paths, and that
// makes it harder to run unit tests.
var localizedStrings = require('../strings/en.json');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var DRAGIMAGE_POS_X = -10;
var DRAGIMAGE_POS_Y = -5;

var dragImageElement = null;
var dragImageShelter = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  var text = '';

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length === 1) {
      text = itemText.getForUri(uris[0]);
    } else {
      text = uris.length + ' ' + getLocalizedTypeFromUris(uris);
    }
  } else {
    text = itemText.getForElement(target);
  }

  var dragImage = getDragImage(text);

  event.dataTransfer.setDragImage(dragImage, DRAGIMAGE_POS_X, DRAGIMAGE_POS_Y);

  removeDragImage();
}

/**
 * Get the drag image element with the specified text set.
 *
 * @param {string} text The text to set.
 *
 * @return {HTMLElement} The drag image element.
 */
function getDragImage(text) {
  if (!dragImageElement) {
    dragImageElement = document.createElement('div');
    dragImageElement.className = 'dnd-image';
  }
  if (!dragImageShelter) {
    dragImageShelter = document.createElement('div');
    dragImageShelter.className = 'dnd-image-shelter';
  }

  dragImageElement.textContent = text;

  document.body.appendChild(dragImageElement);
  document.body.appendChild(dragImageShelter);

  return dragImageElement;
}

/**
 * Remove the drag image element and the shelter it hides behind.
 * This must be delayed a tick to let the native drag and drop handling
 * get the time to read the image.
 */
function removeDragImage() {
  defer(function () {
    if (dragImageElement && dragImageElement.parentNode) {
      dragImageElement.parentNode.removeChild(dragImageElement);
    }
    if (dragImageShelter && dragImageShelter.parentNode) {
      dragImageShelter.parentNode.removeChild(dragImageShelter);
    }
  });
}

/**
 * Get a localized type for a list of URIs.
 * This could be for example 'tracks', 'playlists' etc. Falls back to 'items'
 * if the URIs are of different type. As this is only called when we drag
 * multiple items, we don't need the singular form.
 *
 * @param {Array.<string>} uris Array of URIs.
 *
 * @return {string} The localized type.
 */
function getLocalizedTypeFromUris(uris) {
  var type = 'item';

  var uriObjectForFirst = liburi.from(uris[0]);
  var typeForFirst = uriObjectForFirst && uriObjectForFirst.type;

  if (typeForFirst) {
    type = typeForFirst;

    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      if (!uriObject || uriObject.type !== typeForFirst) {
        type = 'item';
        break;
      }
    }
  }

  // User URIs are parsed with type 'profile' in liburi, but we want 'user'
  if (type === 'profile') {
    type = 'user';
  }

  var pluralType = type + 's';

  // Get the localized version of the plural type
  var localized = localizedStrings['drag_tooltip_many_' + pluralType];

  // If the type was not the generic 'items' type and no localization was found,
  // localize the generic type.
  if (!localized && pluralType !== 'items') {
    localized = localizedStrings['drag_tooltip_many_items'];
  }

  // Return the localized type, or if nothing is found, fall back to the type
  return localized || pluralType;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-live":312,"../selection":186,"../strings/en.json":193,"./util/eventmodel":159,"./util/itemtext":161,"prime/defer":513,"spotify-liburi":563}],156:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop
 */
'use strict';

var dragDataModule = require('./dragdata');
var dragImageModule = require('./dragimage');
var targetModule = require('./target');
var listModule = require('./list');

// Custom behaviors
var sortlistModule = require('./custom/sortlist');
var rootlistModule = require('./custom/rootlist');

/**
 * Attach the module.
 */
function attach() {
  dragDataModule.attach();
  dragImageModule.attach();
  targetModule.attach();
  listModule.attach();

  sortlistModule.attach();
  rootlistModule.attach();
}

/**
 * Detach the module.
 */
function detach() {
  dragDataModule.detach();
  dragImageModule.detach();
  targetModule.detach();
  listModule.detach();

  sortlistModule.detach();
  rootlistModule.detach();
}

exports.attach = attach;
exports.detach = detach;
exports.update = function () {};

},{"./custom/rootlist":152,"./custom/sortlist":153,"./dragdata":154,"./dragimage":155,"./list":157,"./target":158}],157:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/list
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var flow = require('finally');
var Range = require('../../spotify-range2');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var listOperations = require('spotify-live-list-operations');

var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var selection = require('../selection');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_LIST_TARGET = SELECTOR_DROP_TARGET + ', body';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dropIndicator = null;
var draggedLinkContext = null;
var disabledLists = {};

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  draggedLinkContext = null;

  // clear the selectionState cache
  cachedSelectionState.clear();

  var matchingTarget = getMatchingTarget(event);
  if (matchingTarget) {
    var isInList = $(matchingTarget).matches(SELECTOR_LIST);
    if (isInList) {
      var uri = matchingTarget.getAttribute('data-uri');

      // Dragging a link from inside a list needs to store the list context,
      // since it is not allowed to drop a dragged link inside the same list.
      if (target.tagName.toLowerCase() === 'a') {
        draggedLinkContext = uri;
      }

      // Dragging is disallowed for lists where we're waiting for a list move
      // to finish. This is to prevent multiple moves to be called before the
      // response from the first comes back.
      if (disabledLists[uri]) {
        event.preventDefault();
        return;
      }

      var rowNode = getRowNode(event);
      if (rowNode) {
        var index = getTargetIndex(event.clientY, rowNode);
        if (index !== -1) {
          event.dataTransfer.setData('text/x-spotify-data-log-source-index', index);
        }
      }
    }
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target. This can be the
 *     body element even if it's not a drop target.
 */
function onDragOver(event, target) {
  var positionedListDrop = false;
  var rowNode = null;

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  // If we found a list from the event, we must validate if it's allowed to drop
  // in the list.
  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      if (isBody) {
        positionedListDrop = true;
      } else {
        rowNode = getRowNode(event);
        if (rowNode) {
          positionedListDrop = true;
        }
      }
    }
  }

  if (positionedListDrop) {
    event.preventDefault();

    if (isBody) showDropIndicatorBelowList(list);else if (rowNode) showDropIndicatorForRow(rowNode, event.clientY);
  } else {
    hideDropIndicator();

    var listHookResult = { valid: false };
    if (list) {
      hooks.run('list-target-validation', listHookResult, list);
    }

    // The list might be accepted as a drop target even if dropping in a
    // specific position was not accepted. In that case we need to prevent the
    // default action to tell the browser that we accept drops here.
    if (listHookResult.valid) {
      event.preventDefault();
    } else if (!isBody && list) {
      var targetHookResult = { valid: false };
      hooks.run('target-validation', targetHookResult, event, target);

      // If we know that dropping is not allowed here at all, we need to remove
      // the drop effect from the cursor. This is mainly since the handler in
      // targets.js has already handled the event and accepted it, which sets
      // the drop effect.
      if (!targetHookResult.valid) {
        event.dataTransfer.dropEffect = 'none';
      }
    }
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  hideDropIndicator();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  hideDropIndicator();
  draggedLinkContext = null;
}

/**
 * Handler for dropping onto a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  hideDropIndicator();

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      var contextUri = list.getAttribute('data-uri');
      if (contextUri) {
        performListChangesForEvent(event, list, contextUri, location);
        event.handled = true;
      }
    }
  }
}

/**
 * Show the drop indicator below the provided list element.
 *
 * @param {HTMLElement} list A list element.
 */
function showDropIndicatorBelowList(list) {
  var listRect = list.getBoundingClientRect();
  showDropIndicator(listRect.left, listRect.bottom, listRect.width);
}

/**
 * Show the drop indicator above or below a list row.
 *
 * @param {HTMLElement} rowNode A list row element.
 * @param {number} cursorY The cursor Y position, relative to the viewport.
 */
function showDropIndicatorForRow(rowNode, cursorY) {
  var belowMiddle = isBelowMiddleOfNode(cursorY, rowNode);
  var rowRect = rowNode.getBoundingClientRect();
  var x = rowRect.left;
  var y = rowRect.top + (belowMiddle ? rowRect.height : 0);
  showDropIndicator(x, y, rowRect.width);
}

/**
 * Show the drop indicator line for the specified row and cursor position.
 * If the cursor position is below the middle of the row, the indicator will be
 * placed below the row, otherwise above the row.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {number} width The width of the indicator.
 */
function showDropIndicator(x, y, width) {

  // Don't use window.scroll X/Y because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var indicatorAbsX = window.pageXOffset + x;
  var indicatorAbsY = window.pageYOffset + y;
  var indicatorWidth = width;

  if (!dropIndicator) {
    dropIndicator = document.createElement('div');
    dropIndicator.className = 'tr-drag-indicator';
  }

  dropIndicator.style.left = indicatorAbsX + 'px';
  dropIndicator.style.width = indicatorWidth + 'px';
  dropIndicator.style.top = indicatorAbsY + 'px';

  if (!dropIndicator.parentNode) {
    document.body.appendChild(dropIndicator);
  }
}

/**
 * Hide the drop indicator.
 */
function hideDropIndicator() {
  if (dropIndicator && dropIndicator.parentNode) {
    dropIndicator.parentNode.removeChild(dropIndicator);
  }
}

/**
 * Perform the list changes that are needed from the drop event.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function performListChangesForEvent(event, list, contextUri, location) {
  var liveList = live(contextUri).get('rows');
  if (!liveList) return;

  var targetIndex = 0;

  if (location === 'below') {
    var lastRowNode = getLastRowFromLastList();

    // Dropping below a list without rows will use target index 0
    if (lastRowNode) {
      targetIndex = getTargetIndex(event.clientY, lastRowNode);
    }
  } else {
    var rowNode = getRowNode(event);
    if (!rowNode) return;
    targetIndex = getTargetIndex(event.clientY, rowNode);
  }

  var sourceContext = event.dataTransfer.getData('text/x-spotify-data-context');
  var isSameContext = sourceContext && sourceContext === contextUri;

  if (isSameContext) {
    performMoveChanges(contextUri, liveList, targetIndex);
  } else {
    performInsertChanges(event, list, contextUri, liveList, targetIndex);
  }
  event.data = {
    targetIndex: targetIndex
  };
}

/**
 * Move the selected items to a target index in the list.
 *
 * @param {string} contextUri The context URI of the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performMoveChanges(contextUri, liveList, targetIndex) {
  var indices = getMoveIndices(contextUri, liveList);

  // Selection can be nothing. This can happen if you select a row, drag it
  // and before dropping, the row is removed by something else (on another
  // device perhaps). Dropping should in that case not perform any action.
  // Similarly, if dragging multiple rows and some of the rows are removed
  // while dragging, only the rows that are still in the list will be moved.
  if (indices.length === 0) return;

  var operations = listOperations.getMoveOperations(indices, targetIndex);

  // If the list changed while dragging, it might happen that we end up
  // dropping at the same index as we're dragging from, which would give
  // us no operations to perform.
  if (operations.length === 0) return;

  liveList.publish(operations);

  temporarilyDisableList(contextUri, liveList);
}

/**
 * Insert items from the event into the list at the target index.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performInsertChanges(event, list, contextUri, liveList, targetIndex) {
  getInsertValues(event, list, liveList, contextUri, function (error, values) {
    if (error) return;
    if (values.length === 0) return;

    var operations = [{ type: 'insert', index: targetIndex, values: values }];

    liveList.publish(operations);

    temporarilyDisableList(contextUri, liveList);
  });
}

/**
 * Check if dropping at the current position in a list is allowed.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it's a valid drop position.
 */
function validateListDrop(event, list, location) {

  // All positions are valid if we're not dragging from a context in the first
  // place. If we do have a context though, we need to validate the position.
  var types = event.dataTransfer.types;
  var isDraggingFromContext = types.indexOf('text/x-spotify-data-context') > -1;
  if (isDraggingFromContext) {
    if (!validatePotentialOperations(event, list, location)) {
      return false;
    }
  }

  var uri = list.getAttribute('data-uri');
  if (uri && draggedLinkContext === uri) {
    return false;
  }

  var result = { valid: true };
  hooks.run('list-drop-validation', result, event, list, location);

  return !!result.valid;
}

/**
 * Simple wrapper to cache calls to selection.getIndicesPerList()
 *
 * @return {Object} The result of selection.getIndicesPerList()
 */
var cachedSelectionState = function () {
  var cache = {
    lastTime: 0,
    lastValue: null
  };
  var CACHE_TIMEOUT = 500;

  return {
    get: function get() {
      var now = Date.now();

      if (now - cache.lastTime > CACHE_TIMEOUT) {
        cache = {
          lastValue: selection.getIndicesPerList(),
          lastTime: now
        };
      }

      return cache.lastValue;
    },
    clear: function clear() {
      cache.lastTime = 0;
    }
  };
}();

/**
 * Check if dropping at the current event position would actually result in
 * operations that would change the list.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it would result in a change.
 */
function validatePotentialOperations(event, list, location) {
  // get a cached version of the selectionState
  var selectionState = cachedSelectionState.get();

  // Dropping inside the only selected range inside the only container that
  // has a selection is not allowed, as that would result in no change.
  if (selectionState.length === 1) {

    // Dropping inside a different context is always fine
    var contextUri = list.getAttribute('data-uri');
    if (contextUri !== selectionState[0].uri) {
      return true;
    }

    var selectedRanges = Range.fromIndices(selectionState[0].indicesWithHidden);

    if (selectedRanges.length === 1) {
      var selectedRange = selectedRanges[0];

      // Include the next row in the selected range to handle holding on the
      // top part of the next row, which would be a no-op. The bottom part of
      // the previous row will be taken care of by the code below.
      selectedRange.update(selectedRange.start, selectedRange.end + 1);

      var rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        var targetIndex = getTargetIndex(event.clientY, rowNode);
        if (targetIndex > -1) {
          var targetRange = new Range(targetIndex, targetIndex + 1);

          // If the target index is inside the selected range, it's not allowed
          // to drop, as that would be a no-op.
          if (targetRange.contained(selectedRange)) {
            return false;
          }
        }
      }
    }
  }

  return true;
}

/**
 * Get the drop target element that is matching the event target and the drag
 * MIME types of the event. This will start with the event target and step
 * outwards in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The element or null if not found.
 */
function getMatchingTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    if (isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get the list element that is matching the event target and the drag MIME
 * types of the event. This will start with the event target and step outwards
 * in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getMatchingListTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    var isList = $(currentNode).matches(SELECTOR_LIST);
    if (isList && isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get a valid list target from the end of body.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getListTargetFromBody(event) {
  var lastList = getLastListNode();
  if (lastList) {
    var sameParent = event.target.contains(lastList);
    if (sameParent && isMatchingTarget(event, lastList)) {
      if (isBelowNode(event.clientX, event.clientY, lastList)) {
        return lastList;
      }
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowFromLastList() {
  var lastList = getLastListNode();
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the last list in the DOM.
 *
 * @return {HTMLElement?} The list element, or null if not found.
 */
function getLastListNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  return lastList || null;
}

/**
 * Get the target index based on a cursor position and the row that the cursor
 * is on.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} rowNode The DOM node for the row.
 *
 * @return {number} The target index or -1 if not found.
 */
function getTargetIndex(y, rowNode) {
  var index = rowNode.getAttribute('data-index');

  if (index === null) {
    index = -1;
  } else {
    index = parseInt(index, 10);

    if (isNaN(index)) {
      index = -1;
    } else {
      // If cursor is in the bottom part of the row, dropping will place items
      // after the row, so we need to increment the index.
      if (isBelowMiddleOfNode(y, rowNode)) {
        index++;
      }
    }
  }

  return index;
}

/**
 * Get the indices of the rows to move.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list to be changed.
 *
 * @return {Array.<number>} Array of indices.
 */
function getMoveIndices(contextUri, liveList) {
  // As we need the indices, we must use the current selection state,
  // since the list might have changed since the start of the drag.
  // We are only in this function if we are dragging in the same
  // context, so the current selection state will always be valid.
  var selectionState = selection.getIndicesPerList();
  if (selectionState.length !== 1) return [];

  var firstContainer = selectionState[0];
  var selectedIndices = firstContainer.indices;
  var indices = selectedIndices.slice();

  if (indices.length === 0) return [];

  hooks.run('get-move-indices', contextUri, liveList, indices);

  // The indices must be sorted for the utility that creates the list operations
  indices.sort(function (a, b) {
    return a - b;
  });

  return indices;
}

/**
 * Get the values to use for insertion in the list. This will get the event data
 * for the matching MIME types.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {LiveList} liveList The live list for the context.
 * @param {string} contextUri The context URI for the list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getInsertValues(event, list, liveList, contextUri, callback) {
  var eventTypes = event.dataTransfer.types;
  var listTypes = list.getAttribute(ATTR_TARGET);
  if (!listTypes) return callback(null, []);

  var matchingTypes = intersection(listTypes.split('|'), eventTypes);
  if (matchingTypes.length === 0) return callback(null, []);

  var data = getDataFromTypes(event, matchingTypes);

  var isTrackList = isListOfTracks(liveList, contextUri);

  getRowsFromData(data, isTrackList, function (error, rows) {
    if (error) return callback(error);

    callback(null, rows);
  });
}

/**
 * Get the event data associated with the provided MIME types.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array>} Object where key is MIME type and value is
 *     array of values (URIs).
 */
function getDataFromTypes(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var type = types[i];
    var itemsInData = data[type] = [];

    // A MIME type that starts with text/x-spotify is always containing a list
    // of Open URLs separated by '\n'.
    var hasURIs = type.indexOf('text/x-spotify') === 0;

    var dataForType = event.dataTransfer.getData(type);
    var items = hasURIs ? dataForType.split('\n') : [dataForType];
    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) {
          itemsInData.push(uriObject.toURI());
        }
      } else {
        itemsInData.push(item);
      }
    }
  }

  return data;
}

/**
 * Get list row data from the event data. This might expand items if the list
 * is a track list (dropping an album into a track list will expand the album
 * into its tracks and return track rows instead).
 *
 * @param {Object.<string, Array>} data Data from drop event.
 * @param {boolean} isTrackList True if the list is a track list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getRowsFromData(data, isTrackList, callback) {
  var flowFunctions = [];

  if (data['text/x-spotify-tracks']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('track', data['text/x-spotify-tracks']));
    });
  }

  if (data['text/x-spotify-albums']) {
    flowFunctions.push(function () {
      var albums = data['text/x-spotify-albums'];
      if (isTrackList) fetchListTrackRows(albums, this);else this.done(null, getRowObjects('album', albums));
    });
  }

  if (data['text/x-spotify-playlists']) {
    flowFunctions.push(function () {
      var playlists = data['text/x-spotify-playlists'];
      if (isTrackList) fetchListTrackRows(playlists, this);else this.done(null, getRowObjects('playlist', playlists));
    });
  }

  if (data['text/x-spotify-artists']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('artist', data['text/x-spotify-artists']));
    });
  }

  if (data['text/x-spotify-users']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('user', data['text/x-spotify-users']));
    });
  }

  flow(flowFunctions).finally(function (error) {
    if (error) return callback(error);

    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);

    callback(null, rows);
  });
}

/**
 * Fetch the track rows from a set of list URIs. This is for the expansion of
 * for example an album into the tracks of the album.
 *
 * @param {Array.<string>} listUris Array of list URIs.
 * @param {Object} control Flow control object.
 */
function fetchListTrackRows(listUris, control) {
  flow().parallel(listUris, function (listUri) {
    var innerControl = this;
    live(listUri).query('rows(track(uri))', function (error, data) {
      if (error) return innerControl.done(null, []);
      var rows = data.rows.map(function (row) {
        return live(row);
      });
      innerControl.done(null, rows);
    }, live.ASAP);
  }).finally(function (error) {
    if (error) return control.done(null, []);
    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);
    control.done(null, rows);
  });
}

/**
 * Fetch the live object for the row of an item.
 *
 * @param {string} itemType The type of an item (for example 'track').
 * @param {Array.<string>} uris Array of item URIs.
 *
 * @return {Array.<LiveObject>} Array of row live objects.
 */
function getRowObjects(itemType, uris) {
  return uris.map(function (uri) {
    var row = {};
    row[itemType] = { uri: uri };
    return live(row);
  });
}

/**
 * Check if the list is a track list.
 *
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI for the list.
 *
 * @return {boolean} True if the list is a track list.
 */
function isListOfTracks(liveList, contextUri) {
  var uriObject = liburi.from(contextUri);
  var type = uriObject && uriObject.type;
  if (type === liburi.Type.PLAYLIST) return true;

  var result = { valid: false };
  hooks.run('is-list-of-tracks', result, liveList, contextUri);

  if (!result.valid) {
    var firstRow = liveList.get(0);
    var firstTrack = firstRow && firstRow.get('track');
    if (firstTrack) return true;
  }

  return !!result.valid;
}

/**
 * Check if the position is below the bottom edge of the node.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowNode(x, y, node) {
  var rect = node.getBoundingClientRect();
  var below = y >= rect.bottom;
  var betweenX = x >= rect.left && x <= rect.right;
  return below && betweenX;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Temporarily disable drag and dropping inside a list until the move or insert
 * is done. This is to prevent multiple operations to be called before the
 * response from the first comes back. We consider the operation done when we
 * receive the next update event, since it's very tricky to know when this
 * specific move is done. To prevent possible errors with being disabled
 * infinitely, we will enable it again after a certain timeout. This could
 * happen for example if the live list is switched out for a new list, in which
 * case we won't get the update event.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list that was changed.
 */
function temporarilyDisableList(contextUri, liveList) {

  disabledLists[contextUri] = true;

  var timer;

  var handler = function handler(operations) {
    clearTimeout(timer);
    liveList.off('update', handler);

    // Wait slighly longer to allow the change to trickle down to DOM
    setTimeout(function () {
      delete disabledLists[contextUri];
    }, 100);
  };

  liveList.on('update', handler);

  timer = setTimeout(handler, 500);
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.delegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.undelegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-elements":142,"../../spotify-live":312,"../../spotify-range2":352,"../selection":186,"./util/eventmodel":159,"./util/hooks":160,"finally":373,"mout/array/intersection":472,"spotify-liburi":563,"spotify-live-list-operations":564}],158:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/target
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var center = require('../center');
var eventModel = require('./util/eventmodel');
var hooks = require('./util/hooks');
var getLogContext = require('../util/get-log-context');
var UserDragAndDropInteraction1 = require('../../spotify-logger/messages/UserDragAndDropInteraction1');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';
var ATTR_NO_CLASSNAME = 'data-drop-no-classname';
var CLASSNAME_ACTIVE = 'drop-target-active';

var longHoldTimerId = 0;
var longHoldTimerDuration = 1000;
var draggedElement = null;
var lastEnteredElement = null;

/**
 * Handler for starting to drag.
 *
 * @param {MouseEvent} event A dragstart event object.
 * @param {HTMLElement} node The draggable DOM element.
 */
function onDragStart(event, node) {
  draggedElement = node;
  lastEnteredElement = null;
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  draggedElement = null;
  lastEnteredElement = null;

  stopLongHoldTimer();
  removeAnyActiveClass();
}

/**
 * Handler for dragging into a drop target.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnter(event, target) {
  if (validateTarget(event, target)) {
    setEnter(event, target);
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  if (validateTarget(event, target)) {
    setLeave(event, target);
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragOver(event, target) {
  if (validateTarget(event, target)) {

    // Tell the event that we are accepting drops on this target
    event.preventDefault();

    // Since other code might have set the dropEffect to something else,
    // we need to override that, since we're now accepting drops
    event.dataTransfer.dropEffect = 'copy';

    setEnter(event, target);

    // If the target is not valid, remove any styling for active drop target
  } else {
    setLeave(event, target);
  }
}

/**
 * Handler for dropping on a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  stopLongHoldTimer();

  // Dropping should remove active target class name.
  // Dropping outside of a target doesn't need this, as the target is only
  // active when hovering it.
  removeAnyActiveClass();

  if (validateTarget(event, target)) {
    var types = getMimeTypesForTarget(event, target);
    var dropData = getDropData(event, types);
    var sourceUri = event.dataTransfer.getData('text/x-spotify-data-context') || null;
    var sourceLogContext = event.dataTransfer.getData('text/x-spotify-data-log-context') || null;
    var sourceAppUri = event.dataTransfer.getData('text/x-spotify-data-app-uri') || null;
    var sourceIndex = parseInt(event.dataTransfer.getData('text/x-spotify-data-log-source-index'), 0);
    if (isNaN(sourceIndex)) sourceIndex = null;

    var targetUriNode = target.closest('[data-uri]');
    var targetUri = targetUriNode && targetUriNode.getAttribute('data-uri') || null;
    var targetLogContext = getLogContext(target);
    var targetAppUri = global.__spotify && global.__spotify.app_uri || null;

    // Give any other delegates a chance to handle the drop, and if so pass
    // that info along in the event.
    defer(function () {
      center.emit('drop', {
        handled: event.handled,
        node: target,
        sourceUri: sourceUri,
        targetUri: targetUri,
        data: dropData
      });

      var firstItem = dropData[Object.keys(dropData)[0]][0];
      var itemType = liburi.from(firstItem).type;
      var numberOfItems = Object.keys(dropData).reduce(function (sum, key) {
        return sum + dropData[key].length;
      }, 0);
      var targetIndex = event.data && event.data.targetIndex || null;

      UserDragAndDropInteraction1.log({
        item_type: itemType,
        item_uri: firstItem,
        number_items: numberOfItems,
        source_view_uri: sourceAppUri,
        source_uri: sourceUri,
        source_index: sourceIndex,
        source_component: sourceLogContext,
        target_view_uri: targetAppUri,
        target_uri: targetUri,
        target_index: targetIndex,
        target_component: targetLogContext
      });
    });
  }

  // Prevent navigation on drop
  event.preventDefault();

  // Reset here since our multi-frame architecture means we're not guaranteed
  // to have gotten a dragstart event in this frame prior to dropping.
  lastEnteredElement = null;
}

/**
 * Set target to be entered, including setting style and sending event.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setEnter(event, target) {
  if (target === lastEnteredElement) {
    return;
  }

  lastEnteredElement = target;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).addClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragenter', { node: target, types: types });

  startLongHoldTimer(target, types);
}

/**
 * Set target to be left, including removing style and sending event.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setLeave(event, target) {
  if (target !== lastEnteredElement) {
    return;
  }

  lastEnteredElement = null;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).removeClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragleave', { node: target, types: types });

  stopLongHoldTimer();
}

/**
 * Check if the drop target matches the MIME types for the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM element for the drop target.
 *
 * @return {boolean} True if the target is valid.
 */
function validateTarget(event, target) {

  // The element being dragged is not accepted as a drop target
  if (target === draggedElement) {
    return false;
  }

  var types = getMimeTypesForTarget(event, target);

  if (types.length) {
    var result = { valid: true };
    hooks.run('target-validation', result, event, target);

    if (result.valid) {
      return true;
    }
  }

  return false;
}

/**
 * Get the data associated with the drop, grouped by MIME type.
 * If the data contained Spotify URLs, they will be converted to Spotify URIs.
 *
 * @param {MouseEvent} event Event object for a drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array.<string>>} Data object of arrays of item
 *     URIs, grouped by MIME type.
 */
function getDropData(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var itemsInData = data[types[i]] = [];
    var dataForType = event.dataTransfer.getData(types[i]);
    var hasURIs = types[i].indexOf('text/x-spotify') === 0;
    var items = hasURIs ? dataForType.split('\n') : [dataForType];

    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) item = uriObject.toURI();
      }
      if (item) itemsInData.push(item);
    }
  }

  var hasContextData = types.indexOf('text/x-spotify-data-context') > -1;
  if (hasContextData) {
    data['text/x-spotify-data-context'] = [event.dataTransfer.getData('text/x-spotify-data-context')];
  }

  return data;
}

/**
 * Start a timer for emitting an event for long-hold on a target.
 * If one is already started, it will use the previous timer and not restart it.
 *
 * @param {HTMLElement} target A DOM element for the drop target.
 * @param {Array.<string>} types Array of MIME types.
 */
function startLongHoldTimer(target, types) {

  // Don't start a new timer if we already have one running
  if (longHoldTimerId) return;

  longHoldTimerId = setTimeout(function () {
    center.emit('dragover-long', { node: target, types: types });
  }, longHoldTimerDuration);
}

/**
 * Stop any running timer for emitting an event for long-hold on a target.
 */
function stopLongHoldTimer() {
  clearTimeout(longHoldTimerId);

  // Reset the timer ID so we can know that there is no timer running
  longHoldTimerId = 0;
}

/**
 * Remove the active class name from any element that has it.
 */
function removeAnyActiveClass() {
  var active = $('.' + CLASSNAME_ACTIVE);
  if (active) {
    active.removeClass(CLASSNAME_ACTIVE);
  }
}

/**
 * Get the MIME types that are matching both the drag event and the target.
 *
 * @param {MouseEvent} event Any kind of drag and drop event.
 * @param {HTMLElement} target A DOM element.
 *
 * @return {Array.<string>} Array of MIME types.
 */
function getMimeTypesForTarget(event, target) {
  var mimeTypes = [];
  var dataTypes = event.dataTransfer.types;

  var targetTypes = target.getAttribute(ATTR_TARGET);
  if (targetTypes) {
    targetTypes = targetTypes.split('|');

    for (var i = 0, l = dataTypes.length; i < l; i++) {
      var type = dataTypes[i];
      if (targetTypes.indexOf(type) > -1) {
        mimeTypes.push(type);
      }
    }
  }

  return mimeTypes;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.delegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.delegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.undelegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.undelegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

// Exporting for testing
var originalDuration = longHoldTimerDuration;
exports.setLongHoldDuration = function setLongHoldDuration(duration) {
  longHoldTimerDuration = duration;
};
exports.resetLongHoldDuration = function resetLongHoldDuration() {
  longHoldTimerDuration = originalDuration;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":142,"../../spotify-logger/messages/UserDragAndDropInteraction1":324,"../center":150,"../util/get-log-context":202,"./util/eventmodel":159,"./util/hooks":160,"prime/defer":513,"spotify-liburi":563}],159:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/eventmodel
 * @private
 *
 * This module is made to be an abstraction of the event model for drag and
 * drop. It also exposes a delegation interface which allows you to only
 * listen for events for targets matching a certain selector.
 *
 * The need for this abstraction is to simplify the code listening to drag
 * and drop events.
 *
 * - The raw events we get from the browser are sometimes not that easy to
 *   work with. For example, when moving from one target to another, we get
 *   a dragenter event before the dragleave event, which can cause confusion.
 *   This abstraction flips that around, so that you always get the dragleave
 *   event before the dragenter event.
 *
 * - The raw events also trigger for children. For example, if moving the
 *   cursor from one element to one of its children, we get a dragenter event
 *   for the child element and a dragleave for the outer element. This makes
 *   it difficult to highlight drop targets based on dragenter/dragleave.
 *   This abstraction helps by making sure the handler is not called if moving
 *   to a child element inside an element that matches the selector. There
 *   is an exception though when moving to a child that is also matching a
 *   selector, the outer element is then left and the child is entered.
 *
 * @example
 * function onDragEnter(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * }
 *
 * // Start listening
 * eventmodel.delegate('dragenter', '[data-drop-target]', onDragEnter);
 *
 * // Stop listening
 * eventmodel.undelegate('dragenter', '[data-drop-target]', onDragEnter);
 */
'use strict';

var $ = require('../../../spotify-elements');

var attached = {};
var delegations = {};
var movementHandlerCount = 0;

// State variables
var hasEntered = false;
var lastEnteredElement = null;
var lastEnterTarget = null;
var lastEnterEvent = null;
var wasLastEventEnter = false;

/**
 * Reset the temporary state variables used while dragging.
 */
function resetState() {
  hasEntered = false;
  lastEnteredElement = null;
  lastEnterTarget = null;
  lastEnterEvent = null;
  wasLastEventEnter = false;
}

/**
 * Generic handler for any event.
 * This function will look at the current delegations and run the handler
 * functions for the matching delegations.
 * Some events will be handled by calling a special handler, which in some cases
 * later will check for matching delegations.
 *
 * @param {Event} event Event object.
 */
function onEvent(event) {
  var handler = getPrimaryHandler(event.type);
  if (handler) {
    handler(event);
  } else {
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragenter event.
 * Depending on state, this might save the event for later and call the
 * handler at a later point, to ensure that the dragenter event is sent
 * after the dragleave.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 */
function onPrimaryDragEnter(event) {
  wasLastEventEnter = true;

  if (hasEntered) {
    if (lastEnteredElement !== event.target) {
      lastEnterEvent = event;
    }
  } else {
    hasEntered = true;
    lastEnteredElement = event.target;
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragleave event.
 * Depending on state, this might also trigger the handlers for a dragenter
 * event, if there was a saved event from before.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 */
function onPrimaryDragLeave(event) {
  wasLastEventEnter = false;
  lastEnteredElement = null;

  handleDelegationsForEvent(event);

  if (hasEntered) {
    if (lastEnterEvent) {
      lastEnteredElement = lastEnterEvent.target;
      handleDelegationsForEvent(lastEnterEvent);
      lastEnterEvent = null;
    } else {
      hasEntered = false;
    }
  }
}

/**
 * Handler for a drop event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDrop(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Handler for a dragend event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDragEnd(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Delegation handler for a dragenter event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragEnter(event, target, handler, selector) {
  if (target !== lastEnterTarget) {
    lastEnterTarget = target;
    callUserHandler(event, target, handler);
  }
}

/**
 * Delegation handler for a dragleave event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragLeave(event, target, handler, selector) {
  var shouldCallUserHandler = false;

  var lastElement = lastEnterEvent && lastEnterEvent.target;
  if (lastElement) {
    var isSameElement = target === lastElement;
    var isEnteringChild = !isSameElement && target.contains(lastElement);
    var isEnteringMatchingElement = $(lastElement).matches(selector);
    if (!isSameElement && (!isEnteringChild || isEnteringMatchingElement)) {
      shouldCallUserHandler = true;
    }
  }

  // Most often the sequence of events will be dragenter->dragenter->dragleave
  // when moving into one element and then into another element. But if the
  // sequence is just dragenter->dragleave, we should also call the user
  // handler. This would happen if there is no new entered element.
  if (!wasLastEventEnter) {
    shouldCallUserHandler = true;
  }

  if (shouldCallUserHandler) {
    lastEnterTarget = null;
    callUserHandler(event, target, handler);
  }
}

/**
 * Find matching delegations and call the handlers.
 *
 * @param {Event} event Event object.
 */
function handleDelegationsForEvent(event) {
  var type = event.type;
  var delegationData = delegations[type];

  if (delegationData && delegationData.length > 0) {

    delegationData.forEach(function (data) {
      var selector = data.selector;
      var matchingTarget = event.target.closest(selector);

      if (matchingTarget) {
        var handler = getHandler(type) || callUserHandler;
        handler(event, matchingTarget, data.handler, selector);
      }
    });
  }
}

/**
 * Call the user handler for a delegation.
 *
 * @param {Event} event Event object.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function callUserHandler(event, target, handler, selector) {
  handler.call(exports, event, target);
}

/**
 * Get any handler that needs to be called for a raw event before looking
 * for any delegations.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getPrimaryHandler(type) {
  switch (type) {
    case 'dragenter':
      return onPrimaryDragEnter;
    case 'dragleave':
      return onPrimaryDragLeave;
    case 'dragend':
      return onPrimaryDragEnd;
    case 'drop':
      return onPrimaryDrop;
  }
  return null;
}

/**
 * Get any handler that needs to be called after matching delegations,
 * but before calling the user handler.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getHandler(type) {
  switch (type) {
    case 'dragenter':
      return onDragEnter;
    case 'dragleave':
      return onDragLeave;
  }
  return null;
}

/**
 * Check if the event type is one of the events that need special handling
 * for movement (enter/leave events).
 *
 * @param {string} type Event type.
 *
 * @return {boolean} True if the type is a movement type, false otherwise.
 */
function isMovementType(type) {
  switch (type) {
    case 'dragenter':
      return true;
    case 'dragleave':
      return true;
    case 'dragend':
      return true;
    case 'drop':
      return true;
  }
  return false;
}

/**
 * Attach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function attach(type) {
  if (attached[type]) return;
  attached[type] = true;
  document.addEventListener(type, onEvent, false);
}

/**
 * Detach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function detach(type) {
  if (!attached[type]) return;
  attached[type] = false;
  document.removeEventListener(type, onEvent, false);
}

/**
 * Start listening for an event via event delegation for the specified
 * selector.
 *
 * @example
 * var selector = '[data-drop-target]';
 * eventModel.delegate('dragenter', selector, function(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * });
 */
function delegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount++;
    if (movementHandlerCount === 1) {
      attach('dragenter');
      attach('dragleave');
      attach('dragend');
      attach('drop');
    }
  } else if (!attached[type]) {
    attach(type);
  }

  if (!delegations[type]) delegations[type] = [];

  delegations[type].push({ selector: selector, handler: handler });
}

/**
 * Stop listening for an event via event delegation for the specified
 * selector and handler.
 *
 * @example
 * eventModel.undelegate('dragenter', '[data-drop-target]', handler);
 */
function undelegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount = Math.max(0, movementHandlerCount - 1);
    if (movementHandlerCount === 0) {
      detach('dragenter');
      detach('dragleave');
      detach('dragend');
      detach('drop');
    }
  }

  var delegationsForType = delegations[type];
  if (delegationsForType) {
    for (var i = 0, l = delegationsForType.length; i < l; i++) {
      var data = delegationsForType[i];
      if (data.selector === selector && data.handler === handler) {
        delegationsForType.splice(i, 1);
        break;
      }
    }

    if (!isMovementType && delegationsForType.length === 0) {
      detach(type);
    }
  }
}

exports.delegate = delegate;
exports.undelegate = undelegate;

},{"../../../spotify-elements":142}],160:[function(require,module,exports){
/**
 * Hooks
 *
 * Almost like an event emitter. You can add hooks for different ids, and when
 * a hook for an ID is run, the handlers are called.
 *
 * @module spotify-events/dragndrop/util/hooks
 * @private
 */
'use strict';

var hooks = {};

/**
 * Add a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function. The hook sets the arguments.
 */
function add(id, handler) {
  if (!hooks[id]) hooks[id] = [];
  hooks[id].push(handler);
}

/**
 * Remove a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function.
 */
function remove(id, handler) {
  if (hooks[id]) {
    var index = hooks[id].indexOf(handler);
    if (index > -1) {
      hooks[id].splice(index, 1);
    }
  }
}

/**
 * Run the hook handlers for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {...*} var_args Arguments to pass to the handlers.
 */
function run(id, var_args) {
  var handlers = hooks[id];
  if (handlers && handlers.length > 0) {
    var args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, l = handlers.length; i < l; i++) {
      handlers[i].apply(null, args);
    }
  }
}

exports.add = add;
exports.remove = remove;
exports.run = run;

},{}],161:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/itemtext
 * @private
 */
'use strict';

var live = require('../../../spotify-live');
var liburi = require('spotify-liburi');

/**
 * Get the text for a URI.
 *
 * @param {string} uri Any URI.
 *
 * @return {string} The text.
 */
function getForUri(uri) {
  var uriObject = liburi.from(uri);
  if (!uriObject) return '';

  var type = uriObject.type;

  if (type === liburi.Type.TRACK || type === liburi.Type.LOCAL) {
    return getForTrack(uri);
  } else if (type === liburi.Type.ARTIST || type === liburi.Type.LOCAL_ARTIST) {
    return getForArtist(uri);
  } else if (type === liburi.Type.ALBUM || type === liburi.Type.LOCAL_ALBUM) {
    return getForAlbum(uri);
  } else if (type === liburi.Type.PLAYLIST) {
    return getForPlaylist(uri);
  } else if (type === liburi.Type.USER || type === liburi.Type.PROFILE) {
    return getForUser(uri);
  } else if (type === liburi.Type.FOLDER) {
    return getForFolder(uri);
  } else if (type === liburi.Type.STATION) {
    return getForStation(uri);
  }

  return '';
}

/**
 * Get the text for a track URI.
 *
 * Examples:
 * Track Name – First Artist, Second Artist, Third Artist (and so on...)
 * Track Name
 *
 * @param {string} uri Track URI.
 *
 * @return {string} The text.
 */
function getForTrack(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistNames = artists.get(0, artists.length).map(function (artist) {
    return artist.get('name');
  }).join(', ');
  if (!artistNames) return itemName;

  return separateDragTextItems(itemName, artistNames);
}

/**
 * Get the text for an artist URI.
 *
 * Examples:
 * Artist Name
 *
 * @param {string} uri Artist URI.
 *
 * @return {string} The text.
 */
function getForArtist(uri) {
  return live(uri).get('name') || '';
}

/**
 * Get the text for an album URI.
 *
 * Examples:
 * Artist Name – Album Name
 * Album Name
 *
 * @param {string} uri Album URI.
 *
 * @return {string} The text.
 */
function getForAlbum(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistName = artists.get(0).get('name');
  if (!artistName) return itemName;

  return separateDragTextItems(artistName, itemName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * Playlist Name – Owner Name
 * Playlist Name – owner_username
 * Playlist Name
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForPlaylist(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var owner = object.get('owner');
  var ownerName = owner && (owner.get('name') || owner.get('username'));
  if (!ownerName) return itemName;

  return separateDragTextItems(itemName, ownerName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * User Name
 * username
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForUser(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (itemName) return itemName;

  var uriObject = liburi.fromString(uri);
  var username = uriObject && uriObject.username;
  return username || '';
}

/**
 * Get the text for a folder URI.
 *
 * Examples:
 * Folder Name
 *
 * @param {string} uri Folder URI.
 *
 * @return {string} The text.
 */
function getForFolder(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a station URI.
 *
 * Examples:
 * Station Name
 *
 * @param {string} uri Station URI.
 *
 * @return {string} The text.
 */
function getForStation(uri) {
  return live(uri).get('name');
}

/**
 * Separate two strings by the special dash ('en dash', &#8211;) we use.
 *
 * @param {string} item1 First string.
 * @param {string} item2 Second string.
 *
 * @return {string} Final string.
 */
function separateDragTextItems(item1, item2) {
  return item1 + ' – ' + item2;
}

/**
 * Get the text for an element.
 *
 * @param {HTMLElement} target The target element being dragged.
 *
 * @return {string} The drag text.
 */
function getForElement(target) {
  var title = target.getAttribute('data-drag-text');
  if (title) return title;

  var uri = target.getAttribute('data-uri');
  if (uri) {
    title = getForUri(uri);
    if (title) return title;
  }

  title = target.getAttribute('title');
  if (title) return title;

  return target.textContent;
}

exports.getForUri = getForUri;
exports.getForElement = getForElement;

},{"../../../spotify-live":312,"spotify-liburi":563}],162:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var stickyEvents = require('./sticky');
var cosmos = require('./util/cosmos');
var merge = require('mout/object/merge');
var deepEquals = require('mout/lang/deepEquals');
var getOriginUri = require('../spotify-live-wrapped-uri').getOriginUri;
var appUtil = require('./util/app');

var SCROLL_PADDING = 8;
var STRING_FILTER_KEY = 'list-filter-string-';
var SESSION_STORAGE = 'spotify:session-storage';

function update(node) {
  if (!isAttached) return;

  node = $(node) || $(document);
  var nodes = node.matches('[data-filter]') ? [node[0]] : node.search('[data-filter]');
  if (!nodes) return;
  nodes.forEach(function (node) {
    var uri = getURI(node);
    if (!uri) return;

    // When no state is initialized for the uri, initialize it and set the string from the DOM.
    // This is the case when the playlist app loaded a URI that globally has a filter string set.
    var hasState = states[uri];
    if (!hasState) {
      var inputElement = $(node).find('input[type=text]')[0];
      var value = inputElement.value;
      if (value) {
        updateState(uri, {
          activated: true,
          enteredString: value
        });
      }
    }

    handleStale(uri);
  });
}

function handleStale(uri) {
  render(uri);
  logUsage(uri);

  var state = getState(uri);
  var stateHasBeenEmitted = deepEquals(state, lastEmittedStates[uri]);
  if (!stateHasBeenEmitted) {
    lastEmittedStates[uri] = state;
    var value = state.activated ? state.enteredString : '';
    emitFilterRequest(uri, value);
    persistFilterOnSessionStorage(uri, value);
  }
}

function render(uri) {
  var $candidateContainers = $(document).search('[data-uri] [data-filter]');
  if (!$candidateContainers) return;

  var $matchingCandidates = $candidateContainers.filter(function (container) {
    return getURI(container) === uri;
  });
  $matchingCandidates.forEach(function (mainElement) {
    var state = getState(uri);
    var inputElement = $(mainElement).find('input[type=text]')[0];
    var wrapperElement = $(mainElement).find('.h-search-wrapper')[0];
    if (state.activated) {
      if (!$(wrapperElement).hasClass('focus')) {
        $(wrapperElement).addClass('focus');

        mainElement.setAttribute('data-sticky', '');
        stickyEvents.update();
      }

      // NOTE: Setting input.value makes the cursor jump
      // which is annoying when changing typos in the
      // search field. Only set value if text ACTUALLY
      // changes:
      if (inputElement.value !== state.enteredString) {
        inputElement.value = state.enteredString;
      }
    } else {
      inputElement.blur();
      if ($(wrapperElement).hasClass('focus')) {
        $(wrapperElement).removeClass('focus');

        mainElement.removeAttribute('data-sticky');
        stickyEvents.update();
      }
      inputElement.value = '';
    }
  });
}

function focusAndSelectInput(inputElement) {

  // Only focus and select the input text if doesn't have focus already.
  if (document.activeElement != inputElement) {
    inputElement.focus();
    inputElement.select();
  }
}

function scrollIntoView(inputElement) {
  var rect = inputElement.getBoundingClientRect();

  // Only scroll if the input is out of view
  var filterFieldOffset = rect.top - SCROLL_PADDING;
  if (filterFieldOffset < 0 || rect.bottom > window.innerHeight) {
    window.scrollTo(0, window.pageYOffset + filterFieldOffset);
  }
}

function logUsage(uri) {
  var state = getState(uri);
  if (state.enteredString && !getState(uri).usageLogged) {
    updateState(uri, { usageLogged: true });
    // Fields must be in the same order as in logparser
    // AND all fields MUST be present or logging wont happen
    // and will fail silently. https://ghe.spotify.net/datainfra/log-parser/blob/94e6a896efa5d781b0cac54f3dcf92c9c4ee3c73/spotify/log_parser/messages_specs.py#L777

    cosmos.post({
      url: 'sp://logging/v1/log',
      body: {
        'message': 'ClientEvent',
        'version': 3,
        'fields': [window.__spotify.app_uri, // source
        'spotify-events-filter', // context
        'user:typing', // event
        'input-field', // event-version
        '', // test-version
        '', // source-version
        '', // source-vendor
        '' // json-data
        ]
      }
    });
  }
}

function emitFilterRequest(uri, value) {
  center.emit('filter-request', uri, value);
}

function persistFilterOnSessionStorage(uri, value) {
  uri = getOriginUri(uri) || uri;

  var key = STRING_FILTER_KEY + uri;
  var publish = {};
  publish[key] = value;
  live(SESSION_STORAGE).publish(publish);
}

function handleCancelClick(e) {
  clear(getURI(e.target));
}

function handleInputInput(e) {
  updateState(getURI(e.target), { enteredString: e.target.value });
}

function handleInputKeyup(e) {
  var isEscape = e.keyCode === 27;
  if (isEscape) clear(getURI(e.target));
}

function handleInputFocus(e) {
  updateState(getURI(e.target), { activated: true });
}
function handleInputFocusOut(e) {
  var state = getState(getURI(e.target));
  if (state.enteredString === '') updateState(getURI(e.target), { activated: false });
}

function clear(uri) {
  updateState(uri, { activated: false, enteredString: '' });
}

function getState(uri) {
  return states[uri] || {
    activated: false,
    enteredString: ''
  };
}

function updateState(uri, update) {
  states[uri] = merge(getState(uri), update);
  handleStale(uri);
}

function getURI(element) {
  var uri = element.getAttribute('data-uri');
  if (!uri) {
    var parents = $(element).parents('[data-uri]');
    if (parents) uri = parents[0].getAttribute('data-uri');
  }
  uri = getOriginUri(uri) || uri;

  // We use the data-uri as a key for state, but the uri of the
  // container might change to the "sorted" versions of the
  // original uri. From a filter UX state standpoint, these are the
  // same, so we normalize it here.
  return uri || null;
}

var states;
var lastEmittedStates;

var isAttached = false;
var controlMessageSubscription;
var attach = function attach() {
  if (isAttached) return;
  isAttached = true;
  states = {};
  lastEmittedStates = {};
  controlMessageSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (_, response) {
    if (!appUtil.isActive()) return;

    var isMessageOfTypeFind = response && response.body && response.body.type === 'filter';
    if (!isMessageOfTypeFind) return;
    $('[data-filter]').forEach(function (mainElement, i) {
      updateState(getURI(mainElement), {
        activated: true
      });

      var inputElement = $(mainElement).find('input[type=text]')[0];
      if (inputElement) {

        // Only scroll first filter into view.
        if (i === 0) {
          scrollIntoView(inputElement);
        }

        focusAndSelectInput(inputElement);
      }
    });
  });

  center.on('filter-reset', clear);

  $(document).delegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).delegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).delegate('input', '[data-filter] input', handleInputInput);
  $(document).delegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).delegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).delegate('focusout', '[data-filter] input', handleInputFocusOut);
};

var detach = function detach() {
  if (!isAttached) return;
  states = null;
  controlMessageSubscription.cancel();

  center.off('filter-reset', clear);

  $(document).undelegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).undelegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).undelegate('input', '[data-filter] input', handleInputInput);
  $(document).undelegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).undelegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).undelegate('focusout', '[data-filter] input', handleInputFocusOut);
  isAttached = false;
};

// Tells native container that the current app can handle filter
// commands. Enables filter commands in the native menu,
// along with corresponding keyboard shortcuts.
var broadcast = function broadcast(enabled) {
  if (enabled === undefined) throw new Error('broadcast requires enabled argument');
  cosmos.post({
    url: 'sp://messages/v1/container/control',
    body: {
      type: 'update_menu_state',
      enable_filter_item: enabled
    }
  });
};

module.exports = {
  attach: attach,
  detach: detach,
  update: update,
  broadcast: broadcast
};

},{"../spotify-elements":142,"../spotify-live":312,"../spotify-live-wrapped-uri":311,"./center":150,"./sticky":192,"./util/app":199,"./util/cosmos":200,"mout/lang/deepEquals":484,"mout/object/merge":503}],163:[function(require,module,exports){
'use strict';

var modules = [require('./anchor'), require('./player'), require('./dragndrop'), require('./add'), require('./selection'), require('./contextmenu'), require('./navbar'), require('./offline'), require('./sticky'), require('./filter'), require('./watch'), require('./tooltip'), require('./list'), require('./menu'), require('./scroll'), require('./carousel'), require('./scrollbar'), require('./slider'), require('./select'), require('./sort'), require('./thumbs'), require('./touch-mediaobjects'), require('./list-quick-jump')];

var events = {};

var isAttached = false;

events.update = function update(node) {
  if (!isAttached) return;

  modules.forEach(function (module) {
    module.update(node);
  });
};

events.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  modules.forEach(function (module) {
    module.attach();
  });
};

events.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  modules.forEach(function (module) {
    module.detach();
  });
};

module.exports = events;

},{"./add":147,"./anchor":148,"./carousel":149,"./contextmenu":151,"./dragndrop":156,"./filter":162,"./list":165,"./list-quick-jump":164,"./menu":166,"./navbar":167,"./offline":168,"./player":170,"./scroll":175,"./scrollbar":180,"./select":183,"./selection":186,"./slider":190,"./sort":191,"./sticky":192,"./thumbs":194,"./tooltip":195,"./touch-mediaobjects":196,"./watch":204}],164:[function(require,module,exports){
(function (global){
'use strict';

var center = require('./center');
var cosmos = require('./util/cosmos');
var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var SPACE_KEYCODE = 32;
var BACKSPACE_KEYCODE = 8;
var DELETE_KEYCODE = 46;

exports.attach = function attach() {
  document.addEventListener('keypress', onKeyPress, false);
  document.addEventListener('keydown', onKeyDown, false);
};

exports.detach = function detach() {
  document.removeEventListener('keypress', onKeyPress, false);
  document.removeEventListener('keydown', onKeyDown, false);
};

exports.update = function () {};

var selector = ':not([data-sticky-active]) > [data-list-quick-jump]';
var SEARCH_STRING_CONCATENATION_TIMEOUT = 1000;

var searchStringsByUri = {};
var searchTimeoutsByUri = {};
var searchTimestampsByUri = {};

// onKeyPress is needed to read characters properly
function onKeyPress(event) {
  if (shouldEventBeIgnored(event)) return;
  processEvent(event);
}

// onKeyDown is needed to read <backspace>
function onKeyDown(event) {
  if (shouldEventBeIgnored(event)) return;

  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  if (!isBackspace) return;
  processEvent(event);
}

function processEvent(event) {
  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  var letter = event.keyCode === SPACE_KEYCODE ? ' ' : String.fromCharCode(event.keyCode).trim();
  if (!letter && !isBackspace) return;

  var listNode = getListNode(event.target);
  if (!listNode) return;

  var uri = getUri(listNode);
  if (!uri) return;

  // No need to do anything if there is no active search and user presses
  // BACKSPACE, since that would temporarily disable using SPACE for toggling
  // music, even though no quick-jump was actually made (KM-10204)
  if (isBackspace && !searchStringsByUri[uri]) return;

  if (!(uri in searchStringsByUri)) searchStringsByUri[uri] = '';

  if (isBackspace) {
    searchStringsByUri[uri] = searchStringsByUri[uri].slice(0, -1);
  } else if (letter) {
    searchStringsByUri[uri] += letter;
  }

  center.emit('list-quick-jump-request', uri, searchStringsByUri[uri] || null);

  if (searchTimeoutsByUri[uri]) clearTimeout(searchTimeoutsByUri[uri]);

  if (event.keyCode === SPACE_KEYCODE) {
    event.preventDefault(); // Prevent space from scrolling page
  }

  var shortcutsToIgnore = [{ keyCode: SPACE_KEYCODE }, { keyCode: BACKSPACE_KEYCODE }, { keyCode: DELETE_KEYCODE }];

  // Tell container to ignore <space>, <backspace> and <delete> shortcuts
  // until further notice
  cosmos.post({
    url: 'sp://messages/v1/ignoreshortcuts',
    body: {
      action: 'ignore',
      shortcuts: shortcutsToIgnore
    }
  });

  searchTimeoutsByUri[uri] = setTimeout(function () {
    // Tell container to stop ignoring <space>, <backspace> and <delete>
    // shortcuts
    cosmos.post({
      url: 'sp://messages/v1/ignoreshortcuts',
      body: {
        action: 'unignore',
        shortcuts: shortcutsToIgnore
      }
    });

    delete searchStringsByUri[uri];
    delete searchTimeoutsByUri[uri];
    delete searchTimestampsByUri[uri];
    center.emit('list-quick-jump-request', uri, null);
  }, SEARCH_STRING_CONCATENATION_TIMEOUT);

  if (searchStringsByUri[uri].length <= 20) {
    var timeSinceLastLetter = Date.now() - searchTimestampsByUri[uri] || null;
    ClientEvent3.log({
      source: global.__spotify && global.__spotify.app_uri || null,
      context: uri,
      event_version: 'list-quick-jump',
      event: 'user:type',
      json_data: JSON.stringify({
        str: searchStringsByUri[uri],
        letter: letter,
        was_backspace: isBackspace,
        time_since_last_letter: timeSinceLastLetter
      })
    });
  }

  searchTimestampsByUri[uri] = Date.now();
}

function shouldEventBeIgnored(event) {
  return event.metaKey || event.ctrlKey || event.target.matches('input, textarea, [contenteditable]');
}

function getListNode(target) {
  var listNode = target.closest(selector);
  if (!listNode) {
    var listNodes = document.querySelectorAll(selector);
    var hasOnlyOneListNode = listNodes && listNodes.length === 1;

    if (hasOnlyOneListNode) {
      listNode = listNodes[0];
    }
  }
  return listNode;
}

function getUri(listNode) {
  var uriParent = listNode.closest('[data-uri]');
  return uriParent && uriParent.getAttribute('data-uri');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-logger/messages/ClientEvent3":322,"./center":150,"./util/cosmos":200}],165:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var selection = require('./selection');
var cosmos = require('./util/cosmos');
var appUtil = require('./util/app');

var ROW_SELECTOR = '[data-list-item]';
var UNAVAILABLE_CLASS_NAME = 'unavailable';
var OFFLINE_DOWNLOADED_CLASS_NAME = 'offline-downloaded';
var OFFLINE_DOWNLOADING_CLASS_NAME = 'offline-downloading';
var OFFLINE_WAITING_CLASS_NAME = 'offline-waiting';

var storedTrackURIsForUnplayable = {};
var storedTrackURIsForOffline = {};

function updatePlayabilityForRows(uri, playable) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {
    updatePlayabilityForElements(rows, playable);
  }
}

function updatePlayabilityForElements(elements, playable) {
  if (playable) {
    elements.removeClass(UNAVAILABLE_CLASS_NAME);
  } else {
    elements.addClass(UNAVAILABLE_CLASS_NAME);
  }
}

function updateOfflineForRows(uri, shouldBeOffline, offlineProgress) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {

    // This will take an elements object as the first argument, so it can contain multiple rows
    updateOfflineForElements(rows, shouldBeOffline, offlineProgress);
  }
}

function updateOfflineForElements(elements, shouldBeOffline, offlineProgress) {

  // The track is either already downloaded or will be soon
  if (shouldBeOffline) {

    // Download done
    if (offlineProgress === 1) {
      elements.addClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);

      // Waiting to be downloaded
    } else if (offlineProgress === 0) {
      elements.addClass(OFFLINE_WAITING_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);

      // Downloading at the moment
    } else {
      elements.addClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
    }

    // The track is not supposed to be downloaded offline
  } else {
    elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
    elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
    elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
  }
}

function updateUnplayableRows(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');

      var model = live(uri);
      var playable = model.get('playable');

      if (playable !== undefined) {
        updatePlayabilityForElements($(row), playable);
      }

      if (uri in storedTrackURIsForUnplayable) return;
      storedTrackURIsForUnplayable[uri] = true;

      model.on('update', function (properties) {
        if ('playable' in properties) {
          updatePlayabilityForRows(uri, properties.playable);
        }
      });
    });
  }
}

function updateOfflineSyncing(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');
      var model = live(uri);

      // Try to query the data sync if possible (live.ASAP), to try to set the
      // class names before adding the rows to the DOM (by the scroller), to
      // avoid flickering.
      model.query('shouldBeOffline, offlineProgress', function (error, data) {
        if (error) throw error;
        updateOfflineForElements($(row), data.shouldBeOffline, data.offlineProgress);

        if (uri in storedTrackURIsForOffline) return;
        storedTrackURIsForOffline[uri] = true;

        model.on('update', function (properties) {
          if ('shouldBeOffline' in properties || 'offlineProgress' in properties) {
            updateOfflineForRows(uri, model.get('shouldBeOffline'), model.get('offlineProgress'));
          }
        });
      }, live.ASAP);
    });
  }
}

function handleKeyDown(event) {
  if (!event.target.closest(ROW_SELECTOR) || ignoredShortcuts[JSON.stringify({ keyCode: event.keyCode })]) return;

  var shouldRemove = false;
  var isWindows = /Win/.test(global.window.navigator.userAgent);

  var isBackspace = event.keyCode === 8;
  var isDelete = event.keyCode === 46;

  if (isWindows) {
    shouldRemove = isDelete;
  } else {
    shouldRemove = isBackspace || isDelete;
  }

  if (shouldRemove) {
    removeCurrentlySelectedListItems();
  }
}

function removeCurrentlySelectedListItems() {
  var lists = selection.getIndicesPerList();
  if (lists.length > 0) {
    var firstContainerIndex = null;
    var firstIndex = null;
    lists.forEach(function (list) {
      // Delete from origin list where applicable
      // TODO: We could just remove from the list directly, without going
      // through the origin list. Removing from a sorted list will pass
      // the change on to the origin list automatically.
      if (list.origin) {
        list = list.origin;
      }
      var model = live(list.uri);

      var indices = list.indices.sort(function (a, b) {
        return a - b;
      });

      model.query('allows(removeTracks)', function (error, data) {
        if (error) throw error;
        if (!data.allows.removeTracks) return;

        model.get('rows', function (error, liveList) {
          if (error) throw error;
          var operations = indices.map(function (index, indexInArray) {
            return { type: 'remove', index: index - indexInArray, length: 1 };
          });
          liveList.publish(operations);

          if (firstIndex === null) {
            firstIndex = indices[0];
            firstContainerIndex = list.containerIndex;
          }
        });
      });
    });
  }
}

function handleScrollShow(data) {
  updateUnplayableRows(data.container, data.nodes);
  updateOfflineSyncing(data.container, data.nodes);
}

// Exported for testing
exports._classNames = {
  UNAVAILABLE: UNAVAILABLE_CLASS_NAME,
  OFFLINE_WAITING: OFFLINE_WAITING_CLASS_NAME,
  OFFLINE_DOWNLOADING: OFFLINE_DOWNLOADING_CLASS_NAME,
  OFFLINE_DOWNLOADED: OFFLINE_DOWNLOADED_CLASS_NAME
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateUnplayableRows(node);
  updateOfflineSyncing(node);
};

var doc = $(document);
var deleteSubscription;
var ignoredShortcutsSubscription;
var ignoredShortcuts = {};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('keydown', handleKeyDown);
  center.on('scroll-show-before', handleScrollShow);

  deleteSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && data.type === 'delete' && appUtil.isActiveAndFocused()) {
      removeCurrentlySelectedListItems();
    }
  });

  ignoredShortcutsSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/ignoreshortcuts'
  }, function (error, response) {
    if (response.body.action === 'ignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        ignoredShortcuts[JSON.stringify(shortcut)] = 1;
      });
    } else if (response.body.action === 'unignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        delete ignoredShortcuts[JSON.stringify(shortcut)];
      });
    }
  });
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('keydown', handleKeyDown);
  center.off('scroll-show-before', handleScrollShow);

  if (deleteSubscription) {
    deleteSubscription.cancel();
    deleteSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":142,"../spotify-live":312,"./center":150,"./selection":186,"./util/app":199,"./util/cosmos":200}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attach = attach;
exports.detach = detach;
exports.update = update;

var _throttle = require('./util/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _center = require('./center');

var _center2 = _interopRequireDefault(_center);

var _spotifyNavigation = require('../spotify-navigation');

var _spotifyNavigation2 = _interopRequireDefault(_spotifyNavigation);

var _appState = require('../spotify-navigation/app-state');

var _appState2 = _interopRequireDefault(_appState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SELECTOR_MENU = '[data-menu]';
var SELECTOR_MENU_ITEM = '[data-menu-item]';
var SELECTOR_MENU_ITEM_DISABLED = '[data-menu-item-disabled]';
var SELECTOR_MENU_ITEM_ENABLED = '[data-menu-item]:not([data-menu-item-disabled])';
var ATTRIBUTE_MENU = 'data-menu';
var ATTRIBUTE_MENU_ITEM = 'data-menu-item';
var CLASS_SUBMENU = '.dropdown-submenu';
var CLASS_MENU = '.dropdown-menu';

var navigator = new _spotifyNavigation2.default.Navigator();

var isAttached = false;

// The state will take the following shape (a nested structure that can be any
// number of levels deep):
// {
//   menu: { // null if root menu is not open
//     node: menuNode,
//     selectedNode: menuItemNode, // or null
//     menu: { // null if a sub menu is not open
//       node: subMenuNode,
//       selectedNode: subMenuItemNode, // or null,
//       menu: null, // null if a sub menu is not open
//       parent: <back-reference>, // a reference to the object one level up
//     },
//     parent: null, // always null for the root menu
//   }
// }
var state = {
  menu: null
};

/**
 * Handler for when an element gets focused.
 *
 * @param {FocusEvent} event A focus event.
 */
function onFocus(event) {
  var targetMenu = event.target.closest(SELECTOR_MENU);
  if (targetMenu && !state.menu) {
    state.menu = {
      node: targetMenu,
      selectedNode: null,
      menu: null,
      active: true,
      parent: null
    };

    targetMenu.addEventListener('mousemove', onMouseMoveThrottled);
    targetMenu.addEventListener('mouseleave', onMouseLeave);

    // We need to ensure that before triggering the "touchstart" event in the <LI> element
    // of the node, we emulate the mouse being moved over it. This way, the listeners are
    // attached and they will fire.
    // Note: this "mouseMove" call cannot be throttled, because the "touchstart" that will
    // trigger in the <LI> will happen before the throttler fires the event. Additionally,
    // there's no need to use the throttling logic for the touchstart event.
    targetMenu.addEventListener('touchstart', onMouseMove, true);
  }
}

/**
 * Handler for when an element loses focus.
 *
 * @param {FocusEvent} event A blur event.
 */
function onBlur(event) {
  var target = event.target;
  var relatedTarget = event.relatedTarget;


  if (state.menu && target === state.menu.node) {
    // A blur on the menu (target) can mean an element inside of it gains focus.
    // No need to reset then.
    if (!relatedTarget || !target.contains(relatedTarget)) {
      hideMenu();
    }
  }
}

/**
 * Handler for when a key is pressed.
 *
 * @param {KeyboardEvent} event A keyboard event.
 */
function onKeyDown(event) {
  // Only act on events when a menu is open
  if (!state.menu) {
    return;
  }

  var keyCode = event.keyCode;
  var isEnter = keyCode === 13;
  var isEscape = keyCode === 27;
  var isUp = keyCode === 38;
  var isDown = keyCode === 40;
  var isLeft = keyCode === 37;
  var isRight = keyCode === 39;

  if (isEnter) {
    // Look for links to follow inside the current menu item.
    var activeMenuState = getStateForActiveMenu();
    var selectedMenuItem = activeMenuState.selectedNode;
    var link = selectedMenuItem && selectedMenuItem.querySelector('a[href]');
    if (link) {
      navigator.requestOpenState(new _appState2.default(link.getAttribute('href')));
    }
    emitActivateItemEvent(selectedMenuItem);
    return;
  }

  if (isEscape) {
    hideMenu();
    return;
  }

  if (isUp || isDown) {
    var _activeMenuState = getStateForActiveMenu();
    if (_activeMenuState.node) {
      var newActiveMenuItem = isDown ? getMenuItemBelow(_activeMenuState) : getMenuItemAbove(_activeMenuState);

      if (newActiveMenuItem) {
        selectItemInMenu(_activeMenuState, _activeMenuState, newActiveMenuItem);
      }
    }
    return;
  }

  if (isRight) {
    var _activeMenuState2 = getStateForActiveMenu();
    if (_activeMenuState2.selectedNode) {
      if (_activeMenuState2.selectedNode.matches(CLASS_SUBMENU)) {

        // Open the sub menu if not open already (might have been opened by the
        // mouse cursor)
        if (!_activeMenuState2.menu) {
          openSubMenu(_activeMenuState2, _activeMenuState2.selectedNode);
        }

        // Select the first item in the sub menu
        var subMenuNode = _activeMenuState2.menu.node;
        var firstItemInSubMenu =
        // We'd like to get firstElementChild to avoid text nodes, but since
        // JSDom doesn't support that, fall back to firstChild for tests.
        subMenuNode.firstElementChild || subMenuNode.firstChild;
        selectItemInMenu(_activeMenuState2, _activeMenuState2.menu, firstItemInSubMenu);
      }
    }
    return;
  }

  if (isLeft) {
    var _activeMenuState3 = getStateForActiveMenu();
    if (_activeMenuState3.parent) {
      closeSubMenuOf(_activeMenuState3.parent);
    }
    return;
  }
}

/**
 * Handler for when the mouse is moved over a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseMove(event) {
  var isMenu = event.target.matches(CLASS_MENU);
  if (isMenu) {
    return;
  }

  var targetItem = event.target.closest(SELECTOR_MENU_ITEM);
  if (!targetItem) {
    return;
  }

  var targetMenu = targetItem.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var activeMenuState = getStateForActiveMenu();

  if (targetItem === activeMenuState.selectedNode) {
    return;
  }

  if (targetItem.matches(SELECTOR_MENU_ITEM_DISABLED)) {
    deselectItemInMenu(activeMenuState);
  } else {
    selectItemInMenu(activeMenuState, targetMenuState, targetItem);
    activeMenuState = getStateForActiveMenu();
  }

  // When hovering over an item that has a sub menu, open the sub menu if not
  // open already.
  if (targetItem.matches(CLASS_SUBMENU)) {
    if (!targetMenuState.menu) {
      openSubMenu(targetMenuState, targetItem);
    }

    // When hovering over a regular item and a sub menu is currently shown, close
    // the sub menu.
  } else if (activeMenuState.menu) {
    closeSubMenuOf(activeMenuState);
  }
}
var onMouseMoveThrottled = (0, _throttle2.default)(onMouseMove);

/**
 * Handler for when the mouse leaves a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseLeave(event) {
  if (!event.relatedTarget || !event.relatedTarget.closest(SELECTOR_MENU)) {
    var activeMenuState = getStateForActiveMenu();
    deselectItemInMenu(activeMenuState);
    if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
  }
}

/**
 * Handler for when the current menu item is clicked.
 * This is only attached for the current menu item (if there is one).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onItemClick(event) {
  var targetMenu = event.target.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var itemNode = targetMenuState.selectedNode;

  emitActivateItemEvent(itemNode);
}

/**
 * In order to prevent the simulated click event when using a touchscreen,
 * we prevent default so click won't trigger. That click event would otherwise
 * trigger a click on the layer beneath since the menu is closed after activating an item.
 *
 * @param {TouchEvent} event a Touch event.
 */
function onItemTouchStart(event) {
  event.preventDefault();
  onItemClick(event);
}

/**
 * Emit a center event to activate the current item.
 *
 * @param {HTMLElement} itemNode HTML element for the item.
 */
function emitActivateItemEvent(itemNode) {
  _center2.default.emit('menu-activate-item', {
    menu: {
      id: state.menu.node.getAttribute(ATTRIBUTE_MENU) || '',
      element: state.menu.node
    },
    item: {
      id: itemNode.getAttribute(ATTRIBUTE_MENU_ITEM) || '',
      element: itemNode
    }
  });
}

/**
 * Set the current menu item to a new item.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 * @param {Object} targetMenuState Menu state object for the menu where the item
 *   that is to be selected is located.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function selectItemInMenu(activeMenuState, targetMenuState, itemNode) {
  var isTargetSubMenu = activeMenuState.menu === targetMenuState;
  var isTargetParentMenu = isSecondContainedInFirst(targetMenuState, activeMenuState);

  // If the item is in a sub menu we only want to remove any item event
  // listeners. Removing visual selection should only happen when moving within
  // the same menu.
  if (isTargetSubMenu) {
    removeItemListeners(activeMenuState.selectedNode);
  } else {
    deselectItemInMenu(activeMenuState);
  }

  // Deselect the currently selected item in parent menu, if moving from sub
  // menu to the parent menu.
  if (isTargetParentMenu) {
    deselectItemInMenu(targetMenuState);
  }

  activeMenuState.active = false;

  if (targetMenuState.selectedNode !== itemNode) {
    itemNode.classList.add('selected');
    addItemListeners(itemNode);
    targetMenuState.selectedNode = itemNode;
  }

  targetMenuState.active = true;
}

/**
 * Deselect any selected item in the menu represented by the passed state.
 *
 * @param {Object} menuState The menu state object.
 */
function deselectItemInMenu(menuState) {
  if (menuState.selectedNode) {
    var itemNode = menuState.selectedNode;
    itemNode.classList.remove('selected');
    removeItemListeners(itemNode);
    menuState.selectedNode = null;
  }
}

/**
 * Add the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function addItemListeners(itemNode) {
  itemNode.addEventListener('click', onItemClick);
  itemNode.addEventListener('touchstart', onItemTouchStart);
}

/**
 * Remove the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function removeItemListeners(itemNode) {
  itemNode.removeEventListener('click', onItemClick);
  itemNode.removeEventListener('touchstart', onItemTouchStart);
}

/**
 * Open a sub menu for the provided menu state object and item node.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function openSubMenu(menuState, itemNode) {
  var menuNode = itemNode.querySelector(CLASS_MENU);
  if (menuNode) {
    menuState.menu = {
      parent: menuState,
      node: menuNode,
      selectedNode: null,
      menu: null,
      active: false
    };
    menuNode.classList.add('open');
  }
}

/**
 * Close all sub menus for the provided menu state object.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 */
function closeSubMenuOf(menuState) {
  // Close deeper sub menus first
  if (menuState.menu.menu) {
    closeSubMenuOf(menuState.menu);
  }

  if (menuState.menu.active) {
    menuState.menu.active = false;
    menuState.active = true;
  }

  deselectItemInMenu(menuState.menu);
  menuState.menu.node.classList.remove('open');
  menuState.menu = null;
}

/**
 * Hide the current menu by broadcasting a message via center.
 * A listener can be added via center and the handler will then really hide it.
 *
 * @example
 * center.on('menu-hide', function(event) {
 *   if (event.menu.id === 'profile-menu') {
 *     hideProfileMenu();
 *   }
 * });
 */
function hideMenu() {
  if (state.menu) {
    var menuNode = state.menu.node;

    menuNode.removeEventListener('mousemove', onMouseMoveThrottled);
    menuNode.removeEventListener('mouseleave', onMouseLeave);
    menuNode.removeEventListener('touchstart', onMouseMove, true);

    // Remove any sub menus
    var menuState = state.menu;
    while (menuState) {
      deselectItemInMenu(menuState);
      menuState.node.classList.remove('open');
      menuState = menuState.menu;
    }

    delete state.menu;

    _center2.default.emit('menu-hide', {
      menu: {
        id: menuNode.getAttribute(ATTRIBUTE_MENU) || '',
        element: menuNode
      }
    });
  }
}

/**
 * Test if the second menu state object is contained in the second state object.
 *
 * @param {Object} first Menu state object.
 * @param {Object} second Menu state object.
 *
 * @return {Boolean}        True if it is.
 */
function isSecondContainedInFirst(first, second) {
  var statePart = first.menu;
  while (statePart && statePart !== second) {
    statePart = statePart.menu;
  }

  return !!statePart;
}

/**
 * Get the menu state object for the provided menu node. This assumes the node
 * is part of the state tree.
 *
 * @param {HTMLElement} menuNode The menu element.
 *
 * @return {Object} Menu state object.
 */
function getStateForMenu(menuNode) {
  var statePart = state.menu;
  while (statePart && statePart.node !== menuNode) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Get the menu state object for the currently active menu.
 *
 * @return {Object} Menu state object.
 */
function getStateForActiveMenu() {
  var statePart = state.menu;
  while (statePart && !statePart.active) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Find the menu item that is below the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item below the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemBelow(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    return activeMenuState.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);
  }

  var item = activeMenuState.selectedNode.nextElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.nextElementSibling;
  }

  return item;
}

/**
 * Find the menu item that is above the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item above the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemAbove(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    var results = activeMenuState.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);
    return results[results.length - 1] || null;
  }

  var item = activeMenuState.selectedNode.previousElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.previousElementSibling;
  }

  return item;
}

/**
 * The spotify-events style attach function. Should be called once when DOM
 * is ready.
 */
function attach() {
  if (isAttached) return;
  isAttached = true;

  document.addEventListener('keydown', onKeyDown);

  // use capture to work around the non-bubbling events
  document.addEventListener('focus', onFocus, true);
  document.addEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style detach function. Should be called when you no
 * longer need the events.
 */
function detach() {
  if (!isAttached) return;
  isAttached = false;

  state.menu = null;

  document.removeEventListener('keydown', onKeyDown);
  document.removeEventListener('focus', onFocus, true);
  document.removeEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style update function. Should be called when DOM
 * changes.
 */
function update() {}

},{"../spotify-navigation":332,"../spotify-navigation/app-state":331,"./center":150,"./util/throttle":203}],167:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');

var live = require('../spotify-live');
var center = require('./center');

var NAVBAR_ATTR_NAME = 'data-navbar';
var ITEM_ID_ATTR_NAME = 'data-navbar-item-id';
var ITEM_MATCHER_ATTR_NAME = 'data-navbar-item-matcher';
var VIEW_ID_ATTR_NAME = 'data-navbar-view-id';
var ACTIVE_ID_ATTR_NAME = 'data-navbar-active-id';
var HISTORY_POS_ATTR_NAME = 'data-navbar-history-position';
var CLASSNAME_ACTIVE = 'active';
var OVERFLOW_MENU_ID = 'navbar-overflow-menu';
var STICKY_WRAPPER_ATTR_NAME = 'data-sticky-fixed-wrapper';

var APPLICATION_MODEL_URI = 'spotify:application';

var isDesktop = !!global._getSpotifyModule;

var navbarOverflowItems;
var isShowingNavbarOverflow;
var shouldShowNavbarOverflow;

var getSelector = function getSelector(name, opt_operator, opt_matcher) {
  if (opt_operator && opt_matcher) return '[' + name + opt_operator + '"' + opt_matcher + '"' + ']';
  return '[' + name + ']';
};

var handleClick = function handleClick(event, tab) {
  var id = tab.getAttribute(ITEM_ID_ATTR_NAME);

  if (id === OVERFLOW_MENU_ID) {
    shouldShowNavbarOverflow = true;
    updateOverflowMenu();
    return;
  }

  activateItem(id);
  // Prevent any default click action (like link navigation)
  event.preventDefault();
};

var activateItem = function activateItem(id) {
  updateScrollPosition();

  var view = getView(id);
  var tabs = getTabsForId(id);

  // Set styles for navbar items and show/hide views
  setActive(id, tabs, view);
};

var onMessage = function onMessage(message) {
  if (message.data && message.data.name === 'navbar-overflow-click') {
    activateItem(message.data.itemId);
  }

  if (message.data && message.data.name === 'hide-navbar-overflow') {
    hideOverflow();
  }
};

var updateOverflowMenu = function updateOverflowMenu() {
  var moreMenuItem = document.querySelector('[data-navbar-item-id=navbar-overflow-menu]');
  if (!moreMenuItem) return;

  var canBeOpen = navbarOverflowItems && navbarOverflowItems.length;
  if (!canBeOpen) {
    shouldShowNavbarOverflow = false;
  }

  // There's no check for isShowingNavbarOverflow, the event is intentionally
  // resent on update, to support resizing.
  if (shouldShowNavbarOverflow) {
    isShowingNavbarOverflow = true;
    var descriptors = navbarOverflowItems.map(function (item) {
      var link = item.querySelector('a[href]');

      // The text is in the <a> element inside the item.
      return {
        name: item.firstElementChild && item.firstElementChild.textContent || '',
        id: item.getAttribute(ITEM_ID_ATTR_NAME),
        url: link && link.getAttribute('href'),
        active: item.classList.contains('active')
      };
    });

    var targetRect = moreMenuItem.getBoundingClientRect();
    global.top.postMessage({
      type: 'show-navbar-overflow',
      items: descriptors,
      right: targetRect.right,
      top: targetRect.bottom
    }, '*');
  }

  if (!shouldShowNavbarOverflow && isShowingNavbarOverflow) {
    isShowingNavbarOverflow = false;
    global.top.postMessage({
      type: 'hide-navbar-overflow'
    }, '*');
  }
};

var hideOverflow = function hideOverflow() {
  if (isShowingNavbarOverflow) {
    shouldShowNavbarOverflow = false;
    updateOverflowMenu();
  }
};

var getViews = function getViews() {
  var views = document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));
  return Array.prototype.slice.call(views);
};

var getTabs = function getTabs() {
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));
  return Array.prototype.slice.call(tabs);
};

var getTabsForId = function getTabsForId(tabId) {
  if (!tabId) {
    return [];
  }
  // This is intentionally selecting on all of the document
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME, '=', tabId));
  return Array.prototype.slice.call(tabs);
};

var getActiveTab = function getActiveTab() {
  var navbar = getNavbar();
  if (!navbar) return;
  var activeTabId = navbar.getAttribute(ACTIVE_ID_ATTR_NAME);
  var activeTabs = getTabsForId(activeTabId);
  return activeTabs[0];
};

var getView = function getView(id) {
  return document.querySelector(getSelector(VIEW_ID_ATTR_NAME, '=', id));
};

var getFirstTabId = function getFirstTabId() {
  var tab = document.querySelector(getSelector(ITEM_ID_ATTR_NAME));
  if (tab) {
    if (tab.getAttribute(ITEM_ID_ATTR_NAME) === OVERFLOW_MENU_ID) {
      return null;
    }
    return tab.getAttribute(ITEM_ID_ATTR_NAME);
  }
  return null;
};

var setActiveForMatchingId = function setActiveForMatchingId(ids) {
  // Off the list of passed ids, find the first one that matches a tab, then set
  // that one as active.
  var count = 0;
  var tabs;
  var id;
  while (count < ids.length && (!tabs || !tabs.length)) {
    if (ids[count]) {
      id = ids[count];
      tabs = getTabsForId(id);
    }
    count++;
  }
  var useID = id;

  if (!tabs || !tabs.length) {
    return;
  }
  var view = getView(useID);

  setActive(useID, tabs, view);
};

var setActive = function setActive(id, tabs, view) {
  var currentActiveTab = getActiveTab();
  var currentActiveId = currentActiveTab && currentActiveTab.getAttribute(ITEM_ID_ATTR_NAME);

  // Abort if the new tab is already active
  if (currentActiveId === id) return;

  setActiveTabs(id, tabs);
  setActiveView(id, view);

  center.emit('navbar-change', { id: id });
};

var setActiveTabs = function setActiveTabs(id, tabs) {
  var navbar = getNavbar();
  if (!navbar) return;

  navbar.setAttribute(ACTIVE_ID_ATTR_NAME, id);

  tabs.forEach(function (tab) {
    tab.classList.add(CLASSNAME_ACTIVE);
  });

  // Remove the active class name from all tabs except the ones that should be active
  var tabs = getTabs();
  if (tabs.length) {
    tabs.forEach(function (_tab) {
      if (_tab.getAttribute(ITEM_ID_ATTR_NAME) !== id) {
        _tab.classList.remove(CLASSNAME_ACTIVE);
      }
    });
  }
};

var setActiveView = function setActiveView(id, view) {
  if (!view) {
    return;
  }

  var views = getViews();

  // Hide all views except the one that should be active
  for (var i = 0, l = views.length; i < l; i++) {
    if (views[i] !== view[0]) {
      hide(views[i]);
    }
  }

  show(view);
};

var hide = function hide(element) {
  element.style.display = 'none';
};
var show = function show(element) {
  element.style.display = 'block';
};

var updateForNode = function updateForNode(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  live(APPLICATION_MODEL_URI).query('appURI, arguments', function (error, data) {
    if (error) throw error;

    var uri = fixAppURI(data.appURI);
    var fullAppURI = uri;
    if (data.arguments) {
      fullAppURI += ':' + data.arguments;
    }
    var id = getIdFromMatchers(fullAppURI);

    if (id) {
      // This is only the case when matchers (ITEM_MATCHER_ATTR_NAME) are used in DOM.
      setActiveForMatchingId([id]);
    } else {
      // For cases where id is only to be matched from one argument, find the id to
      // highlight by looking at the argument at HISTORY_POS_ATTR_NAME.
      var argumentIndex = +navbar.getAttribute(HISTORY_POS_ATTR_NAME) || 0;
      var idAtArgumentIndex = data.arguments.split(':')[argumentIndex];

      // For cases where nothing matches, also pass the first tab ID. This is
      // how the first tab is highlighted by default.
      var firstTabId = getFirstTabId();

      setActiveForMatchingId([fullAppURI, idAtArgumentIndex, firstTabId]);
    }
  });
};

function updateForOverflow(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  var itemSelector = '[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)';
  var items = node.querySelectorAll(itemSelector);
  if (!items) return;

  items = Array.prototype.slice.call(items);

  var overflowMenuButton = navbar.querySelector('.overflow-menu-button');

  // If we have less than two items, only show the navbar and be done. We need
  // at least two items for messurement and chances are a "more" menu won't be
  // needed.
  if (items.length < 2) {
    navbar.style.visibility = 'visible';
    if (overflowMenuButton) overflowMenuButton.style.display = 'none';
    return;
  }

  var navbarWidth = getWidth(navbar);
  if (!navbarWidth) {
    // The navbar isn't rendered. Bail out.
    return;
  }

  // Reset to the initial rendering state to be able to measure items.
  if (overflowMenuButton) overflowMenuButton.style.display = 'inline';

  items.forEach(function (item, i) {
    item.style.display = 'block';
    item.classList.remove('last-visible');
  });

  var sizing = measureNavbar(items, overflowMenuButton);

  // If stuff doesn't completely fit, reduce the available space by the "more"
  // menu with, then calculate what needs to go in it.
  var availableSpace = navbarWidth;
  var firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  var needsMoreMenu = items.length !== firstOverflown;

  if (needsMoreMenu) {
    availableSpace -= sizing.overflowMenuButtonWidth;
    firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  }

  if (!navbarOverflowItems) {
    navbarOverflowItems = [];
  }
  navbarOverflowItems.length = 0;

  items.forEach(function (item, i) {
    var shouldBeInOverflow = i >= firstOverflown;
    if (shouldBeInOverflow) navbarOverflowItems.push(item);

    // If we don't draw an overflow menu, set the last-visible class on the
    // very last item so its margin-right is removed.
    var isLastInNotOverflown = !needsMoreMenu && i === items.length - 1;

    item.style.display = shouldBeInOverflow ? 'none' : 'block';
    item.classList.toggle('last-visible', isLastInNotOverflown);
  });

  if (overflowMenuButton) {
    overflowMenuButton.style.display = needsMoreMenu ? 'inline' : 'none';
  }

  // Update items and position, possibly close the menu
  updateOverflowMenu();
  navbar.style.visibility = 'visible';
}

function updateScrollPosition() {
  var scrollTop = window.pageYOffset;
  var stickyElements = Array.prototype.slice.call(document.querySelectorAll('[' + STICKY_WRAPPER_ATTR_NAME + ']'));

  if (stickyElements.length === 0) return;

  // Get the `top` value of a sticky element that is
  // in a fixed position (negative value)
  // and the closest to the top (smallest top value).
  var topTarget = stickyElements.reduce(function (res, el) {
    var top = el.getBoundingClientRect().top;
    return top < res ? top : res;
  }, 0);

  if (topTarget < 0) {
    // Add 1 px to have the sticky element in fixed position.
    window.scrollTo(0, topTarget + scrollTop + 1);
  }
}

function handleResize() {
  updateForOverflow(document.body);
}

function measureNavbar(items, overflowMenuButton) {
  // Find out what the margin per item is my messuring beween the first 2 items.
  var item1 = items[0];
  var item2 = items[1];

  var right1 = Math.floor(item1.getBoundingClientRect().right);
  var left2 = Math.floor(item2.getBoundingClientRect().left);
  var marginPerSide = (left2 - right1) / 2;

  var itemWidths = [];
  if (items) {
    itemWidths = items.map(function (item, i, all) {
      var marginLeft = i === 0 ? 0 : marginPerSide;
      var marginRight = i === all.length - 1 ? 0 : marginPerSide;
      return getWidth(item) + marginLeft + marginRight;
    });
  }

  // When the overflowMenuButton is showns, it's always at the end, so it has
  // no right margin.
  var overflowMenuButtonWidth = 0;
  if (overflowMenuButton) {
    overflowMenuButtonWidth = getWidth(overflowMenuButton) + marginPerSide;
  }

  return {
    itemWidths: itemWidths,
    overflowMenuButtonWidth: overflowMenuButtonWidth
  };
}

function getWidth(element) {
  return element && element.offsetWidth || 0;
}

function getFirstOverflownIndex(space, sizes) {
  var count = 0;
  var used = 0;
  while (sizes[count] !== undefined && used < space) {
    used += sizes[count];
    // This is actually expected to return up to .length of the sizes.
    // That will be the case when everything fits.
    count++;
  }
  if (used < space) return count;
  return count - 1;
}

// Hack to get around bridge bug (reported at WP-471) where WP reports
// the uri with the arguments as well.
var fixAppURI = function fixAppURI(uri) {
  return uri.split(':').slice(0, 3).join(':');
};

// Matchers allow you to tell a tab to be active for a pattern of the app arguments.
// If you define data-navbar-item-matcher="user:.*?:playlist:.*$" you tell the tab
// to be active when the arguments match that regexp.
var storedMatchers = {};
var getMatchers = function getMatchers(node) {
  var matchers = node.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));
  if (!matchers.length) return;

  matchers = Array.prototype.slice.call(matchers);
  matchers.forEach(function (matcher) {
    var regexp = matcher.getAttribute(ITEM_MATCHER_ATTR_NAME);
    var id = matcher.getAttribute(ITEM_ID_ATTR_NAME);
    storedMatchers[regexp] = id;
  });
};

var getIdFromMatchers = function getIdFromMatchers(uri) {
  for (var regexp in storedMatchers) {
    if (storedMatchers.hasOwnProperty(regexp)) {
      var regexpObj = new RegExp(regexp);
      if (regexpObj.test(uri)) return storedMatchers[regexp];
    }
  }
  return null;
};

var getNavbar = function getNavbar(opt_node) {
  var node = opt_node || document.documentElement;
  var selector = getSelector(NAVBAR_ATTR_NAME);
  return node.matches(selector) ? node : node.querySelector(selector);
};

var onApplicationChange = function onApplicationChange(event) {
  if ('arguments' in event || 'active' in event) {
    updateForNode(document.documentElement);
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateForNode(node || document.documentElement);
  getMatchers(node || document.documentElement);
  updateForOverflow(node || document.documentElement);
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.addEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).on('update', onApplicationChange);
  window.addEventListener('resize', handleResize);
  center.on('navbar-hide', hideOverflow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  navbarOverflowItems = null;
  isShowingNavbarOverflow = false;
  shouldShowNavbarOverflow = false;

  $(document).undelegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.removeEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).off('update', onApplicationChange);
  window.removeEventListener('resize', handleResize);
  center.off('navbar-hide', hideOverflow);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":142,"../spotify-live":312,"./center":150}],168:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var sessionModel;

function onSessionUpdate(properties) {
  if ('online' in properties) {
    if (properties.online) {
      $(document.body).removeClass('offline');
    } else {
      $(document.body).addClass('offline');
    }
  }
}

function updateWithSessionValue() {
  live('spotify:client').query('session(online)', function (error, data) {
    if (error) throw error;
    onSessionUpdate({ online: data.session.online });
  });
}

var isAttached = false;

exports.update = function () {
  if (!isAttached) return;

  updateWithSessionValue();
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  if (!sessionModel) {
    live('spotify:client').get('session', function (error, session) {
      if (error) throw error;
      sessionModel = session;
      sessionModel.on('update', onSessionUpdate);
    });
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (sessionModel) {
    sessionModel.off('update', onSessionUpdate);
    sessionModel = null;
  }
};

},{"../spotify-elements":142,"../spotify-live":312}],169:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var cosmos = require('spotify-cosmos-api');

var $ = require('../../spotify-elements');
var utils = require('./utils');

var SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

// This array will store event types for touch handling
var lastEventTypes = [];

// Methods that need implementation from another module.
// This is to support generic handling of user actions from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of starting playback for example.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
  handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
};

/**
 * Handle the click of a play button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {Elements} button An element instance from the `elements` package.
 *
 * @private
 */
function handlePlayButtonClick(event, button) {
  var buttonNode = button[0];
  var buttonContextUri = utils.getUriFromButton(buttonNode);

  // We need an associated context URI for the button
  if (!buttonContextUri) {
    return;
  }

  var playerContextUri = methods.getPlayerVariantUri();
  var isPlayingContext = utils.compareContexts(playerContextUri, buttonContextUri);

  var source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

  methods.handlePlayButton(buttonNode, {
    isPlayingContext: isPlayingContext,
    contextUri: buttonContextUri,
    source: source,
    reason: 'playbtn'
  });
}

/**
 * Handle the double click or tap of a list row to start playback.
 *
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleListRow(row) {
  var contextNode = row.parent('[data-context]');
  if (contextNode) {
    var rowNode = row[0];
    var source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
    methods.handlePlayFromRow(rowNode, {
      contextUri: contextNode.data('uri'),
      source: source,
      reason: 'clickrow'
    });
  }
}

/**
 * Handle double clicking on a list row to start playback.
 *
 * @param {MouseEvent} event An event object for a double click.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowDoubleClick(event, row) {
  // Only play when not clicking on interactive elements such as buttons
  if (!utils.isInteractiveElement(event.target)) {
    handleListRow(row);
  }
}

/**
 * Handle a key press on a list row.
 * This will take care of starting playback when pressing Enter.
 *
 * @param {KeyboardEvent} event A keyboard event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowKeyDown(event, row) {
  var isEnter = event.keyCode === 13;
  if (isEnter) {
    if (utils.isFormOrLinkElement(event.target)) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    handleListRow(row);
  }
}

/**
 * Handle the 'contextmenu' event. This is only for touch handling.
 * This is needed since we use a custom context menu in Spotify, and the handler
 * for that calls `preventDefault` for the 'contextmenu' event, which means the
 * rest of the touch handling will go on as usual. So as we don't get the
 * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
 * that we should not act on the following 'touchend' event.
 *
 * @param {MouseEvent} event A 'contextmenu' event.
 *
 * @private
 */
function handleContextMenu(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the start of a touch. Used to detect a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchStart(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the move of a touch. Used to abort detection of a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchMove(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the end of a touch. Used to detect a tap and start playback of a row.
 *
 * @param {TouchEvent} event A touch event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowTouchEnd(event, row) {
  // If this was a tap (only touchstart was triggered before this)
  if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {

    // Prevent the simulated mouse events (including click). This is to
    // avoid the simulated click event to click on the play button that
    // appears when selecting a row on touchstart.
    // See: https://jira.spotify.net/browse/KM-7983
    if (!utils.isInteractiveElement(event.target)) {
      event.preventDefault();

      // Tapping on a row should play it
      handleListRow(row);
    }
  }
  lastEventTypes = [];
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  var doc = $(document);

  doc.delegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.delegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.delegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.delegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.delegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.delegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.delegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.delegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Detach the event listeners for the module.
 */
exports.detach = function () {
  var doc = $(document);

  doc.undelegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.undelegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.undelegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.undelegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.undelegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.undelegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.undelegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.undelegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Set the external methods for this module to add implementations for starting
 * playback etc.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":142,"./utils":172,"spotify-cosmos-api":554}],170:[function(require,module,exports){
'use strict';

var playerWithIndices = require('./withIndices');
var playerWithUids = require('./withUids');

var playerModule = playerWithIndices;

exports.setMode = function (type) {
  switch (type) {
    case 'indices':
      playerModule = playerWithIndices;
      break;
    case 'uids':
      playerModule = playerWithUids;
      break;
  }
};

exports.attach = function () {
  playerModule.attach();
};

exports.detach = function () {
  playerModule.detach();
};

exports.update = function (optNode) {
  playerModule.update(optNode);
};

},{"./withIndices":173,"./withUids":174}],171:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var difference = require('mout/array/difference');
var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

var center = require('../center');
var utils = require('./utils');

var CURRENT = 'current';
var PAUSED = 'paused';
var PLAYING = 'playing';

var LOG_PLAY_BUTTON = 'play-button';
var LOG_PAUSE_BUTTON = 'pause-button';

var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
var SELECTOR_ALL_PLAY_BUTTONS = SELECTOR_PLAY_BUTTON + ',' + SELECTOR_PLAY_CONTEXT_BUTTON;

// Methods that need implementation from another module.
// This is to support generic handling of DOM updates from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of highlighting playing objects.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
  getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

  // This should be a function that takes a function as the first argument. That
  // function argument should be called whenever the player state has changed.
  subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
};

var playableChangeHandlers = {};
var playerSubscription = null;

/**
 * Update states in the DOM based on current player state.
 *
 * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
 *     of that node will be updated.
 */
function updateDOM(optNode) {
  var containerNode = optNode || document;

  updateButtonsBasedOnPlayable(containerNode);

  var playingNodes = getPlayingNodes(containerNode);
  var currentNodes = getCurrentNodes(containerNode);

  if (currentNodes) {
    var nodesForRemoval = currentNodes;
    if (playingNodes) {
      nodesForRemoval = difference(currentNodes, playingNodes);
    }
    nodesForRemoval.forEach(removePlayingStateFromNode);
  }

  if (playingNodes) {
    var nodesForAddition = playingNodes;
    if (currentNodes) {
      nodesForAddition = difference(playingNodes, currentNodes);
    }
    nodesForAddition.forEach(addPlayingStateToNode);

    var nodesForUpdate = difference(playingNodes, nodesForAddition);
    nodesForUpdate.forEach(updatePlayingStateForNode);
  }
}

/**
 * Update the playable status of all play buttons found inside the passed
 * container node.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @private
 */
function updateButtonsBasedOnPlayable(containerNode) {
  // `[data-button=play]` buttons are used to play something specific *in* a
  // context (defining an index as a track number or uid/uri or range).
  // Those are currently not updated themselves, instead their rows are being
  // set to `.unavailable`.
  var buttons = $(containerNode).search('[data-button=play-context]');
  if (buttons) {
    buttons.forEach(updateButtonBasedOnPlayable);
  }
}

/**
 * Update the playable status of the passed button.
 *
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function updateButtonBasedOnPlayable(button) {

  // Play buttons in list rows should not be handled, as the buttons are
  // hidden by CSS anyway for unplayable rows.
  if (!!$(button).parent('[data-list-item]')) {
    return;
  }

  var contextURI = utils.getUriFromButton(button);

  // Check if the context has a playable flag specified.
  var playableValue = live(contextURI).get('playable');
  var definesPlayable = playableValue != undefined;

  // If it does, update the `disabled` attribute based on it
  if (definesPlayable) {
    if (playableValue) {
      button.removeAttribute('disabled');
    } else {
      button.setAttribute('disabled', 'disabled');
    }

    if (!playableChangeHandlers[contextURI]) {
      playableChangeHandlers[contextURI] = function (changed) {
        if (!changed.hasOwnProperty('playable')) return;
        // Update all buttons currently in DOM when `playable` changes on a
        // context. Not worth adding logic to only pick out buttons pointing to
        // a specific URI.
        updateButtonsBasedOnPlayable(document.body);
      };
      live(contextURI).on('update', playableChangeHandlers[contextURI]);
    }
  }
}

/**
 * Get the nodes inside the passed container node that are currently marked as
 * playing.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getCurrentNodes(containerNode) {
  return $(containerNode).search('[data-playback-active=true]');
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing based on the current player state.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getPlayingNodes(containerNode) {
  var variantUri = methods.getPlayerVariantUri();
  var selectors = utils.getContextSelectorsWithVariants(variantUri);

  var contextNodes = $(containerNode).search(selectors.join(', '));
  if (contextNodes) {
    contextNodes = Array.prototype.slice.call(contextNodes);
  } else {
    contextNodes = [];
  }

  // Pass it through the outside implementation, which might filter out
  // nodes from `contextNodes` and add more nodes to the match.
  return methods.getPlayingNodes(containerNode, contextNodes);
}

/**
 * Remove the playing state from the passed DOM node, as it's no longer playing.
 *
 * @param {HTMLElement} node The DOM node to remove state from.
 *
 * @private
 */
function removePlayingStateFromNode(node) {
  var className = [CURRENT, PAUSED, PLAYING].join(' ');
  node = $(node);
  node.removeClass(className).removeAttribute('data-playback-active');

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', LOG_PLAY_BUTTON);
  }
}

/**
 * Add the playing state to the passed DOM node, as it's now playing.
 *
 * @param {HTMLElement} node The DOM node to add state to.
 *
 * @private
 */
function addPlayingStateToNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

  node = $(node);
  node.addClass(classNames).data('playback-active', true);

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Update the playing state for the passed DOM node, as it's still representing
 * the currently playing context, but the player might switch between
 * playing/paused.
 *
 * @param {HTMLElement} node The DOM node to update state for.
 *
 * @private
 */
function updatePlayingStateForNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var currentClassName = isPlaying ? PAUSED : PLAYING;
  var newClassName = isPlaying ? PLAYING : PAUSED;
  var element = $(node);

  if (element.hasClass(currentClassName)) {
    element.removeClass(currentClassName);
  }

  if (!element.hasClass(newClassName)) {
    element.addClass(newClassName);
  }

  if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Handle updating of DOM nodes when they have been added to the DOM by a scroll
 * agent.
 *
 * @param {Object} event Custom event object sent from the scroll agent. Should
 *     contain a `container` property pointing to the DOM node containing the
 *     rows.
 *
 * @private
 */
function handleScrollShowAfter(event) {
  var container = $(event.container);
  var contextNode = null;
  if (container.matches('[data-context]')) {
    contextNode = container;
  } else {
    contextNode = container.parent('[data-context]');
  }

  // We can't pass the context node itself as root because of how the playing
  // state queries are set up.
  var contextParent = contextNode && contextNode[0].parentElement || document;

  updateDOM(contextParent);
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  playerSubscription = methods.subscribeToPlayerChange(function () {
    updateDOM();
  });

  center.on('scroll-show-after', handleScrollShowAfter);
};

/**
 * Detach the needed event listeners for the module.
 */
exports.detach = function () {
  if (playerSubscription) {
    playerSubscription.cancel();
    playerSubscription = null;
  }

  for (var contextUri in playableChangeHandlers) {
    if (playableChangeHandlers.hasOwnProperty(contextUri)) {
      live(contextUri).off('update', playableChangeHandlers[contextUri]);
    }
  }
  playableChangeHandlers = {};

  center.off('scroll-show-after', handleScrollShowAfter);
};

/**
 * Update things in the DOM.
 */
exports.update = updateDOM;

/**
 * Set the external methods for this module to add implementations for methods
 * needed for highlighting playing objects.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":142,"../../spotify-live":312,"../center":150,"./utils":172,"mout/array/difference":464}],172:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module might be used by modules outside of spotify-events.
 * @public
 */

var liburi = require('spotify-liburi');
var $ = require('../../spotify-elements');

var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

/**
 * Get the context URI from a button node or its parents.
 *
 * @param {HTMLElement} button A DOM node for a button.
 *
 * @return {string} The context URI or empty string if not found.
 */
function getUriFromButton(button) {
  var contextNode = button.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node or
 * from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeValueFromNode(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

/**
 * Check if the passed element is a form or link element.
 *
 * @param {HTMLElement} element A DOM node.
 *
 * @return {boolean} True if it is a form or link element.
 */
function isFormOrLinkElement(element) {
  var tagName = element.tagName.toLowerCase();
  var elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
  return elements.indexOf(tagName) > -1;
}

/**
 * Check if the passed element is an interactive element (links, buttons).
 *
 * @param {HTMLElement}  element A DOM node.
 *
 * @return {boolean} True if the element is interactive.
 */
function isInteractiveElement(element) {
  var tagName = element.tagName.toLowerCase();
  return tagName === 'a' || tagName === 'button';
}

/**
 * Get a CSS selector string for a context.
 *
 * @param {string} operator A CSS selector operator ($= or similar).
 * @param {string} uri The context URI.
 *
 * @return {string} The CSS selector string.
 */
function getContextSelector(operator, uri) {
  return '[data-context][data-uri' + operator + uri + ']';
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 *
 * @param {string} uri The context URI to search for. This should be the
 *     currently playing variant URI (for example, when playing a sorted
 *     playlist the sorted URI should be passed).
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectors(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  var selectors = [getContextSelector(SAME, uri)];

  var normalized = normalizeUri(uri);
  if (uri !== normalized) {
    selectors.push(getContextSelector(SAME, normalized));
  }

  return selectors;
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 * This also includes any variant of the passed context URI. For example, if
 * passing a sorted playlist URI, it will return selectors for matching all
 * variations of that playlist URI, including the regular playlist URI, filtered
 * URI etc.
 *
 * @param {string} uri The context URI to search for. This can be either the
 *     origin URI, or any variant URI. The function will convert it to the
 *     origin URI automatically.
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectorsWithVariants(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  // Only add the ENDSWITH selectors. Those also match the original.
  // When it's a sorted and/or filtered list, just use the origin.
  var endsWith = getOriginUri(uri) || uri;
  var endsWithNormalized = normalizeUri(endsWith);

  var selectors = [getContextSelector(ENDSWITH, endsWith.replace(/^spotify:/, ':'))];

  if (endsWith !== endsWithNormalized) {
    selectors.push(getContextSelector(ENDSWITH, endsWithNormalized.replace(/^spotify:/, ':')));
  }

  return selectors;
}

/**
 * Check if two context URIs are representing the same context. This will take
 * care of normalizing the casing of URL encoding and filtered/sorted contexts.
 *
 * @param {string} context1 The first context.
 * @param {string} context2 The second context.
 *
 * @return {boolean} True if they represent the same context.
 */
function compareContexts(context1, context2) {
  if (!context1 || !context2) return false;

  context1 = normalizeUri(getOriginUri(context1) || context1);
  context2 = normalizeUri(getOriginUri(context2) || context2);

  return context1 === context2;
}

/**
 * A URI might contain URL encoded characters, and per spec the URL encoding can
 * be either in lowercase or uppercase (should be treated as same URL). If the
 * input URL has lowercase encoding, liburi will convert it into uppercase
 * encoding.
 *
 * @param {string} uri The URI to normalize.
 *
 * @return {string} The normalized URI.
 */
function normalizeUri(uri) {
  var uriObj = liburi.from(uri);
  var normalized = uriObj ? uriObj.toString() : uri;

  // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
  // since it does not recognize `internal` URIs, and therefore uses the default
  // `app` type.
  normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

  // Work around the bad conversion of spaces in filtered list URIs. The URI
  // spec we use says that spaces should be encoded as `+`, but the `filterlist`
  // URI uses the regular `%20` encoding for spaces. Passing it through liburi
  // converts it to `+`, so we need to convert it back to `%20` again.
  normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
    return match.replace(/\+/g, '%20');
  });

  return normalized;
}

/**
 * Create an empty method that will only log a warning when called.
 *
 * @param {string} methodName The name of the method to warn about.
 *
 * @return {Function} The function.
 */
function createEmptyMethod(methodName) {
  return function () {
    if (global.console) {
      console.warn('spotify-events/player: `' + methodName + '` is not implemented.');
    }
  };
}

exports.getUriFromButton = getUriFromButton;
exports.getAttributeValueFromNode = getAttributeValueFromNode;
exports.isFormOrLinkElement = isFormOrLinkElement;
exports.isInteractiveElement = isInteractiveElement;
exports.getContextSelector = getContextSelector;
exports.getContextSelectors = getContextSelectors;
exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
exports.compareContexts = compareContexts;
exports.normalizeUri = normalizeUri;
exports.createEmptyMethod = createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":142,"../../spotify-live-wrapped-uri":311,"spotify-liburi":563}],173:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');
var find = require('mout/array/find');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing track within the playing context.
 *
 * @return {number} The index, or -1 if not found.
 */
function getPlayerIndex() {
  var indexObject = live('spotify:player').get('index');
  return indexObject ? indexObject.get('track') : -1;
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the player is currently shuffling the context.
 *
 * @return {boolean} True if shuffling.
 */
function getPlayerIsShuffling() {
  var options = live('spotify:player').get('options');
  var shufflingContext = options && options.get('shufflingContext');
  return !!shufflingContext;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var button = $(buttonNode);
  var playerIndex = getPlayerIndex();
  var range;
  var newIndex;
  var uids;
  var uris;

  var dataRange = button.data('range');
  if (dataRange) {
    range = Range.fromString(dataRange);
    var list = live(data.contextUri).get('rows');
    if (list) {
      var indices = range.toIndices();
      uids = indices.map(function (index) {
        return list.keys[index];
      });
      uris = indices.map(function (index) {
        var track = list.get(index).get('track');
        return track.uri;
      });
    }
    newIndex = null;
  } else {
    var contextIndexNode = null;
    if (button.matches('[data-context-index]')) {
      contextIndexNode = button;
    } else {
      contextIndexNode = button.parent('[data-context-index]');
    }

    if (contextIndexNode) {
      newIndex = parseInt(contextIndexNode.data('context-index'), 10);
      var list = live(data.contextUri).get('rows');
      if (list) {
        uids = [list.keys[newIndex]];
        uris = [list.get(newIndex).get('track').uri];
      }
    } else {
      newIndex = null;
    }
  }

  var shouldPauseResume = false;

  if (data.isPlayingContext) {
    if (range) {
      // null or undefined
      if (playerIndex == null) {
        shouldPauseResume = false;
      } else {
        shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
      }
    } else if (newIndex != null) {
      shouldPauseResume = newIndex === playerIndex;
    } else {
      shouldPauseResume = true;
    }
  }

  if (shouldPauseResume) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    var eventData = {
      context: data.contextUri,
      index: newIndex,
      source: data.source,
      reason: data.reason
    };

    if (range) {
      eventData.range = [range.start, range.end];
    }

    if (uids) {
      eventData.uids = uids;
    }

    if (uris) {
      eventData.uris = uris;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var index = parseInt(rowNode.getAttribute('data-context-index'), 10);
  if (isNaN(index)) {
    index = -1;
  }
  var uid = rowNode.getAttribute('data-uid') || '';
  var uri = rowNode.getAttribute('data-uri') || '';

  var eventData = {
    context: data.contextUri,
    index: index,
    source: data.source,
    reason: data.reason
  };

  if (uid) {
    eventData.uids = [uid];
  }

  if (uri) {
    eventData.uris = [uri];
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerIndex = getPlayerIndex();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a range specified and where
  // the current player index does not match.
  var filteredContextNodes = filterRanges(playerIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

  var rowNodes = getContextNodesForRows(containerNode, selectors, playerIndex, playerTrackUri) || [];

  var rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 * @param {string} trackUri The URI of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, index, trackUri) {
  var isShuffling = getPlayerIsShuffling();

  // When playing from this client, we highlight the playing index if the
  // playing variant and the list variant are exactly the same.
  //
  // Removed support for connect as we can no longer detect a connect session: KM-9645.

  var useIndexSelector = !isShuffling;
  var useTrackSelector = !!trackUri;

  var selector = selectors.map(function (selector) {
    if (useIndexSelector || useTrackSelector) selector += ' ';
    if (useIndexSelector) selector += '[data-context-index=' + index + ']';
    if (useTrackSelector) selector += '[data-uri="' + trackUri + '"]';
    return selector;
  }).join(', ');

  var nodes = selector && $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (isShuffling) {
      // As the lax matching used in this case might yield duplicate rows in a
      // single list, we must filter out those.
      nodes = nodes.filter(function (row, i) {
        var listNode = $(row).parent('[data-list]');
        // If this row is not the first row to be highlighted in this list,
        // filter it out.
        return row === find(nodes, function (row) {
          return listNode === $(row).parent('[data-list]');
        });
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching range specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRanges(containerNode, selectors, index) {
  var rangeAttribute = '[data-range]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var rangeInContextSelector = selector + ' ' + rangeAttribute;
    var rangedContextSelector = selector + rangeAttribute;
    var rangeSelector = rangeInContextSelector + ', ' + rangedContextSelector;
    return rangeSelector;
  });

  var rangeNodes = $(containerNode).search(selectors.join(', '));
  if (rangeNodes) {
    rangeNodes = Array.prototype.slice.call(rangeNodes);
  } else {
    rangeNodes = [];
  }

  return filterRanges(index, rangeNodes);
}

/**
 * Return a new array of nodes where nodes that specify a range that doesn't
 * match the currently playing index are removed.
 *
 * @param {number=} index The currently playing index. Can be undefined/null.
 * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function filterRanges(index, nodes) {
  var thisRange = index != null ? new Range(index, index + 1) : null;

  return nodes.filter(function (node) {
    node = $(node);
    var range = node.data('range');

    // Node without a range should always be active
    if (!range) return true;

    // If player has no index, but the node has a range, we can't be sure if
    // it's playing
    if (!thisRange) return false;

    range = Range.fromString(range);
    return range.contains(thisRange);
  });
}

},{"../../spotify-elements":142,"../../spotify-live":312,"../../spotify-range2":352,"./actions":169,"./updates":171,"./utils":172,"mout/array/find":468}],174:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing page.
 *
 * @return {number} The page index, or -1 if not found.
 */
function getPlayerPageIndex() {
  var indexObject = live('spotify:player').get('index');
  var pageIndex = indexObject && indexObject.get('page');
  var hasPageIndex = typeof pageIndex === 'number';
  return hasPageIndex ? pageIndex : -1;
}

/**
 * Get the UID of the currently playing track.
 *
 * @return {string} The UID, or empty string if not found.
 */
function getPlayerTrackUid() {
  return live('spotify:player').get('uid') || '';
}

/**
 * Get the uri of the currently playing track.
 *
 * @return {string} The uri, or empty string if not found.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track ? track.get('uri') || '' : '';
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the playback was initiated from open.spotify.com
 *
 * This info is needed to be able to do a best-effort of highlighting rows when
 * playing from open.
 *
 * @return {boolean} True if playing from open.spotify.com.
 */
function getPlayerIsPlayingFromOpen() {
  var playOrigin = live('spotify:player').get('playOrigin');
  var externalReferrer = playOrigin && playOrigin.get('externalReferrer');

  return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var isPlaying = data.isPlayingContext;

  var button = $(buttonNode);

  var trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
  var trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
  var pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

  if (isPlaying) {
    isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
  }

  if (isPlaying) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {

    var eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    if (trackUid) {
      eventData.uid = trackUid;
    }

    if (trackUri) {
      eventData.trackUri = trackUri;
    }

    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Verify that a uid, uri or pageIndex is playing, or that just the context
 * is playing when none of that is set.
 * This is used when we already know that we're playing the context.
 *
 * @param {string} trackUid
 * @param {string} trackUri
 * @param {number} pageIndex
 *
 * @return {boolean} True if it's really playing
 */
function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
  if (trackUid) {
    var playerTrackUid = getPlayerTrackUid();
    return playerTrackUid === trackUid;
  }

  if (trackUri) {
    var playerTrackUri = getPlayerTrackUri();
    return playerTrackUri === trackUri;
  }

  if (!isNaN(pageIndex)) {
    var playerPageIndex = getPlayerPageIndex();
    return playerPageIndex === pageIndex;
  }

  // No index given also means it's really playing.
  return true;
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var eventData = {
    context: data.contextUri,
    source: data.source,
    reason: data.reason
  };

  var uid = rowNode.getAttribute('data-uid');
  if (uid) {
    eventData.uid = uid;
  }

  var pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
  if (!isNaN(pageIndex)) {
    eventData.page = pageIndex;
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerPageIndex = getPlayerPageIndex();
  var playerTrackUid = getPlayerTrackUid();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a page specified and where
  // the current player page does not match.
  var filteredContextNodes = filterPages(playerPageIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
  var pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {string} trackUid The UID of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {

  // When playing from this client, we highlight the playing UIDs.
  var useTrackSelector = getPlayerIsPlayingFromOpen();

  var selector = selectors.map(function (selector) {
    selector += ' ';
    if (useTrackSelector) selector += '[data-uri=' + trackUri + ']';
    if (!useTrackSelector) selector += '[data-uid=' + trackUid + ']';
    return selector;
  }).join(', ');

  var nodes = $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (useTrackSelector) {
      // Gets UID of the first node and find all the nodes
      // with the same UID
      var firstUid = $(nodes[0]).data('uid');
      nodes = nodes.filter(function (row, i) {
        return firstUid === $(row).data('uid');
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching page specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} playerPageIndex The currently playing page index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
  var pageAttribute = '[data-context-page]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var pageInContextSelector = selector + ' ' + pageAttribute;
    var pagedContextSelector = selector + pageAttribute;
    var pageSelector = pageInContextSelector + ', ' + pagedContextSelector;
    return pageSelector;
  });

  var pageNodes = $(containerNode).search(selectors.join(', '));
  if (pageNodes) {
    pageNodes = Array.prototype.slice.call(pageNodes);
  } else {
    pageNodes = [];
  }

  return filterPages(playerPageIndex, pageNodes);
}

/**
 * Return a new array of nodes where nodes that specify a context page that
 * doesn't match the currently playing context page are removed.
 *
 * @param {number} playerPageIndex The currently playing page index.
 * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
 *
 * @return {Array.<HTMLElement>} Array of filtered nodes.
 */
function filterPages(playerPageIndex, contextNodes) {
  return contextNodes.filter(function (node) {
    var nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

    // Node without a page should always be active
    if (isNaN(nodePageIndex)) return true;

    // If player has no page, but the node has a page, we can't be sure if it's
    // playing.
    if (isNaN(playerPageIndex)) return false;

    // Node that matches the player page should be active
    return playerPageIndex === nodePageIndex;
  });
}

},{"../../spotify-elements":142,"../../spotify-live":312,"../../spotify-range2":352,"./actions":169,"./updates":171,"./utils":172}],175:[function(require,module,exports){
'use strict';

var Range = require('../spotify-range2');

var contains = require('mout/array/contains');

var $ = require('../spotify-elements');

var SYNC = require('prime/emitter').EMIT_SYNC;

var throttle = require('./util/throttle');
var ListManager = require('./util/ListManager.js');

var center = require('./center');

var doc = $(document);
var win = $(window);

var scrollContainers = [];
var listManagers = [];
var scrollHandlers = [];
var pendingScrollContainers = [];
var pendingHiddenIndices = [];
var cleanupHandlers = [];

var getBounds = function getBounds(view, container) {
  var dde = document.documentElement;

  if (view === window || view === document.body) view = dde;
  var viewTop = view === dde ? 0 : view.getBoundingClientRect().top;

  var viewHeight = view.clientHeight;
  var containerTop = container.getBoundingClientRect().top;
  var containerHeight = container.offsetHeight;

  var viewBox = {
    top: viewTop,
    height: viewHeight,
    bottom: viewTop + viewHeight
  };

  var containerBox = {
    top: containerTop,
    height: containerHeight,
    bottom: containerTop + containerHeight
  };

  return {
    view: viewBox,
    container: containerBox
  };
};

var getRange = function getRange(view, container, height, hotZone) {
  hotZone = hotZone || 0;
  var bounds = getBounds(view, container);
  var top = -(bounds.container.top - bounds.view.top);
  var startsAt = Math.floor((top - hotZone) / height);
  var endsAt = Math.ceil((top + bounds.view.height + hotZone) / height);
  if (startsAt < 0) startsAt = 0;
  if (endsAt <= startsAt) return false;
  return new Range(startsAt, endsAt);
};

var init = function init(view, container, length, height, tag) {
  var view0 = view[0];
  var container0 = container[0];

  container.addClass('scroll-container-enabled');

  var manager = new ListManager(container0, {
    height: height,
    length: length,
    tag: tag,
    debug: false,
    request: function request(range, callback) {
      center.emit('scroll-request', container0, range, callback, SYNC);
    }
  });
  listManagers.push(manager);

  // Update the manager with previously saved hidden indices.
  // This allows the scroller to take hidden indices into account even for the
  // first render.
  var pendingIndex = pendingScrollContainers.indexOf(container);
  if (pendingIndex > -1) {
    manager.reset(length, pendingHiddenIndices[pendingIndex]);
    pendingScrollContainers.splice(pendingIndex, 1);
    pendingHiddenIndices.splice(pendingIndex, 1);
  }

  manager.on('before-show', function (range, nodes) {
    center.emit('scroll-show-before', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('after-show', function (range, nodes) {
    center.emit('scroll-show-after', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('index-change', function (index) {
    center.emit('scroll-index-change', {
      pageNode: container,
      container: container,
      ranges: index
    }, SYNC);
  });

  var hasRequestedMore = false;

  var scroll = function scroll() {
    var bounds = getBounds(view0, container0);
    var show = getRange(view0, container0, height);

    if (show) {
      var padding = 2;
      show = new Range(show.start - padding, show.end + padding);
      manager.show(new Range(show.start, show.end));
    }

    // If the scroll position is close enough to the end, an event should be
    // emitted to allow for more content to be loaded. Not all lists will use this,
    // but some lists want to lazy load content by loading more when you reach the
    // bottom, and then they can listen for this event.
    if (!hasRequestedMore) {
      if (bounds.container.bottom < 2000) {
        hasRequestedMore = true;

        // Emit the event and also pass a callback to the event.
        // The receiver of this event should pass the new total length of the list
        // as the second argument to the callback.
        center.emit('scroll-request-more', container0, function (error, length) {
          if (error) throw error;
          hasRequestedMore = false;
          scrollReset(container0, length);
        });
      }
    }
  };

  scrollHandlers.push(scroll);

  scroll = container._scrollEvent = throttle(scroll);

  var scrollReset = function scrollReset(c, height, opt_hiddenIndices, opt_fromIndex) {
    if ($(c) === container) {
      var hasFromIndex = typeof opt_fromIndex === 'number';
      if (hasFromIndex && opt_fromIndex > 0) {
        manager.resetFrom(opt_fromIndex, height, opt_hiddenIndices);
      } else {
        manager.reset(height, opt_hiddenIndices);
      }
      scroll();
    }
  };

  center.on('scroll-reset', scrollReset);
  container._scrollResetEvent = scrollReset;

  var scrollToIndex = function scrollToIndex(c, index, opt_offsetScrollPosition) {
    if (view0 !== window) {
      throw new Error('Can\'t scroll to index if view is not `window`');
      return;
    }

    if ($(c) === container) {
      var bounds = getBounds(view0, container0);

      // Let's say we scroll the sidebar to show the playlist at 200px from
      // the top or the bottom (depending if it was above or below fold).
      // If the sidebar height is smaller than 400px, we vertically center the
      // playlist:
      var offset = Math.min(opt_offsetScrollPosition || 0, (bounds.view.height - manager.height) / 2);

      var indexTopRelativeToContainer = manager.height * index;
      var position = bounds.container.top + indexTopRelativeToContainer;

      var scrollY = position + window.pageYOffset;
      var stickyOffset = (doc.search('[data-sticky-active]') || []).map(function (sticky) {
        return sticky.offsetHeight;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);

      if (position <= stickyOffset) {
        // item is above viewport
        scrollY -= offset + stickyOffset;
      } else if (position + manager.height > bounds.view.height) {
        // item is below viewport
        scrollY += offset + manager.height - bounds.view.height;
      } else {
        // item is in viewport
        return;
      }

      view0.scrollTo(0, scrollY);
    }
  };

  center.on('scroll-to-index', scrollToIndex);

  view.on('scroll', scroll);
  win.on('resize', scroll);
  scroll();

  cleanupHandlers.push(function () {
    center.off('scroll-reset', scrollReset);
    center.off('scroll-to-index', scrollToIndex);
    view.off('scroll', scroll);
    win.off('resize', scroll);

    container.removeClass('scroll-container-enabled');
  });
};

function onScrollSetHidden(data) {
  var hiddenIndices = data.indices;

  var container = $(data.itemContainer);
  var index = scrollContainers.indexOf(container);
  if (index > -1) {
    var manager = listManagers[index];
    if (manager) {
      manager.reset(manager.length, hiddenIndices);
    }
    var scrollHandler = scrollHandlers[index];
    if (scrollHandler) {
      scrollHandler();
    }
  } else {
    pendingScrollContainers.push(container);
    pendingHiddenIndices.push(hiddenIndices);
  }
}

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || doc;

  var scrollNodes = doc.search('[data-scroll-container]');

  var handlers = [];
  var managers = [];
  scrollContainers = scrollContainers.filter(function (container, index) {
    if (!contains(scrollNodes, container[0])) {
      container._view.off('scroll', container._scrollEvent);
      win.off('resize', container._scrollEvent);
      center.off('scroll-reset', container._scrollResetEvent);
      delete container._scrollEvent;
      delete container._scrollResetEvent;
      return false;
    }
    managers.push(listManagers[index]);
    handlers.push(scrollHandlers[index]);
    return true;
  });
  listManagers = managers;
  scrollHandlers = handlers;

  if (node !== doc) scrollNodes = node.search('[data-scroll-container]');

  if (scrollNodes) scrollNodes.forEach(function (node0) {
    var container = $(node0);

    if (container._scrollEvent || node0.children.length) return;

    scrollContainers.push(container);
    var view = container.parent('[data-scroll-view]') || win;
    container._view = view;

    var callback = function callback(error, children, length) {
      if (error) throw error;
      children = $(children);
      children.insert(container);

      var second = children[1];
      var height = second.offsetHeight;
      var tag = $(second).tag();
      children.remove();
      init(view, container, length, height, tag);
    };

    center.emit('scroll-request', container[0], new Range(0, 3), callback, SYNC);
  });
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  center.on('scroll-set-hidden', onScrollSetHidden);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  center.off('scroll-set-hidden', onScrollSetHidden);

  cleanupHandlers.forEach(function (cleanupHandler) {
    cleanupHandler();
  });
  cleanupHandlers = [];
};

},{"../spotify-elements":142,"../spotify-range2":352,"./center":150,"./util/ListManager.js":197,"./util/throttle":203,"mout/array/contains":463,"prime/emitter":514}],176:[function(require,module,exports){
'use strict';

/**
 * Module for handling clicks on the scroll bar track to scroll pages.
 *
 * @private
 */

var BezierEasing = require('bezier-easing');

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'clickEnd') {
      scroller._clickEndHandler = handler;
    }
  },

  scrollTo: function scrollTo(scroller, newPosition, useEasing, callback) {
    var startPosition = scroller.view.scrollTop;
    var positionDiff = newPosition - startPosition;

    var startTimestamp = Date.now();
    var totalTime = config.scrollToTransitionMs;

    if (!useEasing) {
      totalTime = config.scrollToLinearTransitionMs;
    }

    // Ease in/out quadratic
    var easing = new BezierEasing(0.455, 0.03, 0.515, 0.955);

    var tick = function tick() {
      var elapsedTime = Date.now() - startTimestamp;
      var totalPercentage = elapsedTime / totalTime;

      var currentPercentage = useEasing ? easing.get(totalPercentage) : totalPercentage;

      scroller.view.scrollTop = startPosition + positionDiff * currentPercentage;

      if (totalPercentage < 1) {
        // Must use setTimeout to not make it flicker. Setting scrollTop in
        // requestAnimationFrame will make it scroll and in the next frame allow
        // the scroll handlers to move elements, making it look very flickery.
        setTimeout(tick, config.frameMs);
      } else {
        scroller.view.scrollTop = startPosition + positionDiff;
        scroller.isClickScrollAnimating = false;
        if (callback) {
          callback();
        }
      }
    };

    scroller.isClickScrollAnimating = true;
    setTimeout(tick, config.frameMs);
  },

  holdClick: function holdClick(scroller) {
    var targetThumbEdge = scroller.clickTargetThumbTop;
    var newPosition = this.getNextScrollValue(scroller);
    var newThumbTop = newPosition / scroller.viewScrollHeight * scroller.viewHeight;
    var newThumbBottom = newThumbTop + scroller.thumbHeight;
    var direction = scroller.clickTargetDirection;

    var isValid = false;
    if (direction === 'up' && newThumbBottom > targetThumbEdge) {
      isValid = true;
    } else if (direction === 'down' && newThumbTop < targetThumbEdge) {
      isValid = true;
    }

    if (isValid) {
      var useEasing = false;

      this.scrollTo(scroller, newPosition, useEasing, function () {
        if (scroller.isClickScrolling) {
          this.holdClick(scroller);
        }
      }.bind(this));
    }
  },

  getNextScrollValue: function getNextScrollValue(scroller) {
    var change = scroller.viewHeight * config.clickScrollDistanceFactor;

    if (scroller.clickTargetDirection === 'up') {
      return scroller.view.scrollTop - change;
    }

    return scroller.view.scrollTop + change;
  },

  setMovementData: function setMovementData(scroller, clientY) {
    var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
    var targetThumbEdge = clientY - trackTop;
    var direction = targetThumbEdge < scroller.thumbTop ? 'up' : 'down';

    scroller.clickTargetDirection = direction;
    scroller.clickTargetThumbTop = targetThumbEdge;
  },

  onClickHold: function onClickHold(scroller) {
    scroller.isClickScrolling = true;

    this.holdClick(scroller);
  },

  onMouseMove: function onMouseMove(scroller, event) {
    if (scroller.isMouseOver && event.target === scroller.scrollBarTrack) {
      this.setMovementData(scroller, event.clientY);

      if (scroller.isClickScrolling && !scroller.isClickScrollAnimating) {
        this.holdClick(scroller);
      }
    }
  },

  onMouseUp: function onMouseUp(scroller) {
    scroller.isClickScrolling = false;

    clearTimeout(scroller.clickHoldTimer);

    this.removeHandlers(scroller);

    if (scroller._clickEndHandler) {
      scroller._clickEndHandler();
    }
  },

  onTrackMouseDown: function onTrackMouseDown(scroller, event) {
    var isVisible = scroller.isVisible;
    var isPrimaryButton = event.button === 0;
    var isTargetTrack = event.target === scroller.scrollBarTrack;

    if (isVisible && isPrimaryButton && isTargetTrack) {
      var navigator = window.navigator;
      var isMac = navigator && navigator.userAgent.indexOf('Mac') > -1;
      var isWindows = navigator && navigator.userAgent.indexOf('Windows') > -1;

      if (isMac && event.altKey || isWindows && event.shiftKey) {
        var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
        var targetThumbCenter = event.clientY - trackTop;
        var targetThumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, targetThumbCenter - scroller.thumbHeight / 2));

        scroller.view.scrollTop = targetThumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
      } else {
        this.setMovementData(scroller, event.clientY);

        var targetPosition = this.getNextScrollValue(scroller);
        var useEasing = true;

        this.scrollTo(scroller, targetPosition, useEasing);

        this.addHandlers(scroller);

        scroller.clickHoldTimer = setTimeout(this.onClickHold.bind(this, scroller), config.scrollToTransitionMs + config.clickHoldDelayMs);
      }
    }
  },

  addHandlers: function addHandlers(scroller) {
    scroller._click_onMouseUp = this.onMouseUp.bind(this, scroller);
    scroller._click_onMouseMove = this.onMouseMove.bind(this, scroller);

    document.addEventListener('mouseup', scroller._click_onMouseUp, false);
    document.addEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  removeHandlers: function removeHandlers(scroller) {
    document.removeEventListener('mouseup', scroller._click_onMouseUp, false);
    document.removeEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  attach: function attach(scroller) {
    var onTrackMouseDown = this.onTrackMouseDown.bind(this, scroller);

    scroller.scrollBarTrack.addEventListener('mousedown', onTrackMouseDown, false);

    return function () {
      scroller.scrollBarTrack.removeEventListener('mousedown', onTrackMouseDown, false);
    };
  }

};

},{"./config":177,"bezier-easing":363}],177:[function(require,module,exports){
"use strict";

/**
 * Config with all timer values etc. Easy to have them all in one place, and it
 * also helps for testing, since the config can be used from there too.
 *
 * @private
 */

module.exports = {
  hideAfterMs: 750,
  showAfterMs: 500,

  // Sync with CSS transition duration
  hideTransitionMs: 500,

  expandDelayMs: 150,

  frameMs: 16,
  scrollToTransitionMs: 200,
  scrollToLinearTransitionMs: 120,
  clickHoldDelayMs: 500,
  clickScrollDistanceFactor: 0.95
};

},{}],178:[function(require,module,exports){
'use strict';

/**
 * Module for handling dragging the scroll bar thumb to scroll.
 *
 * @private
 */

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'dragStart') {
      scroller._dragStartHandler = handler;
    } else if (eventName === 'dragEnd') {
      scroller._dragEndHandler = handler;
    }
  },

  onThumbMouseDown: function onThumbMouseDown(scroller, event) {
    if (event.button === 0 && scroller.isVisible) {
      scroller.isDragging = true;
      scroller.startDragMouseY = event.clientY;
      scroller.startDragThumbTop = scroller.thumbTop;

      this.addDragHandlers(scroller);

      if (scroller._dragStartHandler) {
        scroller._dragStartHandler();
      }
    }
  },

  onMouseUp: function onMouseUp(scroller, event) {
    if (scroller.isDragging) {
      scroller.isDragging = false;

      this.removeDragHandlers(scroller);

      if (scroller._dragEndHandler) {
        scroller._dragEndHandler();
      }
    }
  },

  onMouseMove: function onMouseMove(scroller, event) {
    var y = event.clientY;
    var startY = scroller.startDragMouseY;

    scroller.thumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, scroller.startDragThumbTop + y - startY));

    scroller.view.scrollTop = scroller.thumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
  },

  addDragHandlers: function addDragHandlers(scroller) {
    scroller._drag_onMouseMove = this.onMouseMove.bind(this, scroller);
    scroller._drag_onMouseUp = this.onMouseUp.bind(this, scroller);

    document.addEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.addEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  removeDragHandlers: function removeDragHandlers(scroller) {
    document.removeEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.removeEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  attach: function attach(scroller) {
    var onThumbMouseDown = this.onThumbMouseDown.bind(this, scroller);

    scroller.scrollBarThumb.addEventListener('mousedown', onThumbMouseDown, false);

    return function () {
      scroller.scrollBarThumb.removeEventListener('mousedown', onThumbMouseDown, false);
    };
  }

};

},{}],179:[function(require,module,exports){
'use strict';

/**
 * Module for handling expanding the scroll bar width on hover.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  expand: function expand(scroller) {
    clearTimeout(scroller.resetExpandedTimer);
    scroller.scrollBarTrack.classList.add('expanded');
  },

  collapse: function collapse(scroller) {
    scroller.scrollBarTrack.classList.remove('expanded');
  },

  // Called from outside
  onHide: function onHide(scroller) {
    if (!scroller.alwaysVisible) {
      clearTimeout(scroller.expandTimer);
      clearTimeout(scroller.resetExpandedTimer);

      scroller.resetExpandedTimer = setTimeout(this.collapse.bind(this, scroller), config.hideTransitionMs);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
        clearTimeout(scroller.resetExpandedTimer);
        scroller.expandTimer = setTimeout(function () {
          this.expand(scroller);
        }.bind(this), config.expandDelayMs);
      } else {
        this.expand(scroller);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
      } else {
        this.collapse(scroller);
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.expand(scroller);

      return function () {};
    } else {
      this.collapse(scroller);

      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  }

};

},{"./config":177}],180:[function(require,module,exports){
'use strict';

var glue = require('../../spotify-glue-cat');
var cosmos = require('spotify-cosmos-api');

var center = require('../center');
var drag = require('./drag');
var visibility = require('./visibility');
var position = require('./position');
var expansion = require('./expansion');
var click = require('./click');

var scrollers = [];
var scrollerStyle = null;

function Scroller(scrollView) {
  this.view = scrollView;
  this.setInitialState();
  this.addScrollBar();
  this.refresh();

  this.view.setAttribute('data-scroll-area-initialized', '');

  this._onResize = function () {
    this.refresh();
  }.bind(this);
  this._onScroll = function () {
    this.refreshScrollBar();
  }.bind(this);
  this._onThumbDragStart = function (event) {
    event.preventDefault();
    event.stopPropagation();
  };

  // Listen for the scroll event to update view size etc on scroll
  var scrollObject = this.isBody ? window : this.view;
  scrollObject.addEventListener('scroll', this._onScroll, false);

  // Listen for the window resize event, even for scroll areas that are not the
  // body scroll. Since we can't listen for resize events when elements resize,
  // we do a best effort of at least updating when the window resizes (which
  // might affect the size of the scroll area).
  window.addEventListener('resize', this._onResize, false);

  // Prevent dragndrop handling from spotify-events (it will be triggered
  // otherwise since we have to set the draggable attribute to not trigger
  // focus events).
  this.scrollBarThumb.addEventListener('dragstart', this._onThumbDragStart, true);

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);

  visibility.setHandler('show', this, function () {
    this.refresh();
  }.bind(this));

  visibility.setHandler('hide', this, function () {
    expansion.onHide(this);
  }.bind(this));

  // Events are sent when dragging to allow some use cases where you need to do
  // something while dragging. For example, when dragging the scroll bar in the
  // app sidebar and hovering over the main view, it will not trigger mousemove
  // events since the main view is an iframe. To counter that, zlink is
  // listening to these events and sets pointer-events on the content area.
  drag.setHandler('dragStart', this, function () {
    center.emit('scroll-thumb-drag-start', { id: this.viewId });
  }.bind(this));
  drag.setHandler('dragEnd', this, function () {
    visibility.onDragEnd(this);
    center.emit('scroll-thumb-drag-end', { id: this.viewId });
  }.bind(this));

  click.setHandler('clickEnd', this, function () {
    visibility.onClickEnd(this);
  }.bind(this));
}

Scroller.prototype.setInitialState = function () {
  var scrollerStyleToUse = scrollerStyle || window.__spotify.scroller_style;
  this.alwaysVisible = scrollerStyleToUse === 'always';

  this.scrollBarTrack = null;
  this.scrollBarThumb = null;

  this.isBody = this.view === document.body;
  this.viewId = this.view.getAttribute('data-scroll-area');
  this.viewHeight = 0;
  this.viewScrollHeight = 0;

  this.isVisible = false;
  this.isDragging = false;
  this.isMouseOver = false;
  this.isClickScrolling = false;
  this.isClickScrollAnimating = false;

  this.thumbTop = 0;
  this.thumbHeight = 0;

  this.clickTargetDirection = 'down';
  this.clickTargetThumbTop = 0;

  this.startDragMouseY = 0;
  this.startDragThumbTop = 0;

  this.hideTimer = 0;
  this.mouseOverShowTimer = 0;
};

Scroller.prototype.addScrollBar = function () {
  var track = document.createElement('div');
  var thumb = document.createElement('div');

  track.className = 'scrollbar-track';
  thumb.className = 'scrollbar-thumb';

  if (this.alwaysVisible) {
    track.className += ' always-visible';
  }

  // If the thumb is not set to draggable it will trigger focus events on
  // elements being dragged over. For example, dragging the thumb up to the
  // search input puts focus in the search input, which opens the suggest box.
  // Since we will find this element from the dragndrop module, we also need to
  // prevent any drag handling (find the drag listener further down).
  thumb.setAttribute('draggable', 'true');

  track.appendChild(thumb);
  this.view.appendChild(track);

  this.scrollBarTrack = track;
  this.scrollBarThumb = thumb;
};

Scroller.prototype.setViewSize = function () {
  // Hide the scroll bar while calculating sizes, so the scroll bar doesn't
  // interfere. This can happen if scrolled to the bottom of the scroll view and
  // the scroll height changes to be smaller. If the scroll bar is not hidden
  // while calculating the values here, the scrollHeight will not change, since
  // the scroll bar is taking up space.
  this.scrollBarTrack.style.display = 'none';

  if (this.isBody) {
    this.viewHeight = window.innerHeight || Infinity;
  } else {
    this.viewHeight = this.view.clientHeight || Infinity;
  }

  this.viewScrollHeight = this.view.scrollHeight;

  this.scrollBarTrack.style.display = 'block';
};

Scroller.prototype.setThumbSize = function () {
  var percentage = this.viewHeight / this.viewScrollHeight;
  this.thumbHeight = Math.max(40, this.viewHeight * percentage);
  this.scrollBarThumb.style.height = this.thumbHeight + 'px';
};

Scroller.prototype.setTrackPosition = function () {
  this.scrollBarTrack.style.transform = 'translate3d(0, ' + (this.view.scrollTop + 'px') + ', 0)';
};

Scroller.prototype.refresh = function () {
  this.refreshView();
  this.refreshScrollBar();
};

Scroller.prototype.refreshView = function () {
  this.setViewSize();
};

Scroller.prototype.refreshScrollBar = function () {
  this.setThumbSize();

  if (!this.isBody) {
    this.setTrackPosition();
  }
};

Scroller.prototype.update = function () {
  var oldViewHeight = this.viewHeight;
  var oldScrollHeight = this.viewScrollHeight;

  this.refresh();

  visibility.update(this);

  var newViewHeight = this.viewHeight;
  var newScrollHeight = this.viewScrollHeight;

  if (newViewHeight !== oldViewHeight || newScrollHeight !== oldScrollHeight) {
    visibility.highlight(this);
  }
};

Scroller.prototype.setScrollBarMode = function (mode) {
  this.alwaysVisible = mode === 'always';

  if (this.alwaysVisible) {
    this.scrollBarTrack.classList.add('always-visible');
  } else {
    this.scrollBarTrack.classList.remove('always-visible');
  }

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);
};

Scroller.prototype.isInDOM = function () {
  var currentNode = this.view.parentNode;
  while (currentNode && currentNode !== document.documentElement) {
    currentNode = currentNode.parentNode;
  }

  // If we still have a current node after the loop, we found the document
  // element, which means it's in DOM.
  return !!currentNode;
};

Scroller.prototype.destroy = function () {
  var scrollObject = this.isBody ? window : this.view;

  scrollObject.removeEventListener('scroll', this._onScroll, false);

  window.removeEventListener('resize', this._onResize, false);

  this.scrollBarThumb.removeEventListener('dragstart', this._onThumbDragStart, true);

  this.view.removeAttribute('data-scroll-area-initialized', '');
  this.view.removeChild(this.scrollBarTrack);

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();
};

var isAttached = false;
var controlMessageSubscription;

exports.update = function (node) {
  if (!isAttached) {
    return;
  }

  // Clean up scrollers that are not in DOM anymore.
  scrollers = scrollers.filter(function (scroller) {
    if (!scroller.isInDOM()) {
      scroller.destroy();
      return false;
    }
    return true;
  });

  // Update all active scrollers
  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].update();
  }

  var selector = '[data-scroll-area]';
  var scrollViews = (node || document).querySelectorAll(selector);

  for (var i = 0, l = scrollViews.length; i < l; i++) {
    if (!scrollViews[i].hasAttribute('data-scroll-area-initialized')) {
      var scrollView = scrollViews[i];
      var isBody = scrollView === document.body;

      if (isBody && glue.getVersion() !== 2) {
        continue;
      }

      scrollers.push(new Scroller(scrollView));
    }
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var setScrollBarMode = function setScrollBarMode(mode) {
    scrollerStyle = mode;

    for (var i = 0, l = scrollers.length; i < l; i++) {
      scrollers[i].setScrollBarMode(mode);
    }
  };

  controlMessageSubscription = cosmos.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (error, response) {
    if (!error) {
      var data = response.getJSONBody();
      if (data) {
        var styleWasChanged = true;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            setScrollBarMode('always');
            break;
          case 'set_scroller_style_overlay':
            setScrollBarMode('overlay');
            break;
          default:
            styleWasChanged = false;
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will render a white area where the scroll bar is
        // supposed to be. By adding and removing a class name we're triggering
        // a re-render and it will look good.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          var performFix = function performFix() {
            var nodes = scrollers.map(function (scroller) {
              return scroller.view;
            });

            // Always include body to fix the main scroll, even if it doesn't
            // have a custom scroll bar.
            if (nodes.indexOf(document.body) === -1) {
              nodes.push(document.body);
            }

            for (var i = 0, l = nodes.length; i < l; i++) {
              nodes[i].classList.add('jmeBDLRW3CRWW3kZZaZ');
              nodes[i].classList.remove('jmeBDLRW3CRWW3kZZaZ');
            }
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].destroy();
  }
  scrollers.length = 0;

  scrollerStyle = null;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"../../spotify-glue-cat":228,"../center":150,"./click":176,"./drag":178,"./expansion":179,"./position":181,"./visibility":182,"spotify-cosmos-api":554}],181:[function(require,module,exports){
'use strict';

/**
 * Module for handling updating the scroll bar thumb position when scroll
 * position changes.
 *
 * @private
 */

module.exports = {

  setThumbPosition: function setThumbPosition(scroller) {
    if (scroller.viewScrollHeight === scroller.viewHeight) {
      scroller.thumbTop = 0;
    } else {
      scroller.thumbTop = scroller.view.scrollTop / (scroller.viewScrollHeight - scroller.viewHeight) * (scroller.viewHeight - scroller.thumbHeight);
    }

    scroller.scrollBarThumb.style.transform = 'translate3d(0, ' + (scroller.thumbTop + 'px') + ', 0)';
  },

  onScroll: function onScroll(scroller) {
    this.setThumbPosition(scroller);
  },

  attach: function attach(scroller) {
    var onScroll = this.onScroll.bind(this, scroller);

    var scrollObject = scroller.isBody ? window : scroller.view;
    scrollObject.addEventListener('scroll', onScroll, false);

    this.setThumbPosition(scroller);

    return function () {
      scrollObject.removeEventListener('scroll', onScroll, false);
    };
  }

};

},{}],182:[function(require,module,exports){
'use strict';

/**
 * Module for handling the visibility of the scroll bar, based on mouse position
 * and scroll events.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'show') {
      scroller._showHandler = handler;
    } else if (eventName === 'hide') {
      scroller._hideHandler = handler;
    }
  },

  refresh: function refresh(scroller) {
    if (scroller.viewScrollHeight > scroller.viewHeight) {
      this.showScrollBar(scroller);
    } else {
      this.hideScrollBar(scroller);
    }
  },

  showScrollBar: function showScrollBar(scroller) {
    if (scroller.isVisible) {
      return;
    }

    if (scroller.viewScrollHeight > scroller.viewHeight) {
      scroller.scrollBarTrack.classList.add('visible');
      scroller.isVisible = true;

      if (scroller._showHandler) {
        scroller._showHandler();
      }
    }
  },

  hideScrollBar: function hideScrollBar(scroller) {
    if (!scroller.isVisible || scroller.isDragging) {
      return;
    }

    scroller.scrollBarTrack.classList.remove('visible');
    scroller.isVisible = false;

    if (scroller._hideHandler) {
      scroller._hideHandler();
    }
  },

  startHideTimer: function startHideTimer(scroller) {
    this.stopHideTimer(scroller);
    scroller.hideTimer = setTimeout(this.hideScrollBar.bind(this, scroller), config.hideAfterMs);
  },

  stopHideTimer: function stopHideTimer(scroller) {
    clearTimeout(scroller.hideTimer);
  },

  // Called from outside
  onDragEnd: function onDragEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  // Called from outside
  onClickEnd: function onClickEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onScroll: function onScroll(scroller) {
    if (!scroller.isVisible) {
      this.showScrollBar(scroller);
    }

    if (!scroller.isDragging && !scroller.isClickScrolling && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = true;

      this.stopHideTimer(scroller);

      if (!scroller.isVisible) {
        scroller.mouseOverShowTimer = setTimeout(this.showScrollBar.bind(this, scroller), config.showAfterMs);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = false;

      if (!scroller.isDragging && !scroller.isClickScrolling) {
        clearTimeout(scroller.mouseOverShowTimer);

        if (scroller.isVisible) {
          this.startHideTimer(scroller);
        }
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);

      return function () {};
    } else {
      this.hideScrollBar(scroller);

      var onScroll = this.onScroll.bind(this, scroller);
      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      var scrollObject = scroller.isBody ? window : scroller.view;
      scrollObject.addEventListener('scroll', onScroll, false);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scrollObject.removeEventListener('scroll', onScroll, false);

        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  },

  update: function update(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);
    }
  },

  highlight: function highlight(scroller) {
    if (!scroller.alwaysVisible && !scroller.isVisible) {
      this.showScrollBar(scroller);
      this.startHideTimer(scroller);
    }
  }

};

},{"./config":177}],183:[function(require,module,exports){
/**
 * @module spotify-events/select
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SELECT = 'select';
var ATTR_PROPERTY = 'select-property';
var SELECTOR_SELECT = '[data-' + ATTR_SELECT + ']';

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a change on a select node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the select.
 */
function handleChange(event, elem) {
  var property = elem.data(ATTR_PROPERTY);
  var node = elem[0];
  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    publish(node, property);
    // If no property is set, just emit a change event on center.
  } else {
    emitUpdate(node, selectedValue(node));
  }
}

/**
 * Return the value attribute of the selected option
 *
 * @param {Elements} elem An elements DOM node for the select
 */
function selectedValue(node) {
  var selected = node.options[node.selectedIndex];
  return selected.value;
}

/**
 * Handle when a select-option event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSelectSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SELECT + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var value = event.selected;

  // updating the node will trigger a DOM event,
  // delegated to handleChange in this module.
  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    publish(node, property, value);
  } else {
    setState(node, value);
  }
}

/**
 * Publish new data to the live model. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HtmlElement} node A DOM node for the select
 * @param {string} property A property name on the live model
 * @param {string=} opt_value Optional value to set the property to.
 *     If not provided, the selected option's value is fetched from the DOM.
 */
function publish(node, property, opt_value) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_value === undefined ? selectedValue(node) : opt_value;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to send an center event,
  // and update the DOM if needed.
  model.publish(data);
}

/**
 * Update the state of one select node.
 *
 * @param {HTMLElement} node A DOM node for the select.
 */
function updateNode(node) {
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, properties[property]);
      }
    });
  });
}

/**
 * Update a select node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function setState(node, value) {
  updateNodeWithValue(node, value);
  emitUpdate(node, value);
}

/**
 * Update a select based on an option's value attribute
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function updateNodeWithValue(node, value) {
  var selectElement = $(node);
  var optionElement = selectElement.find('option[value="' + value + '"]');
  if (optionElement && !optionElement.attribute('selected')) {
    optionElement.select();
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-select attribute' || null,
 *   selected: the new selected value
 * }
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value Attribute of the selected option
 */
function emitUpdate(node, selected) {
  var id = $(node).data(ATTR_SELECT) || null;
  center.emit('select-change', {
    element: node,
    id: id,
    selected: selected
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SELECT);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('change', SELECTOR_SELECT, handleChange);

  center.on('select-set', onSelectSet);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('change', SELECTOR_SELECT, handleChange);

  center.off('select-set', onSelectSet);
};

},{"../spotify-elements":142,"../spotify-live":312,"./center":150}],184:[function(require,module,exports){
/**
 * @module spotify-events/selection/containers
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

/**
 * Container DOM nodes.
 *
 * @type {Array.<HTMLElement>}
 */
var containers = [];

/**
 * Forget the known containers.
 */
function reset() {
  containers.length = 0;
}

/**
 * Update container storage based on the current DOM.
 */
function update() {
  var nodes = $(document).search(':not(.sticky-clone) > [data-list]');
  if (!nodes) return;

  // Don't drop any containers. If they are removed from the DOM we just keep
  // the reference along with the selection state at the same index. Clearing
  // has to be done manually instead.

  // Append new containers to the end of the list.
  nodes.forEach(function (container) {
    if (containers.indexOf(container) === -1) {
      containers.push(container);
    }
  });
}

/**
 * Get the number of rows in the container at the specified index.
 *
 * @param {number} index The container index.
 *
 * @return {number} The number of rows.
 */
function getContainerLength(index) {
  var container = $(containers[index]);
  if (!container) return 0;

  var uri = container.data('uri');
  if (!uri) return 0;

  var list = live(uri).get('rows');
  if (!list) return 0;

  return list.length;
}

/**
 * Get the index of a container based on URI.
 *
 * @param {string} uri The URI of the container.
 *
 * @return {number} The index of the container. Returns -1 if not found.
 */
function getContainerIndex(uri) {
  for (var i = 0, l = containers.length; i < l; i++) {
    var containerUri = getUri(i);
    if (containerUri === uri) return i;
  }

  return -1;
}

/**
 * Get the URI for a container.
 *
 * @param {number} index The container index.
 *
 * @return {string?} The URI or null if not found.
 */
function getUri(index) {
  var element = containers[index];
  var uri = element && element.getAttribute('data-uri');
  return uri || null;
}

/**
 * Get the URIs for all containers.
 *
 * @return {Array.<string?>} Array of URIs.
 */
function getUris() {
  var uris = [];
  for (var i = 0, l = containers.length; i < l; i++) {
    uris.push(getUri(i));
  }
  return uris;
}

/**
 * Get the live list for a container.
 *
 * @param {number} index The container index.
 *
 * @return {LiveList?} A live list or null if not found.
 */
function getLiveList(index) {
  var uri = getUri(index);
  var list = live(uri).get('rows');
  return list || null;
}

exports.elements = containers;
exports.reset = reset;
exports.update = update;
exports.getContainerLength = getContainerLength;
exports.getContainerIndex = getContainerIndex;
exports.getUri = getUri;
exports.getUris = getUris;
exports.getLiveList = getLiveList;

},{"../../spotify-elements":142,"../../spotify-live":312}],185:[function(require,module,exports){
(function (global){
/**
 * spotify-events/selection/controller
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var center = require('../center');
var selection = require('./index');
var model = require('./model');
var rows = require('./rows');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');
var cosmos = require('../util/cosmos');

var focusEventValid = false;

// Listeners per URI (key is URI)
var listListeners = {};
var listListenerUris = [];

var SELECTABLE = '[data-list-item]';
var CLIPBOARD_ENDPOINT = 'sp://desktop/v1/clipboard';

/**
 * Check whether the event occured on the documentElement.
 *
 * @param {Event} event A event object.
 *
 * @return {boolean}
 */
function isOnDocument(event) {
  return event.target === document.documentElement;
}

/**
 * Get the row node from a mouse event.
 *
 * @param {MouseEvent} event A mouse event object.
 *
 * @return {HTMLElement} A DOM node.
 */
function getNodeFromEvent(event) {
  return event.target.closest(SELECTABLE);
}

/**
 * Check if a target is inside a filter component.
 *
 * @param {HTMLElement} target A DOM node.
 *
 * @return {boolean} Whether the target was inside a filter component.
 */
function isFilterTarget(target) {
  return target !== document && !!target.closest('[data-filter]');
}

/**
 * Handle a mousedown event.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleMouseDown(event, opt_isMouseUp) {
  if (isOnDocument(event)) return;

  focusEventValid = false;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowMouseDown(event, node, opt_isMouseUp);
  } else {
    handleOutsideMouseDown(event);
  }
}

/**
 * Handle when the mouse is pressed down on a list row.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {HTMLElemtn} rowNode The DOM node for the clicked row.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleRowMouseDown(event, rowNode, opt_isMouseUp) {
  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;

  // If we can't find a valid position for the DOM node, we can't handle
  // selection correctly.
  var position = positions.getFromNode(rowNode);
  if (!position) return;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;
  var singleClick = !event.shiftKey;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
    singleClick = true;
  }

  // Remove selection if a selected item is clicked with cmd/ctrl
  if (multiselect && singleClick && isSelected && isPrimaryButton) {

    // For multiselect, make sure we do the deselection only on mouseup
    if (!opt_isMouseUp) return;
    handleDeselectOnSingleMultiSelect(position);

    // Select multiple items if clicked with shift key
  } else if (!singleClick) {

    // Optimize by doing this only on mousedown
    if (opt_isMouseUp) return;
    handleShiftMultiSelect(position);

    // Select a single item
  } else {

    // Handle the case when the primary button is pressed down on a selected item.
    // The method will be called once again in that case, on mouse up. This is
    // to allow the drag and drop to abort the selection change.

    // So we do the actual selection on mouseup, where we know it's not a drag n drop thing.
    if (isPrimaryButton && isSelected && !opt_isMouseUp) {
      return;
    }
    // For multiselect, make sure we do the selection only on mouseup
    if (multiselect && !opt_isMouseUp) {
      return;
    }

    handleSingleSelect(position, event, opt_isMouseUp);
  }
  rows.update();
}

/**
 * Handle when the mouse is pressed down outside a list row.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideMouseDown(event) {
  var isSort = !!event.target.closest('[data-sort]');
  var isFilter = isFilterTarget(event.target);
  var hasSelection = model.hasSelection();

  // Deselect if clicked outside the list.
  // Clicking sort headers should just sort, not clear selection.
  if (!(isSort || isFilter) && hasSelection) {
    model.clear();
    rows.update();
  }
}

/**
 * Handle a focus event.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleFocus(event) {
  if (!focusEventValid) return;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowFocus(event, node);
  } else {
    handleOutsideFocus(event);
  }
  focusEventValid = false;
}

/**
 * Handle when a row receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 * @param {HTMLElement} rowNode The DOM node for the focused row.
 */
function handleRowFocus(event, rowNode) {
  var position = positions.getFromNode(rowNode);

  // Invalid positions and already selected rows don't need to be handled
  if (!position || model.isSelected(position)) {
    return;
  }

  model.clear();
  model.add(position);
  model.setFocus(position);
  model.setOrigin(position);
  rows.update();
}

/**
 * Handle when an element outside the table receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideFocus(event) {
  if (isFilterTarget(event.target)) return;
  model.clear();
  rows.update();
}

/**
 * Handle when the mouse button is released.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleMouseUp(event) {
  if (isOnDocument(event)) return;

  handleMouseDown(event, true);
}

/**
 * Handle deselecting a currently selected row in a multi-select situation
 * (cmd/ctrl). This might mean that we need to adjust origin and focus as well.
 *
 * @param {Position} position Position clicked on.
 */
function handleDeselectOnSingleMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();
  var dir = positions.getDirection(origin, focus);

  // When removing the node that is both origin and focus, there will be no
  // direction in which the origin/focus could be moved. Like here:

  // Click A, CMD click C, CMD click B, CMD click B again.

  // Native desktop will now still have origin on B. MacOS Finder does move
  // origin but it's hard to know how it decides.

  // For a predictable behaviour, default to look downwards, and always reverse
  // the direction when no selected node is found.

  if (!dir) dir = 1;

  var isOrigin = position.isSame(origin);
  var isFocus = position.isSame(focus);
  var above, below;

  if (isOrigin || isFocus) {
    above = getClosestSelected(position, 'up');
    below = getClosestSelected(position, 'down');
  }

  // If direction is down (1), the next after origin is found below
  if (isOrigin) {
    model.setOrigin(dir === 1 ? below || above : above || below);
  }

  // If direction is down (1), the next after focus is found above
  if (position.isSame(focus)) {
    model.setFocus(dir === 1 ? above || below : below || above);
  }

  model.remove(position);
}

/**
 * Handle multi-selecting a range from the current focus to the new position.
 * This also handles deselecting as needed.
 *
 * @param {Position} position Position clicked on.
 */
function handleShiftMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();

  // Remove selection from origin to old focus.
  // If it's part of the new selection it will be re-added.
  if (origin && focus && !origin.isSame(focus)) {
    model.remove(origin, focus);
  }

  // If there is no origin, we will set the origin to the first selectable row
  if (!origin) {
    origin = new Position(0, 0);
    model.setOrigin(origin);
  }

  // Add selection from the current origin to the clicked position
  model.add(origin, position);
  model.setFocus(position);
}

/**
 * Handle a normal mousedown without any multi-select keys.
 *
 * @param {Position} position Position clicked on.
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleSingleSelect(position, event, opt_isMouseUp) {
  var origin = model.getOrigin();

  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;
  var isSecondaryButton = button === 2;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
  }

  // Left click without cmd/ctrl/shift clears selection.
  // Also right click on something that wasn't selected clears.
  var isRegularPrimary = !multiselect && isPrimaryButton;
  var isSelectedSecondary = !isSelected && isSecondaryButton;
  if (isRegularPrimary || isSelectedSecondary) {
    model.clear();
  }

  // Add item to selection
  model.add(position);
  model.setFocus(position, { isTouch: isTouchEvent(event) });

  // When adding to an existing selection, leave origin alone.
  var isNextToSelection;
  if (origin && !origin.isSame(position)) {
    var next = positions.getClosest(position, 'down');

    isNextToSelection = next && model.isSelected(next);
    if (!isNextToSelection) {
      var prev = positions.getClosest(position, 'up');
      isNextToSelection = prev && model.isSelected(prev);
    }
  }
  if (!isNextToSelection) {
    model.setOrigin(position);
  }
}

/**
 * Handler for when a key is pressed down in the list. Depending on the key,
 * this will either move the selection (up and down arrows), shrink/grow the
 * selection (shift up and down arrows) or clear the selection (escape key).
 *
 * @param {KeyboardEvent} event The event object.
 */
function handleKeyDown(event) {
  if (isFilterTarget(event.target)) return;

  focusEventValid = true;
  var isUp = event.keyCode === 38;
  var isDown = event.keyCode === 40;

  if (!isKeyboardNavEnabled()) return;

  if (!isUp && !isDown) return;

  var origin = model.getOrigin();
  var focus = model.getFocus();
  var next = focus;

  do {
    next = next && positions.getClosest(next, isDown ? 'down' : 'up');
  } while (next && model.isPositionHidden(next));

  // Only move the selection if the up or down key was pressed.
  // And only do it if the cmd/ctrl key is not also pressed.
  // The cmd/ctrl key will change the volume in the client.
  if ((isUp || isDown) && !event.metaKey && !event.ctrlKey && next) {

    // Multi-select must have a previous selection position
    if (event.shiftKey && isMultiSelectEnabled() && origin && focus) {
      var keyDirection = isDown ? 1 : -1;
      var direction = positions.getDirection(origin, focus);
      var isSingleRange = direction === 0;
      if (isSingleRange || keyDirection === direction) {
        model.add(next);
        scrollIntoView(next);
      } else {
        model.remove(focus);
      }

      // If multi-select can't be performed, just move the current selection
    } else {
      model.clear();
      model.add(next);
      model.setOrigin(next);
      scrollIntoView(next);
      event.preventDefault(); // Prevent normal scrolling
    }

    // Always set the new focus to the row above or below
    model.setFocus(next);
  }

  rows.update();
}

/**
 * Handle when a section of a list is scrolled into view.
 * This needs to update selection state of the row nodes.
 *
 * @param {Object} event Event object.
 */
function handleScrollShowAfter(event) {
  var node = event.pageNode && event.pageNode[0];
  rows.update(node);
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Object} data Object with properties `hiddenIndices` (array of
 *     indices) and `uri` (URI of the list).
 */
function handleSetHidden(data) {
  model.setHiddenIndices(data.indices, data.uri);
}

/**
 * Add a row to the selection based on a list URI.
 * TODO: Remove logic to handle global lists.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 * @param {boolean=} opt_doNotScrollIntoView Optionally skip scrolling added index into view
 */
function handleAddByUri(listUri, index, opt_doNotScrollIntoView) {
  var uriNodes = $('[data-uri=' + listUri + ']');
  var matches = intersection(containers.elements, uriNodes);

  if (!matches || matches.length < 1) {
    return;
  }

  var container = $(matches[0]);
  var containerIndex = container && containers.elements.indexOf(container[0]);
  var listIsPlayContext = container && container.matches('[data-context]');

  if (listIsPlayContext) {
    // Selection is not based on the global container that is defined via data-context,
    // so the indices need to be resolved to match the selection containers.
    var localPosition = positions.getPositionFromGlobalIndex(index);
    containerIndex = localPosition.containerIndex;
    index = localPosition.index;
  } else if (containerIndex === -1) {
    console && console.warn && console.warn('No container matching this uri was found or selection doesn\'t know ' + 'about the container. Possibly you need to run events.update.');
    return;
  }

  if (!isMultiSelectEnabled()) model.clear();

  var position = new Position(containerIndex, index);
  if (!model.getOrigin()) model.setOrigin(position);
  model.setFocus(position);
  model.add(position);

  rows.update();

  if (opt_doNotScrollIntoView !== true) {
    scrollIntoView(position);
  }
}

/**
 * Handle a select_all event from Cosmos.
 */
function handleSelectAll() {
  if (!isMultiSelectEnabled()) {
    return false;
  }

  model.clear();

  var first = new Position(0, 0);
  model.setOrigin(first);

  var last = positions.getLastPositionForSelectAll();
  model.setFocus(last);

  model.add(first, last);
  rows.update();
}

/**
 * Handle a copy event from Cosmos.
 */
function handleCopy() {
  cosmos.put({ url: CLIPBOARD_ENDPOINT, body: getSelectedUrls().join('\n') });
}

/**
 * Handle a cut event from Cosmos.
 */
function handleCut() {
  handleCopy();

  cosmos.post({ url: 'sp://messages/v1/container/control', body: { type: 'delete' } });
}

/**
 * Gets list of uris for selected rows
 *
 * @return {Array.<string>} Array of URIs.
 */
function handleGetUris() {
  var selections = model.selections;
  var uris = [];

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    if (!containerSelection) continue;

    var entity;

    var list = containers.getLiveList(container);
    if (!list) continue;

    // * Order the keys
    // Since the user can select tracks in any order,
    // the selection is an unordered set until we actually retrieve the
    // uris of the selection. In this case we want to get the uris
    // in the same order as they are shown in the list.
    var orderedSelectedKeys = list.keys.filter(function (key) {
      return !!containerSelection[key];
    });

    for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
      var item = list.valueOf(orderedSelectedKeys[i]);
      if (!item) continue;

      entity = item.get('track');
      if (!entity) entity = item.get('playlist');
      if (!entity) entity = item.get('album');
      if (!entity) entity = item.get('artist');
      if (!entity) entity = item.get('user');
      if (!entity) entity = item;

      uris.push(entity.get('uri'));
    }
  }

  return uris;
}

/**
 * Returns the HTTPS urls of the selected rows
 *
 * @return {Array.<string>} Array of URLs.
 */
function getSelectedUrls() {
  var uris = handleGetUris();
  var urls = [];
  for (var i = 0; i < uris.length; i++) {
    var uriObj = liburi.from(uris[i]);
    if (uriObj) {
      urls.push(uriObj.toOpenURL());
    }
  }
  return urls;
}

/**
 * Get the mouse button number identifier from an event object.
 *
 * @param {MouseEvent|TouchEvent} event A mouse event.
 *
 * @return {number} A number representing the pressed button:
 *     0: No button pressed
 *     1: Primary button (usually left)
 *     2: Secondary button (usually right)
 *     3: Middle (usually the wheel)
 */
function getButtonFromEvent(event) {

  // Touches don't have buttons, so treat all touches as a primary button
  if (isTouchEvent(event)) {
    return 1;
  }

  switch (event.button) {
    case 0:
      return 1;
    case 2:
      return 2;
    case 1:
      return 3;
    default:
      return 0;
  }
}

/**
 * Check if the user agent is on a Mac.
 *
 * @return {boolean} True if Mac, false otherwise.
 */
function isMac() {
  if (!global.window) return false;
  if (!global.window.navigator) return false;
  var userAgent = global.window.navigator.userAgent || '';
  return userAgent.indexOf('Mac') > -1;
}

/**
 * Check if multi-select is enabled.
 * We currently disable it for the Web Player, since not much can be done with
 * a multi-selection there.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isMultiSelectEnabled() {
  if ($('body').data('multi-select-disabled') !== null) return false;
  if (!global.window) return false;
  return !!global.window._getSpotifyModule;
}

/**
 * Check if keyboard selection is enabled.
 * If it's not enabled it is not possible to move the selection with arrow
 * keys or extend it with shift + arrow keys.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isKeyboardNavEnabled() {
  return $('body').data('keyboard-select-disabled') === null;
}

/**
 * Check if the event is a touch event.
 *
 * @param {Event} event Event object.
 *
 * @return {boolean} True if it is a touch event object.
 */
function isTouchEvent(event) {
  return !!event.changedTouches;
}

/**
 * Get the closest selected position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosestSelected(position, direction) {
  while (position) {
    position = positions.getClosest(position, direction);
    if (position && model.isSelected(position)) return position;
  }
  return null;
}

/**
 * Scroll the position into view.
 *
 * @param {Position} position A position.
 */
function scrollIntoView(position) {
  var container = containers.elements[position.containerIndex];
  var scrollContainer = container && container.querySelector('[data-scroll-container]');
  if (scrollContainer) {
    center.emit('scroll-to-index', scrollContainer, position.index);
  } else {
    var node = positions.getNodeFromPosition(position);
    if (!node) return;

    var offset = node.getBoundingClientRect().top;
    if (offset < 0 || offset >= window.innerHeight) {
      node.scrollIntoView(offset < 0);
    }
  }
}

/**
 * Update the list listeners for the current containers.
 */
function updateListListeners() {
  var uris = containers.getUris();

  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    if (uri && listListenerUris.indexOf(uri) === -1) {
      var list = live(uri).get('rows');
      if (list) {
        var listener = createListListener(uri);
        list.on('update', listener);
        listListeners[uri] = listener;
        listListenerUris.push(uri);
      }
    }
  }
}

/**
 * Create an event listener for list updates.
 * When an update happens, the selection model will be updated for the right
 * container.
 *
 * @param {string} uri A URI for a list.
 *
 * @return {function} A listener function.
 */
function createListListener(uri) {
  return function (operations) {
    var uris = containers.getUris();
    var containerIndex = uris.indexOf(uri);
    if (containerIndex > -1) {

      // If something was removed from the list, we must update the selection
      // state, as something that was selected might have been removed.
      // Insert and move operations don't affect the current selection state,
      // as everything is based on row IDs, which don't change.
      for (var i = 0, l = operations.length; i < l; i++) {
        var operation = operations[i];
        if (operation.type === 'remove') {
          model.updateContainer(containerIndex);
          break;
        }
      }

      // Update the rows visually based on the model state
      rows.update();
    }
  };
}

/**
 * Remove all list listeners.
 */
function resetListListeners() {
  for (var i = 0, l = listListenerUris.length; i < l; i++) {
    var uri = listListenerUris[i];
    var listener = listListeners[uri];
    var list = live(uri).get('rows');
    if (list && listener) {
      list.off('update', listener);
      delete listListeners[uri];
      listListenerUris.splice(i, 1);
      i--;l--;
    }
  }
}

function handleListSwap(event) {
  var rowsListBefore = live(event.before).get('rows');
  if (!rowsListBefore) return;

  var selectionBefore = selection.getIndicesPerList().filter(function (indicesPerList) {
    return indicesPerList.uri === event.before;
  })[0];

  var selectedKeysBefore = [];
  if (selectionBefore) {
    selectedKeysBefore = selectionBefore.indices.map(function (index) {
      return rowsListBefore.keys[index];
    });
  }

  center.on('scroll-reset', function onScrollReset() {
    center.off('scroll-reset', onScrollReset);

    live(event.after).get('rows', function (error, rowsListAfter) {
      selectedKeysBefore.forEach(function (selectedKeyBefore) {
        var indexAfter = rowsListAfter.keys.indexOf(selectedKeyBefore);
        if (indexAfter !== -1) {
          handleAddByUri(event.after, indexAfter, true);
        }
      });
    }, live.ASAP);
  });
}

exports.handleMouseDown = handleMouseDown;
exports.handleMouseUp = handleMouseUp;
exports.handleKeyDown = handleKeyDown;
exports.handleFocus = handleFocus;
exports.handleScrollShowAfter = handleScrollShowAfter;
exports.handleSetHidden = handleSetHidden;
exports.handleAddByUri = handleAddByUri;
exports.handleSelectAll = handleSelectAll;
exports.handleCopy = handleCopy;
exports.handleCut = handleCut;
exports.handleGetUris = handleGetUris;
exports.updateListListeners = updateListListeners;
exports.resetListListeners = resetListListeners;
exports.handleListSwap = handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":142,"../../spotify-live":312,"../center":150,"../util/Position":198,"../util/cosmos":200,"./containers":184,"./index":186,"./model":187,"./positions":188,"./rows":189,"mout/array/intersection":472,"spotify-liburi":563}],186:[function(require,module,exports){
/**
 * spotify-events/selection
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');
var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

var center = require('../center');
var controller = require('./controller');
var containers = require('./containers');
var model = require('./model');
var rows = require('./rows');
var positions = require('./positions');
var Position = require('../util/Position');
var appUtil = require('../util/app');

var cosmos = require('../util/cosmos');

var controlMessageSubscription;

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  var doc = $(document);
  doc.on('mousedown', controller.handleMouseDown);
  doc.on('touchstart', controller.handleMouseDown);
  doc.on('mouseup', controller.handleMouseUp);
  doc.on('touchend', controller.handleMouseUp);
  doc.on('keydown', controller.handleKeyDown);
  doc.on('focus', controller.handleFocus, true);

  center.on('scroll-show-after', controller.handleScrollShowAfter);
  center.on('selection-set-hidden', controller.handleSetHidden);
  center.on('list-swap', controller.handleListSwap);

  // Creating an "intentional bug".. By switching to use row IDs internally
  // for the selection model, we no longer need to manually update indices
  // as long as the new list has the same IDs (which we require anyway for
  // other reasons). We stopped using this event a long time ago anyway,
  // because it never really worked without odd behaviors. I've done a
  // code search (indexed Nov 23 2014), and there is not a single place
  // where this event is used, except in old versions of spotify-events,
  // which is not a problem. Technically, not responding to this event
  // is a breaking change, but for simplicity's sake let's stop handling it.
  // Fixing code that never gets used just for the sake of it makes no sense.
  // If someone really needs this in the future, we can fix it then.
  // So, this line should be commented for now.
  //
  // center.on('update-indices', controller.handleUpdateIndices);

  controlMessageSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && appUtil.isActiveAndFocused()) {
      if (data.type === 'select_all') {
        controller.handleSelectAll();
      } else if (data.type === 'copy') {
        controller.handleCopy();
      } else if (data.type === 'cut') {
        controller.handleCut();
      }
    }
  });
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  var doc = $(document);
  doc.off('mousedown', controller.handleMouseDown);
  doc.off('touchstart', controller.handleMouseDown);
  doc.off('mouseup', controller.handleMouseUp);
  doc.off('touchend', controller.handleMouseUp);
  doc.off('keydown', controller.handleKeyDown);
  doc.off('focus', controller.handleFocus, true);

  center.off('scroll-show-after', controller.handleScrollShowAfter);
  center.off('selection-set-hidden', controller.handleSetHidden);
  center.off('list-swap', controller.handleListSwap);

  // See comment in `attach` for the long story why this is commented.
  // center.off('update-indices', controller.handleUpdateIndices);

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

/**
 * Update the module based on the current DOM state.
 */
exports.update = function () {
  containers.update();
  controller.updateListListeners();
};

/**
 * Add a row to the selection based on a list URI.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 */
exports.add = function (listUri, index) {
  controller.handleAddByUri(listUri, index);
};

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
exports.hasHoles = function () {
  return model.hasHoles();
};

/**
 * Check if the row node is selected.
 *
 * @param {HTMLElement|Elements} node A DOM node for a row.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
exports.isNodeSelected = function (node) {
  node = 'innerHTML' in node ? node : node[0];
  if (!node) return false;

  var position = positions.getFromNode(node);
  if (!position) return false;

  return model.isSelected(position);
};

/**
 * Reset the selection state and its knowledge of any containers.
 */
exports.reset = function () {
  controller.resetListListeners();
  model.reset();
  rows.update();
  containers.reset();
};

/**
 * Clear the current selection.
 */
exports.clear = function () {
  model.clear();
  rows.update();
};

/**
 * Set the origin to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setOrigin = function (containerIndex, index) {
  model.setOrigin(new Position(containerIndex, index));
};

/**
 * Set the focus to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setFocus = function (containerIndex, index) {
  model.setFocus(new Position(containerIndex, index));
};

/**
 * Get the current origin position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getOrigin = function () {
  var origin = model.getOrigin();
  if (!origin) return null;
  return {
    containerIndex: origin.containerIndex,
    index: origin.index
  };
};

/**
 * Get the current focus position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getFocus = function () {
  var focus = model.getFocus();
  if (!focus) return null;
  return {
    containerIndex: focus.containerIndex,
    index: focus.index
  };
};

/**
 * Get all selected indices organized by list.
 *
 * @return {Array.<Object>} Array of objects of this structure:
 *     {
 *       containerIndex: 0,
 *
 *       // This is the list in the UI (could be sorted or unsorted)
 *       uri: 'spotify:internal:sortlist:asc:track(name):list',
 *       keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *       indices: [3, 4, 5, 10, 15, 20], // Ordered indices in the list
 *
 *       // If all items between two selected items are hidden, they will be
 *       // included here to allow nice ranges to be created from this. It will
 *       // also include hidden items right after the last selected item.
 *       keysWithHidden: ['c', 'd', 'e', 'j', 'k', 'l', 'm', 'n', 'o', 't'],
 *       indicesWithHidden: [3, 4, 5, 10, 11, 12, 13, 14, 15, 20],
 *
 *       // Optional object for the unsorted list if the list is a sorted list
 *       origin: {
 *         uri: 'spotify:list',
 *         keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *         indices: [7, 19, 8, 14, 0, 9] // Unordered indices in the original list
 *       }
 *     }
 */
exports.getIndicesPerList = function () {
  var selections = model.selections;
  var indicesPerList = [];

  for (var i = 0; i < selections.length; i++) {
    var containerSelection = selections[i];
    if (containerSelection && Object.keys(containerSelection).length) {

      var uri = containers.getUri(i);
      if (!uri) continue;

      var list = containers.getLiveList(i);
      if (!list) continue;

      var indices = model.getIndicesForContainer(i);
      if (!indices) continue;

      var keys = indices.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var indicesWithHidden = model.getIndicesWithHiddenForContainer(i);
      var keysWithHidden = indicesWithHidden.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var context = {
        containerIndex: i,
        uri: uri,
        indices: indices,
        keys: keys,
        indicesWithHidden: indicesWithHidden,
        keysWithHidden: keysWithHidden
      };

      var originUri = getOriginUri(uri);
      if (originUri) {
        var wrappedList = live(uri).get('rows');
        var originList = live(originUri).get('rows');

        var originIndices;
        var originKeys;
        if (wrappedList && originList) {
          var key;
          var originListKeyIndexMap = {};
          originIndices = new Array(indices.length);
          originKeys = new Array(indices.length);

          for (var i = 0, keys = originList.keys; i < keys.length; i++) {
            originListKeyIndexMap[keys[i]] = i;
          };

          for (var j = 0; j < indices.length; j++) {
            key = wrappedList.keys[indices[j]];
            originIndices[j] = originListKeyIndexMap[key];
            originKeys[j] = originList.keys[originIndices[j]];
          }
        }
        context.origin = {
          uri: originUri,
          indices: originIndices || [],
          keys: originKeys || []
        };
      }

      indicesPerList.push(context);
    }
  }

  return indicesPerList;
};

/**
 * Get all selected indices relative to the full page (across all containers).
 *
 * @return {Object?} The value null if no global context is found or if found,
 *     an object of this structure:
 *     {
 *       uri: 'spotify:context:uri',
 *       indices: [0, 3, 56, 120],
 *
 *       // These elements are Elements instances from the 'elements' npm
 *       // package. This should be fixed in a future major version, to be
 *       // normal HTML elements.
 *       containers: [
 *         containerElement1,
 *         containerElement1,
 *         containerElement4,
 *         containerElement5
 *       ]
 *     }
 */
exports.getIndicesGlobal = function () {
  var selections = model.selections;
  var elements = containers.elements;
  var indices = [];
  var selectionContainers = [];

  if (elements.length === 0) {
    return null;
  }
  var contextUriContainer = elements[0].closest('[data-context]');
  var contextUri = contextUriContainer && contextUriContainer.getAttribute('data-uri');

  if (!contextUri) return null;

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    var list = containers.getLiveList(container);
    if (list && containerSelection) {

      var orderedSelectedKeys = list.keys.filter(function (key) {
        return !!containerSelection[key];
      });

      for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
        var j = list.keys.indexOf(orderedSelectedKeys[i]);
        indices.push(positions.getGlobalIndexFromPosition(new Position(container, j)));
        selectionContainers.push($(elements[container]));
      }
    }
  }

  return {
    uri: contextUri,
    indices: indices,
    containers: selectionContainers
  };
};

/**
 * Get the URI of all selected rows.
 *
 * @return {Array.<string>} Array of URIs.
 */
exports.getUris = function () {
  return controller.handleGetUris();
};

/**
 * Get the nodes for all selected rows that can be found.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
exports.getNodes = function () {
  return rows.getSelectedRows();
};

},{"../../spotify-elements":142,"../../spotify-live":312,"../../spotify-live-wrapped-uri":311,"../center":150,"../util/Position":198,"../util/app":199,"../util/cosmos":200,"./containers":184,"./controller":185,"./model":187,"./positions":188,"./rows":189}],187:[function(require,module,exports){
/**
 * @module spotify-events/selection/model
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');

/**
 * Selections for all known containers.
 * Each container's selection space is represented as an object where keys are
 * row IDs. This allows for quick lookups.
 *
 * @type {Array.<Object.<string, boolean>>}
 */
var selections = [];

/**
 * Hidden items for all known containers.
 * Each container is represented as an object where keys are row IDs. This
 * allows for quick lookups.
 *
 * @type {Object.<number, Object.<string, boolean>>}
 */
var hiddenKeysPerContainer = {};

var originContainerIndex = null;
var originKey = null;
var focusContainerIndex = null;
var focusKey = null;
var focusIsTouch = false;

/**
 * Get the current origin.
 *
 * @return {Position?} The origin position or null if not set.
 */
function getOrigin() {
  if (originContainerIndex === null) return null;
  if (originKey === null) return null;

  var list = containers.getLiveList(originContainerIndex);
  if (list) {
    var index = list.keys.indexOf(originKey);
    if (index === -1) return null;
    var position = new Position(originContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Get the current focus. This is the position for the keyboard focus.
 *
 * @return {Position?} The focus position or null if not set.
 */
function getFocus() {
  if (focusContainerIndex === null) return null;
  if (focusKey === null) return null;

  var list = containers.getLiveList(focusContainerIndex);
  if (list) {
    var index = list.keys.indexOf(focusKey);
    var position = new Position(focusContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Set the current origin.
 *
 * @param {Position?} position A position or null if removing the origin.
 */
function setOrigin(position) {
  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      originContainerIndex = position.containerIndex;
      originKey = list.keys[position.index] || null;
      return;
    }
  }

  originContainerIndex = null;
  originKey = null;
}

/**
 * Set the current focus.
 *
 * @param {Position?} position A position or null if removing the focus.
 */
function setFocus(position, options) {
  focusIsTouch = !!(options && options.isTouch);

  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      focusContainerIndex = position.containerIndex;
      focusKey = list.keys[position.index];
      return;
    }
  }

  focusContainerIndex = null;
  focusKey = null;
}

/**
 * Check if the current focus was triggered by a touch.
 * This is done since we might want to have different styles for selection focus
 * when triggered by a touch event.
 *
 * @return {boolean} True if triggered by touch.
 */
function wasFocusTriggeredByTouch() {
  return focusIsTouch;
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Array.<number>} hiddenIndices Array of indices that are hidden.
 * @param {string} containerUri The URI of the container.
 */
function setHiddenIndices(hiddenIndices, containerUri) {
  var list = live(containerUri).get('rows');
  if (list) {
    var keys = list.keys;
    var hiddenKeys = {};
    for (var i = 0, l = hiddenIndices.length; i < l; i++) {
      var key = keys[hiddenIndices[i]];
      if (key) hiddenKeys[key] = true;
    }

    var containerIndex = containers.getContainerIndex(containerUri);

    hiddenKeysPerContainer[containerIndex] = hiddenKeys;

    updateContainer(containerIndex);
  }
}

/**
 * Check if given position is hidden.
 *
 * @param {Position} from The position to check.
 * @return {boolean} True if position is hidden.
 */
function isPositionHidden(pos) {
  var idsPerContainer = getIds(pos, pos);
  var id = idsPerContainer[0][0];
  var hiddenKeys = hiddenKeysPerContainer[pos.containerIndex];
  return hiddenKeys && hiddenKeys[id];
}

/**
 * Add rows to the selection.
 *
 * @param {Position} from The start position to add.
 * @param {Position=} opt_to The end position to add. If not provided, it will
 *     only add a single row to the selection.
 */
function add(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];
    var hiddenKeys = hiddenKeysPerContainer[containerIndex];

    // Set all new items as selected, unless they're hidden
    for (var j = 0, id; id = ids[j]; j++) {
      if (!hiddenKeys || !hiddenKeys[id]) {
        selected[id] = true;
      }
    }
  }
}

/**
 * Remove rows from the selection.
 *
 * @param {Position} from The start position to remove.
 * @param {Position=} opt_to The end position to remove. If not provided, it will
 *     only remove a single row from the selection.
 */
function remove(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];

    // Loop the row ids that are to be removed and remove them from the selection.
    // That's usually faster than looping the selection since there's no UI for
    // removing a big chunk of selection in one go.
    for (var j = 0, id; id = ids[j]; j++) {
      delete selected[id];
    }
  }
}

/**
 * Clear the current selection.
 */
function clear() {
  selections.length = 0;
  setOrigin(null);
  setFocus(null);
}

/**
 * Reset the current selection state.
 */
function reset() {
  clear();
  hiddenKeysPerContainer = {};
}

/**
 * Update the model state based on the current state of the list.
 * If items were removed from the list, removed items that were selected
 * will be removed from selection state.
 */
function updateContainer(containerIndex) {
  var keys = selections[containerIndex];
  if (!keys) return;

  var list = containers.getLiveList(containerIndex);
  if (!list) return;

  for (var key in keys) {
    var hasKey = list.hasKey(key);
    var shouldDelete = !hasKey;
    if (!shouldDelete) {
      var hiddenKeys = hiddenKeysPerContainer[containerIndex];
      var shouldDelete = hiddenKeys ? hiddenKeys[key] : false;
    }
    if (shouldDelete) {
      delete keys[key];
    }
  }
}

/**
 * Get ranges for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Range>} Array of ranges. There will be one range per
 *     matching container.
 */
function getRanges(from, to) {
  var ranges = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      ranges.push(new Range(0, 0));
    } else {
      ranges.push(new Range(fromIndex, toIndex + 1));
    }
  }

  return ranges;
}

/**
 * Get IDs for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Array.<string>>} Array of IDs per container.
 */
function getIds(from, to, opt_keys) {
  var idsPerContainer = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      idsPerContainer.push([]);
    } else {
      var ids = [];
      idsPerContainer.push(ids);

      var containerUri = containers.getUri(i);
      var list = live(containerUri).get('rows');
      if (list) {
        var keys = list.keys;

        for (var n = fromIndex; n < toIndex + 1; n++) {
          ids.push(keys[n]);
        }
      }
    }
  }

  return idsPerContainer;
}

/**
 * Check if the position is selected.
 *
 * @param {Position} position A position.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
function isSelected(position) {

  // Get the ranges of the according container
  var keys = selections[position.containerIndex];
  if (!keys) return false;

  // Check if the row is within the selected ranges for the container
  var list = containers.getLiveList(position.containerIndex);
  if (list) {
    var key = list.keys[position.index];
    return !!keys[key];
  }

  return false;
}

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
function hasHoles() {
  var rangeCount = 0;

  for (var containerIndex = 0; containerIndex < selections.length; containerIndex++) {
    var containerSelection = selections[containerIndex];
    var list = containers.getLiveList(containerIndex);

    var keys = Object.keys(containerSelection);

    // A selection in more than one container means the selection has holes
    if (keys.length > 0) {
      rangeCount++;

      // Also more than one range in only one container means it has holes.
      if (list) {
        var indices = [];
        for (var j = 0, len = keys.length; j < len; j++) {
          indices.push(list.indexOf(keys[j]));
        }
        indices.sort(function (a, b) {
          return a - b;
        });
        var previousIndex;
        for (var i = 0, l = indices.length; i < l; i++) {
          var index = indices[i];
          if (i > 0 && index > previousIndex + 1) {
            rangeCount++;
            break;
          }
          previousIndex = index;
        }
      }
    }
    if (rangeCount > 1) return true;
  }

  return false;
}

/**
 * Check if there is any selection in any container.
 *
 * @return {boolean} True if there is a selection.
 */
function hasSelection() {
  for (var i = 0, l = selections.length; i < l; i++) {
    if (selections[i] && Object.keys(selections[i]).length > 0) {
      return true;
    }
  }

  return false;
}

/**
 * Get the selected indices for a container.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesForContainer(containerIndex) {
  var unorderedKeys = selections[containerIndex];
  if (!unorderedKeys) return null;
  var indices = [];

  var list = containers.getLiveList(containerIndex);

  var orderedKeys = list.keys.filter(function (key) {
    return !!unorderedKeys[key];
  });

  if (list && orderedKeys.length) {
    if (orderedKeys.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      indices = list.indexOfMany(orderedKeys);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      indices = [list.indexOf(orderedKeys[0])];
    }
  }

  return indices.length ? indices : null;
}

/**
 * Get the selected indices for a container, including hidden items that join
 * two ranges. For example, in a list [A, B, C, D, E, F, G, H], everything is
 * selected except C, D, F and G. There are hidden items, C, D, F and G. This
 * method would then return the indices of all items except H,
 * [0, 1, 2, 3, 4, 5, 6]. It does include hidden items right after the last
 * selected one.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesWithHiddenForContainer(containerIndex) {
  var indices = getIndicesForContainer(containerIndex);
  if (!indices) return null;

  var hiddenKeys = hiddenKeysPerContainer[containerIndex];
  if (!hiddenKeys) return indices;

  var ranges = Range.fromIndices(indices);
  if (ranges.length === 1) return indices;

  var list = containers.getLiveList(containerIndex);
  if (!list) return indices;

  var hiddenIds = Object.keys(hiddenKeys);
  var hiddenIndices = [];

  if (hiddenIds.length) {
    if (hiddenIds.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      hiddenIndices = list.indexOfMany(hiddenIds);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      hiddenIndices = [list.indexOf(hiddenIds[0])];
    }
  }

  hiddenIndices = hiddenIndices.filter(function (index) {
    return index > -1;
  });

  var hiddenRanges = Range.fromIndices(hiddenIndices);
  var hiddenStarts = hiddenRanges.map(function (range) {
    return range.start;
  });
  var hiddenEnds = hiddenRanges.map(function (range) {
    return range.end;
  });

  for (var i = 0, l = ranges.length; i < l; i++) {
    var range = ranges[i];
    var nextRange = ranges[i + 1];

    var indexOfRange = hiddenStarts.indexOf(range.end);
    if (indexOfRange > -1) {
      var hiddenEnd = hiddenEnds[indexOfRange];
      if (!nextRange || hiddenEnd === nextRange.start) {
        var hiddenIndicesInRange = hiddenRanges[indexOfRange].toIndices();
        if (hiddenIndicesInRange.length > 0) {
          indices = indices.concat(hiddenIndicesInRange);
        }
      }
    }
  }

  indices.sort(function (a, b) {
    return a - b;
  });

  return indices.length ? indices : null;
}

exports.selections = selections;
exports.getOrigin = getOrigin;
exports.getFocus = getFocus;
exports.setOrigin = setOrigin;
exports.setFocus = setFocus;
exports.wasFocusTriggeredByTouch = wasFocusTriggeredByTouch;
exports.setHiddenIndices = setHiddenIndices;
exports.isPositionHidden = isPositionHidden;
exports.add = add;
exports.remove = remove;
exports.clear = clear;
exports.reset = reset;
exports.updateContainer = updateContainer;
exports.isSelected = isSelected;
exports.hasHoles = hasHoles;
exports.hasSelection = hasSelection;
exports.getIndicesForContainer = getIndicesForContainer;
exports.getIndicesWithHiddenForContainer = getIndicesWithHiddenForContainer;

},{"../../spotify-live":312,"../../spotify-range2":352,"../util/Position":198,"./containers":184,"./positions":188}],188:[function(require,module,exports){
/**
 * @module spotify-events/selection/positions
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');

var containers = require('./containers');
var Position = require('../util/Position');

/**
 * Get the closest position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosest(position, direction) {
  var isDown = direction === 'down';
  var containerIndex = position.containerIndex;
  var index = position.index;

  // Find next position within the current container
  var containerLength = containers.getContainerLength(containerIndex);
  var nextIndex = isDown ? index + 1 : index - 1;
  if (nextIndex < containerLength && nextIndex >= 0) {
    return new Position(containerIndex, nextIndex);
  }

  // Out of bounds, traverse containers
  containerIndex = isDown ? containerIndex + 1 : containerIndex - 1;
  containerLength = containers.getContainerLength(containerIndex);
  if (containerLength) {
    nextIndex = isDown ? 0 : containerLength - 1;
    return new Position(containerIndex, nextIndex);
  }

  return null;
}

/**
 * Get a position from a row node.
 *
 * @param {HTMLElement} node A DOM node for a list row.
 *
 * @return {Position?} A position or null if not found.
 */
function getFromNode(node) {

  // We need a parent node, since we will be checking if the row is inside
  // one of the known selection containers.
  if (!node.parentNode) return null;

  // We also need a data-index attribute on the row to get the index for the
  // row within the current selection container.
  if (!node.hasAttribute('data-index')) return null;

  var elements = containers.elements;
  if (elements.length === 0) return null;

  for (var i = 0, l = elements.length; i < l; i++) {
    if (elements[i] && containsNode(elements[i], node)) {
      var row = +node.getAttribute('data-index');
      return new Position(i, row);
    }
  }

  return null;
}

/**
 * Check if an element contains another node.
 *
 * @param {HTMLElement} element The container element.
 * @param {HTMLElement} child The potential child node.
 *
 * @return {boolean} True if element contains the child, false otherwise.
 */
function containsNode(element, child) {
  while (child && child.parentNode !== element) {
    child = child.parentNode;
  }
  return !!child;
}

/**
 * Get the row node that the specified position represents.
 *
 * @param {Position} position A position.
 *
 * @return {HTMLElement?} A DOM node or null if not found.
 */
function getNodeFromPosition(position) {
  var container = containers.elements[position.containerIndex];
  if (!container) return null;
  var node = $(container).find('[data-index=' + position.index + ']');
  return node ? node[0] : null;
}

/**
 * Get the direction from one position to another.
 *
 * @param {Position} from First position.
 * @param {Position} to Second position.
 *
 * @return {number} A number representing the direction.
 *     -1 is up
 *      0 is same
 *      1 is down
 */
function getDirection(from, to) {
  if (!from || !to) return 0;

  // With different containers we can just compare the containers
  if (from.containerIndex !== to.containerIndex) return from.containerIndex < to.containerIndex ? 1 : -1;

  // Within the same container, compare the row indices
  if (from.index === to.index) return 0;
  return from.index < to.index ? 1 : -1;
}

/**
 * Get data about in which container and where inside that the provided
 * global index is.
 *
 * @param {number} globalIndex An index relative to the full page (all
 *     selection containers).
 *
 * @return {Position} A position.
 */
function getPositionFromGlobalIndex(globalIndex) {
  var resolvedIndex = globalIndex;
  var resolvedContainerIndex = 0;
  var containerLength;
  var countIndices = 0;

  // Subtract the amount of tracks in containers until passing globalIndex
  for (var i = 0, l = containers.elements.length; i < l; i++) {

    containerLength = containers.getContainerLength(i);
    countIndices += containerLength;

    if (countIndices > globalIndex) break;

    resolvedContainerIndex = i + 1;
    resolvedIndex -= containerLength;
  }

  return new Position(resolvedContainerIndex, resolvedIndex);
}

/**
 * Get the global index relative to the full page (across all selection
 * containers) from a position object.
 *
 * @param {Position} position A position.
 *
 * @return {number} A global index.
 */
function getGlobalIndexFromPosition(position) {
  var resolvedIndex = position.index;

  // Subtract length of previous lists
  for (var i = position.containerIndex - 1; i >= 0; i--) {
    resolvedIndex += containers.getContainerLength(i);
  }

  return resolvedIndex;
}

/**
 * Get last position on page.
 *
 * @return {Position} A position.
 */
function getLastPosition() {
  var lastContainerIndex = containers.elements.length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

/**
 * Get last position for "select all" on page, disregarding containers with
 * [data-select-all="false"].
 *
 * @return {Position} A position.
 */
function getLastPositionForSelectAll() {
  var lastContainerIndex = containers.elements.filter(function (element) {
    return element.getAttribute('data-list-may-select-all') !== 'false';
  }).length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

exports.getClosest = getClosest;
exports.getFromNode = getFromNode;
exports.getNodeFromPosition = getNodeFromPosition;
exports.getDirection = getDirection;
exports.getPositionFromGlobalIndex = getPositionFromGlobalIndex;
exports.getGlobalIndexFromPosition = getGlobalIndexFromPosition;
exports.getLastPosition = getLastPosition;
exports.getLastPositionForSelectAll = getLastPositionForSelectAll;

},{"../../spotify-elements":142,"../util/Position":198,"./containers":184}],189:[function(require,module,exports){
/**
 * @module spotify-events/selection/rows
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var difference = require('mout/array/difference');

var model = require('./model');
var containers = require('./containers');
var positions = require('./positions');

var SELECTOR_ROW = '[data-list-item]';
var CLASSNAME_SELECTED = 'selected';
var CLASSNAME_FOCUSED = 'selection-focus';
var CLASSNAME_FOCUSED_TOUCH = 'selection-focus-touch';
var focusTimeout;

/**
 * Update the selection state of rows.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, the update
 *     will only affect rows found inside this node.
 */
function update(opt_node) {
  var currentlySelectedRows = getSelectedRows(opt_node);
  var rowsToBeSelected = getRowsToSelect(opt_node);

  var rowsToDeselect = difference(currentlySelectedRows, rowsToBeSelected);
  var rowsToSelect = difference(rowsToBeSelected, currentlySelectedRows);

  currentlySelectedRows.forEach(function (row) {
    $(row).removeClass(CLASSNAME_FOCUSED);
    $(row).removeClass(CLASSNAME_FOCUSED_TOUCH);
  });

  // Remove styles for selected rows that should now be deselected
  rowsToDeselect.forEach(function (row) {
    $(row).removeClass(CLASSNAME_SELECTED);
  });

  // Add styles for unselected rows that should now be selected
  rowsToSelect.forEach(function (row) {
    $(row).addClass(CLASSNAME_SELECTED);
  });

  // Add styles for the row with the selection focus
  var focus = model.getFocus();
  if (focus) {
    var focusNode = positions.getNodeFromPosition(focus);
    if (focusNode) {
      // If the focusNode is not yet in the viewport and we `focus()` it, the
      // browser will bluntly scroll it into view, which looks bad. (KM-6508)
      clearTimeout(focusTimeout);
      focusTimeout = setTimeout(function () {
        var isInputFocused = document.activeElement && $(document.activeElement).matches('input, textarea');
        var isButtonFocused = document.activeElement && $(document.activeElement).matches('button');
        if (isElementInViewport(focusNode) && !isInputFocused && !isButtonFocused) {
          focusNode.focus();
        }
      }, 0);
      $(focusNode).addClass(CLASSNAME_FOCUSED);

      if (model.wasFocusTriggeredByTouch()) {
        $(focusNode).addClass(CLASSNAME_FOCUSED_TOUCH);
      }
    }
  }
}

/**
 * Get the rows that are currently selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getSelectedRows(opt_node) {
  var elements = opt_node ? [opt_node] : containers.elements;
  var rows = [];

  elements.forEach(function (container) {
    var nodes = $(container).search(SELECTOR_ROW + '.' + CLASSNAME_SELECTED);
    if (nodes) Array.prototype.push.apply(rows, nodes);
  });

  return rows;
}

/**
 * Get the rows that should be selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getRowsToSelect(opt_node) {
  var rows = [];
  var containerElements = containers.elements;

  model.selections.forEach(function (keys, index) {
    if (!keys) return;

    var list = containers.getLiveList(index);
    if (!list) return;

    var container = containerElements[index];
    // If a node was passed, only check the container if it contains the node
    if (opt_node && !containerElements[index].contains(opt_node)) {
      container = null;
    }
    if (!container) return;

    var listNodes = $(container).search(SELECTOR_ROW);
    if (!listNodes) return;

    var nodes = listNodes.filter(function (listNode) {
      var nodeIndex = +listNode.getAttribute('data-index');
      var nodeRowId = list.keys[nodeIndex];
      return !!keys[nodeRowId];
    });

    Array.prototype.push.apply(rows, nodes);
  });
  return rows;
}

function isElementInViewport(el) {
  var rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.bottom <= document.documentElement.clientHeight;
}

exports.update = update;
exports.getSelectedRows = getSelectedRows;

},{"../../spotify-elements":142,"./containers":184,"./model":187,"./positions":188,"mout/array/difference":464}],190:[function(require,module,exports){
/**
 * @module spotify-events/slider
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SLIDER = 'slider';
var ATTR_PROPERTY = 'slider-property';
var SELECTOR_SLIDER = '[data-' + ATTR_SLIDER + ']';
var CLASSNAME_ENABLED = 'enabled';
var CLASSNAME_DISABLED = 'disabled';
var ATTR_ALLOWED = 'slider-allowed-property';

var SPACE_KEY_CODE = 32;

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a click on a slider node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleClick(event, elem) {
  var property = elem.data(ATTR_PROPERTY);

  if (elem.data(ATTR_ALLOWED) && !live(elem.data('uri')).get(elem.data(ATTR_ALLOWED))) {
    return;
  }

  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    toggleAndPublish(elem[0], property);

    // If no property is set, just flip the visual style and emit
    // a change event on center.
  } else {
    setState(elem[0], !elem.hasClass(CLASSNAME_ENABLED));
  }
}

/**
 * Handle a keyboard event on a slider node.
 *
 * @param {KeyboardEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleKeyUp(event, elem) {
  if (event.keyCode !== SPACE_KEY_CODE) {
    return;
  }

  handleClick(event, elem);
};

/**
 * Handle when a slider-set event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSliderSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SLIDER + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var enabled = !!event.enabled;

  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    toggleAndPublish(node, property, enabled);
  } else {
    setState(node, enabled);
  }
}

/**
 * Update the live model with new data. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 * @param {string} property A property name on the model.
 * @param {boolean=} opt_enabled Optional boolean flag. If true, this
 *     sets it to true, if false this sets it to false. If not provided,
 *     this sets it to the opposite of the current value in the model.
 */
function toggleAndPublish(node, property, opt_enabled) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_enabled === undefined ? !value : opt_enabled;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to update the visual state
  // of the button.
  model.publish(data);
}

/**
 * Update the state of one slider node.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 */
function updateNode(node) {

  // Don't handle the same URI and node twice.
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  var allowedProperty = elem.data(ATTR_ALLOWED);

  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, !!value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, !!properties[property]);
      }

      if (allowedProperty && allowedProperty in properties) {
        disableNode(node, !properties[allowedProperty]);
      }
    });
  });
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function setState(node, enabled) {
  updateNodeWithValue(node, enabled);
  emitUpdate(node, enabled);
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function updateNodeWithValue(node, enabled) {
  var elem = $(node);
  if (enabled) {
    elem.addClass(CLASSNAME_ENABLED);
  } else {
    elem.removeClass(CLASSNAME_ENABLED);
  }
}

/**
 * Update a slider node based on whether is disabled
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} disabled True if should be disabled, false otherwise.
 */
function disableNode(node, disabled) {
  var elem = $(node);
  if (disabled) {
    elem.addClass(CLASSNAME_DISABLED);
  } else {
    elem.removeClass(CLASSNAME_DISABLED);
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-slider attribute' || null,
 *   enabled: true // the new value
 * }
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if enabled, false otherwise.
 */
function emitUpdate(node, enabled) {
  var id = $(node).data(ATTR_SLIDER) || null;
  center.emit('slider-change', {
    element: node,
    id: id,
    enabled: enabled
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

/**
 * Update the module based on the current DOM state.
 *
 * @param {HTMLElement=} opt_node Optional DOM node to make changes inside.
 */
exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SLIDER);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_SLIDER, handleClick);
  doc.delegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.on('slider-set', onSliderSet);
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_SLIDER, handleClick);
  doc.undelegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.off('slider-set', onSliderSet);
};

},{"../spotify-elements":142,"../spotify-live":312,"./center":150}],191:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
require('../spotify-elements/attributes');
require('../spotify-elements/traversal');

var live = require('../spotify-live');
var center = require('./center');
var sortUriUtils = require('../spotify-live-sort-uri');

var UIInteraction4 = require('../spotify-logger/messages/UIInteraction4');

var ASC = 'tl-sort-asc';
var DESC = 'tl-sort-desc';

var handleSort = function handleSort(event, node) {
  var listNode = node.parent('[data-list]');
  if (!listNode) return;

  var uri = listNode.data('uri');
  if (!uri) return;

  var model = live(uri);

  var queryCurrent = sortUriUtils.getQuery(uri);
  var directionCurrent = sortUriUtils.getDirection(uri);

  var query = node.data('sort');

  var reverse = directionCurrent === 'asc' ? 'desc' : 'asc';
  var direction = queryCurrent === query ? reverse : 'asc';
  var reset = queryCurrent === query && directionCurrent === 'desc';

  var origin = sortUriUtils.getOriginUri(uri) || uri;

  var nextUri;
  if (reset) {
    nextUri = origin;
    query = null;
    direction = null;
  } else {
    nextUri = sortUriUtils.create(origin, direction, query);
  }

  // The first time a live model for the sorted URI is created, the sortlist
  // model will set up the sorting queries based on the URI.
  var nextList = live(nextUri);

  // We then need to trigger the sort to happen by asking for rows
  // The app itself will most likely request rows anyway, but by doing it
  // early might make it slightly faster.
  nextList.get('rows', function () {});

  var player = live('spotify:player');

  player.get('variant', function (error, context) {
    if (error) throw error;

    if (context && context.get('uri') === uri) {
      player.emit('update-context', {
        context: nextUri
      });
    }
  });

  setClassNames(listNode, query, direction);

  center.emit('sort-header-click', {
    uri: origin,
    requested: {
      query: query || null,
      direction: direction || null
    },
    current: {
      query: queryCurrent || null,
      direction: directionCurrent || null
    }
  });

  center.emit('list-swap', { before: uri, after: nextUri });

  UIInteraction4.log({
    feature_id: live('spotify:application').get('appURI') || 'unknown',
    section_id: 'sort-header',
    target_uri: nextUri,
    interaction_type: 'hit',
    user_intent: 'sort',
    timestamp: Math.round(Date.now() / 1000)
  });
};

var setClassNames = function setClassNames(list, opt_query, opt_direction) {

  var uri = list.data('uri');
  var query = opt_query !== undefined ? opt_query : sortUriUtils.getQuery(uri);
  var direction = opt_direction !== undefined ? opt_direction : sortUriUtils.getDirection(uri);
  var headers = list.search('[data-sort]');
  if (!headers) return;

  for (var i = 0, header; header = $(headers[i]); i++) {
    header.removeClass(ASC + ' ' + DESC);
    if (header.data('sort') === query) {
      header.addClass(direction === 'asc' ? ASC : DESC);
    }
  }
};

var handlePreviousProxyClick = function handlePreviousProxyClick(event, node) {
  handleSort(null, node.previousSibling());
};

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || $(document);

  var lists = node.matches('[data-list]') ? [node] : node.search('[data-list]');
  if (!lists) return;

  for (var i = 0, list; list = $(lists[i]); i++) {
    var headers = list.search('[data-sort]');
    if (!headers) continue;
    setClassNames(list);
  }
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', '[data-sort]', handleSort);
  $(document).delegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', '[data-sort]', handleSort);
  $(document).undelegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

},{"../spotify-elements":142,"../spotify-elements/attributes":138,"../spotify-elements/traversal":144,"../spotify-live":312,"../spotify-live-sort-uri":310,"../spotify-logger/messages/UIInteraction4":323,"./center":150}],192:[function(require,module,exports){
'use strict';

var throttle = require('./util/throttle');
var center = require('./center');
var sort = require('./sort');

var DEFAULT_STICKY_CLASS_NAME = 'sticky-top';
var TTL_STICKIES = 4000;
var TTL_POSITIONS = 0;

var isAttached = false;
var nodesGBCR = null;
var rootGBCR = null;
var timestamp;

var updateStickies = function updateStickies(nodes) {
  var rects = getRects(TTL_STICKIES);
  var scrollTop = window.scrollY;
  var width = rects.root.width;
  var top = rects.root.top;
  var height = 0;

  resetOldStickies();

  (nodes instanceof Array ? nodes : rects.nodes).forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;
    var stickyClone = node.stickyClone;
    var stickyClassName = nodeInfo.stickyClassName;

    // Check if the node should be sticked or not (if true, it should be).
    if (rect.top - top < scrollTop) {
      if (!(stickyClone || node).classList.contains(stickyClassName)) {
        // <THEAD>s can't be made sticky, so we clone it and add it to the DOM.
        if (node.nodeName.toLowerCase() === 'thead' && !node.stickyClone) {
          node = createClone(node);
        }

        node.classList.add(stickyClassName);

        // Update styles accordingly.
        node.setAttribute('data-sticky-active', '');
        node.style.right = width - rect.right + 'px';
        node.style.left = rect.left + 'px';
        node.style.position = 'fixed';
        node.style.top = height + 'px';
      } else {
        (stickyClone || node).style.top = height + 'px';
      }

      // Increment the top reference and the height. Do it even if the element is already sticked.
      height += rect.height;
      top += rect.height;
    } else {
      if ((stickyClone || node).classList.contains(stickyClassName)) {
        resetSticky(node);
      }
    }
  });
};

var updatePositions = function updatePositions() {
  var rects = getRects(TTL_POSITIONS);
  var width = rects.root.width;

  // Update left and right.
  rects.nodes.forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;

    if (node.stickyClone) {
      node = node.stickyClone;
    }

    if (node.classList.contains(nodeInfo.stickyClassName)) {
      node.style.right = width - rect.right + 'px';
      node.style.left = rect.left + 'px';
    }
  });
};

var resetSticky = function resetSticky(node) {
  // <THEAD>s can't be made sticky, so verify if we are using a clone and remove it from the DOM.
  if (node.nodeName.toLowerCase() === 'thead' && node.stickyClone) {
    removeClone(node);
  }

  node.classList.remove(getStickyClassName(node));

  // Update styles accordingly.
  node.removeAttribute('data-sticky-active', '');
  node.style.right = '';
  node.style.left = '';
  node.style.position = '';
  node.style.top = '';
};

var resetOldStickies = function resetOldStickies() {
  var selector = '[data-sticky-active]:not([data-sticky])';
  var nodes = document.querySelectorAll(selector);
  for (var i = 0, l = nodes.length; i < l; i++) {
    if (!nodes[i].isStickyClone) {
      resetSticky(nodes[i]);
    }
  }
};

var getRects = function getRects(ttl) {
  var reference = timestamp + ttl;
  var nodes = document.querySelectorAll('[data-sticky]');

  // Refresh timestamp (always).
  timestamp = Date.now();

  // If the reference time is still valid, and nodes are the same, then return data.
  if (reference > timestamp && nodesGBCR && nodes.length === nodesGBCR.length) {
    var equal = true;

    for (var i = 0; i < nodes.length; i++) {
      equal = equal && nodes[i] === nodesGBCR[i].node;
    }

    if (equal) {
      return {
        nodes: nodesGBCR,
        root: rootGBCR
      };
    }
  }

  // Otherwise, compute and cache.
  rootGBCR = document.documentElement.getBoundingClientRect();
  nodesGBCR = Array.prototype.map.call(document.querySelectorAll('[data-sticky]'), function (node) {
    var parentRect = node.parentNode.getBoundingClientRect();
    var nodeRect = node.getBoundingClientRect();

    // Return a structure per node. Only some fields are stored in the rect object (the ones used).
    return {
      stickyClassName: getStickyClassName(node),
      node: node,
      rect: {
        top: parentRect.top,
        height: nodeRect.height,
        left: parentRect.left,
        right: parentRect.right
      }
    };
  });

  return {
    nodes: nodesGBCR,
    root: rootGBCR
  };
};

var createClone = function createClone(node) {
  var div = document.createElement('div');
  var thead = node.cloneNode(true);
  var table = node.parentNode.cloneNode(false);
  var onListSwap;

  table.appendChild(thead).removeAttribute('data-sticky');
  div.appendChild(table);
  div.className = 'sticky-clone';
  div.isStickyClone = true;

  onListSwap = function onListSwap(data) {
    var table = thead.parentNode;
    var uri = table && table.getAttribute('data-uri');

    // Update the "data-uri" of the cloned table, and the sort state of the original one.
    if (uri) {
      table.setAttribute('data-uri', data.after);
      sort.update(node.parentNode);
    };
  };

  center.on('list-swap', onListSwap);

  node.parentNode.parentNode.appendChild(div);
  node.style.visibility = 'hidden';
  node.stickyListSwapListener = onListSwap;
  node.stickyClone = div;

  return div;
};

var removeClone = function removeClone(node) {
  var stickyClone = node.stickyClone;

  if (stickyClone.parentNode) {
    stickyClone.parentNode.removeChild(stickyClone);
  }

  if (node.stickyListSwapListener) {
    center.off('list-swap', node.stickyListSwapListener);
  }

  node.style.removeProperty('visibility');

  delete node.stickyClone;
  delete node.stickyListSwapListener;
};

var getStickyClassName = function getStickyClassName(stickyNode) {
  var root = document.documentElement;
  var classSticky;
  var node;

  for (node = stickyNode; node !== root; node = node.parentNode) {
    if (classSticky = node.getAttribute('data-class-sticky')) {
      return classSticky;
    }
  }

  return DEFAULT_STICKY_CLASS_NAME;
};

exports.DEFAULT_STICKY_CLASS_NAME = DEFAULT_STICKY_CLASS_NAME;

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;

    window.addEventListener('scroll', updateStickies);
    window.addEventListener('resize', updatePositions);
  }
};

exports.detach = function detach() {
  if (isAttached) {
    isAttached = false;

    window.removeEventListener('scroll', updateStickies);
    window.removeEventListener('resize', updatePositions);

    nodesGBCR = null;
    rootGBCR = null;
  }
};

exports.update = function (optNode) {
  if (isAttached) {
    nodesGBCR = null;
    rootGBCR = null;

    updateStickies();
  }
};

exports._getStickyClassName = getStickyClassName;

},{"./center":150,"./sort":191,"./util/throttle":203}],193:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": "items",
  "drag_tooltip_many_tracks": "tracks",
  "drag_tooltip_many_artists": "artists",
  "drag_tooltip_many_albums": "albums",
  "drag_tooltip_many_playlists": "playlists",
  "drag_tooltip_many_users": "users"
}
},{}],194:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var dom = require('./util/dom');

var SELECTOR_THUMBS_DOWN_BUTTON = '[data-button=thumbs-down]';
var SELECTOR_THUMBS_UP_BUTTON = '[data-button=thumbs-up]';

/**
 * Handle the click on a Thumbs button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleThumbsButtonClick(event, button) {
  var type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
  var trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  var contextUri = dom.getContextFromNodeOrParent(button[0]);

  // Must use track uri
  if (!trackUri || !contextUri) return;

  // Emit thumb event on context
  if (type === 'thumbs-down') {
    live(contextUri).emit('thumb-down', trackUri);
  } else if (type === 'thumbs-up') {
    live(contextUri).emit('thumb-up', trackUri);
  }
};

var isAttached = false;

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.delegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.undelegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

exports.update = function (optNode) {};

},{"../spotify-elements":142,"../spotify-live":312,"./util/dom":201}],195:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var zen = require('../spotify-elements/zen');

var tooltipMargin = 8; // We want some spacing around the tooltip

var tooltip = zen('div#tooltip');
var tooltipNode = tooltip[0];
var tooltipTextNode = zen('span')[0];
var tooltipArrowTop = zen('div.tooltip-arrow-top');
var tooltipArrowBottom = zen('div.tooltip-arrow-bottom');
tooltip.appendChild(tooltipArrowTop);
tooltip.appendChild(tooltipArrowBottom);
tooltip.appendChild(tooltipTextNode);

var attachedNode = null;
var tooltipNodeAttached = false;

// tooltipArrow will point to the current visible tooltipArrow
// that can be either tooltipArrowTop or tooltipArrowBottom
var tooltipArrow = null;

var addTooltipToDOM = function addTooltipToDOM() {
  document.body.appendChild(tooltipNode);
  tooltipNodeAttached = true;
};

var removeTooltipFromDOM = function removeTooltipFromDOM() {
  attachedNode = null;
  if (tooltipNode.parentNode) document.body.removeChild(tooltipNode);

  tooltipNodeAttached = false;
};

var showTooltip = function showTooltip(event, node) {
  var realNode = node[0];
  var top = 0;
  var left = 0;

  var tooltipText = node.data('tooltip') || node.getAttribute('title');
  if (!tooltipText) return;

  // Remember the node we set the text from so that text can be updated.
  attachedNode = node;

  if (!node.tooltipCheck) {
    node.removeAttribute('title');
    node.setAttribute('data-tooltip', tooltipText);
    node.tooltipCheck = true;
  }

  if (!tooltipNodeAttached) addTooltipToDOM();

  setText(tooltipText);

  var tooltipHeight = tooltipNode.clientHeight;
  var tooltipWidth = tooltipNode.offsetWidth;

  // Don't use window.scrollY because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var scrollY = window.pageYOffset;

  var bounds = realNode.getBoundingClientRect();
  var targetHeight = realNode.offsetHeight;
  var targetWidth = realNode.offsetWidth;
  var targetTop = parseInt(bounds.top) + scrollY;
  var targetLeft = parseInt(bounds.left);
  var targetCenter = targetLeft + targetWidth / 2;
  var targetBottom = targetTop + targetHeight;
  var viewportWidth = document.documentElement.clientWidth;
  var viewportHeight = document.documentElement.clientHeight;

  // Decide if the tooltip should be over or under the node
  if (targetBottom + tooltipHeight + tooltipMargin - scrollY > viewportHeight) {
    // On top
    top = targetTop - tooltipHeight - tooltipMargin;
    tooltipArrowTop.removeClass('visible');
    tooltipArrowBottom.addClass('visible');
    tooltipArrow = tooltipArrowBottom;
  } else {
    top = targetTop + targetHeight + tooltipMargin;
    if (top - scrollY > viewportHeight) {
      top = viewportHeight - tooltipHeight;
    }
    tooltipArrowTop.addClass('visible');
    tooltipArrowBottom.removeClass('visible');
    tooltipArrow = tooltipArrowTop;
  }

  var distanceToTheRight = viewportWidth - tooltipMargin - targetCenter;
  var distanceToTheLeft = targetCenter - tooltipMargin;
  var tooltipOffsetRight = Math.max(0, tooltipWidth / 2 - distanceToTheRight);
  var tooltipOffsetLeft = Math.max(0, tooltipWidth / 2 - distanceToTheLeft);

  left = targetCenter - tooltipWidth / 2 - (tooltipOffsetRight || -tooltipOffsetLeft);

  tooltipNode.style.top = top + 'px';
  tooltipNode.style.left = left + 'px';
  tooltipArrow[0].style.left = targetCenter - left + 'px';

  if (node.hasAttribute('data-tooltip-instant')) {
    tooltip.addClass('instant');
  } else {
    tooltip.removeClass('instant');
  }

  tooltip.addClass('visible');
};

var hideTooltip = function hideTooltip() {
  attachedNode = null;
  setText('');
  tooltip.removeClass('visible');
  tooltipNode.style.left = 0;
  tooltipNode.style.top = 0;
  if (tooltipArrow) {
    tooltipArrow[0].style.left = 0;
  }
};

var setText = function setText(text) {
  tooltipTextNode.innerHTML = text;
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('mouseover', '[data-tooltip]', showTooltip);
  doc.delegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.on('keydown', hideTooltip);
  doc.on('mousedown', hideTooltip);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  removeTooltipFromDOM();
  var doc = $(document);
  doc.undelegate('mouseover', '[data-tooltip]', showTooltip);
  doc.undelegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.off('keydown', hideTooltip);
  doc.off('mousedown', hideTooltip);
};

/** Forces an update of the tooltip text. */
exports.update = function update() {
  if (!isAttached) return;

  if (!attachedNode) return;

  if (attachedNode.data('tooltip')) {
    showTooltip(null, attachedNode);
  } else {
    // The tooltip no longer has text and should be hidden.
    hideTooltip();
  }
};

// Export for testing purposes
exports._setText = setText;

},{"../spotify-elements":142,"../spotify-elements/zen":145}],196:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');

var doc = $(document);
var hoverActive = true;

/* Store events in an array */
var touchArray = [];
var addEvent = function addEvent(touchEvent) {
  touchArray.push(touchEvent);
};

function getMediaObjects() {
  return doc.search('.media-object');
}

function isMediaObject(element) {
  return !!element.closest('.media-object');
}

function handleEvent(e) {
  var target = e.target;
  if (isMediaObject(target)) {
    switch (e.type) {
      case 'touchstart':
        addEvent(e);
        if (hoverActive) {
          disableHover(e);
        }
        break;

      case 'touchmove':
        addEvent(e);
        break;

      case 'touchend':

        if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
          e.preventDefault();
          target.click();
        }
        touchArray = [];
        break;

      case 'contextmenu':
        addEvent(e);
        break;

      case 'mousemove':
        if (!hoverActive) {
          enableHover(e);
        }
        break;
    }
  }
}

function disableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    mediaObjects.forEach(function (object) {
      // Find available hover elements
      var overlay = $(object).find('.mo-overlay');
      // Hide hover elements
      if (overlay) {
        var add = $(object).find('.mo-add');
        var play = $(object).find('.mo-play');
        var more = $(object).find('.mo-more');
        var del = $(object).find('.mo-delete');

        hide(overlay);
        if (add) {
          hide(add);
        }
        if (play) {
          hide(play);
        }
        if (more) {
          hide(more);
        }
        if (del) {
          hide(del);
        }
      }
    });
    hoverActive = false;
  }

  function hide(element) {
    element.addClass('not-visible');
  }
}

function enableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    // Show hover elements
    mediaObjects.forEach(function (object) {
      var elements = $(object).search('.not-visible');
      if (elements) {
        show(elements);
        hoverActive = true;
      }
    });
  }

  function show(element) {
    element.removeClass('not-visible');
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('touchstart', handleEvent);
  doc.on('touchmove', handleEvent);
  doc.on('touchend', handleEvent);
  doc.on('mousemove', handleEvent);
  doc.on('contextmenu', handleEvent);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('touchstart', handleEvent);
  doc.off('touchmove', handleEvent);
  doc.off('touchend', handleEvent);
  doc.off('mousemove', handleEvent);
  doc.off('contextmenu', handleEvent);
};

exports.update = function () {};

exports._reset = function () {
  hoverActive = true;
  touchArray = [];
};

},{"../spotify-elements":142}],197:[function(require,module,exports){
'use strict';

var prime = require('prime');
var Emitter = require('prime/emitter');
var Range = require('../../spotify-range2');

var SYNC = Emitter.EMIT_SYNC;

module.exports = prime({
  mixin: Emitter,

  constructor: function constructor(container, params) {
    this.container = container;

    this.height = params.height || 0;
    this.length = params.length || 0;

    this.tag = params.tag || 'li';
    this.request = params.request;

    // Unique call identificator.
    this._id = 0;

    this.reset();
  },

  resetFrom: function resetFrom(fromIndex, length, hiddenIndices) {
    var range = this._range;

    // Redirect the call to reset.
    if (fromIndex < range.end) {
      this.reset(length, hiddenIndices);
      this.show(range);
    }
  },

  reset: function reset(length, hiddenIndices) {
    var tag = this.tag;
    var totalHeight;

    if (typeof length !== 'undefined') {
      this.length = length;
    }

    totalHeight = this.length * this.height;

    // Hidden indices are not supported anymore (legacy).
    if (hiddenIndices) {
      throw new TypeError('Hidden indices are not supported anymore!');
    }

    this.container.innerHTML = '<' + tag + ' style="height:' + totalHeight + 'px"></' + tag + '>' + '<' + tag + ' style="height:0px"></' + tag + '>';

    this._range = new Range(0, 0);
    this._waitingRange = new Range(0, 0);

    // An array of ranges representing the visible nodes.
    this.emit('index-change', [], SYNC);
  },

  show: function show(range) {
    var length = this.length;
    var actual = this._range;
    var waiting = this._waitingRange;

    // Limit range to the [0, length) interval.
    var bound = new Range(Math.max(0, range.start), Math.min(length, range.end));

    // If the range requested is the same, do nothing.
    if (bound.start === actual.start && bound.end === actual.end) {
      return;
    }

    // If the range requested is the same, do nothing.
    if (bound.start === waiting.start && bound.end === waiting.end) {
      return;
    }

    this._drawRange(bound);
  },

  _drawRange: function _drawRange(range) {
    var container = this.container;
    var oldRange = this._range;
    var height = this.height;
    var length = this.length;
    var tag = this.tag;
    var id = ++this._id;
    var self = this;

    this._waitingRange = range;

    // Request the whole range. We will manually intersect later with the current one.
    this.request(range, function (err, nodes) {
      var oldLength = oldRange.length;
      var newLength = range.length;
      var diff = 0;
      var first;
      var last;
      var i;

      // If a new range has been requested in the meantime, don't draw/modify anything.
      if (id !== self._id) {
        return;
      }

      // Cache the range requested.
      self._range = range;
      self._waitingRange = new Range(0, 0);

      // Get first and last nodes as references. We will use them for removing/adding nodes.
      first = container.firstChild;
      last = container.lastChild;

      // Change heights of the paddings.
      first.style.height = range.start * height + 'px';
      last.style.height = (length - range.end) * height + 'px';

      // Remove old nodes. Since nodes change their position when removing them one by one,
      // we have to keep the cumulative sum of nodes removed cached.
      oldRange.subtract(range).forEach(function (subrange) {
        var length = subrange.length;

        for (i = 0; i < length; i++) {
          // We add one to the children index because the first child is not a row but the top padding.
          container.removeChild(container.children[subrange.start - oldRange.start - diff + 1]);
        }

        diff += length;
      });

      // Add new nodes. If the new nodes are below the old range, insert them at the top;
      // otherwise, insert them at the bottom.
      range.subtract(oldRange).forEach(function (subrange) {
        var length = subrange.length;
        var start = subrange.start - range.start;
        var subnodes = nodes.slice(start, start + length);
        var ref;

        // Emit a change before.
        self.emit('before-show', subrange, subnodes, SYNC);

        // Get the reference node. If the range is below, then insert at the top.
        // Otherwise, insert at the bottom.
        if (subrange.below(oldRange)) {
          ref = first.nextSibling;
        } else {
          ref = last;
        }

        for (i = 0; i < length; i++) {
          container.insertBefore(subnodes[i], ref);
        }

        // Emit a change after.
        self.emit('after-show', subrange, subnodes, SYNC);
      });

      self.emit('index-change', [range], SYNC);
    });
  }
});

},{"../../spotify-range2":352,"prime":515,"prime/emitter":514}],198:[function(require,module,exports){
'use strict';

var Position = function Position(containerIndex, index) {
  this.containerIndex = containerIndex;
  this.index = index;
};

Position.prototype.isSame = function (position) {
  return this.containerIndex === position.containerIndex && this.index === position.index;
};

module.exports = Position;

},{}],199:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');

function checkIfActive() {
  return live('spotify:application').get('active') || false;
}

function checkIfFocused() {

  // If the active element of the top frame has a contentWindow that matches
  // this window, it means the iframe of this app is in focus.
  var topActiveElement = window.top.document.activeElement;
  var activeWindow = topActiveElement && topActiveElement.contentWindow;
  if (activeWindow) {
    return activeWindow === window;
  }

  // Top frame (zlink)
  if (window.top === window) {
    return true;
  }

  return false;
};

exports.isActive = function () {
  return checkIfActive();
};

exports.isActiveAndFocused = function () {
  return checkIfActive() && checkIfFocused();
};

},{"../../spotify-live":312}],200:[function(require,module,exports){
/**
 * @module spotify-events/util/cosmos
 * @private
 */

'use strict';

var live = require('../../spotify-live');
var cosmos = require('spotify-cosmos-api');
var liburi = require('spotify-liburi');

var ASAP = live.ASAP;

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    live('spotify:client').query('currentUser(username)', function (error, data) {
      if (error) return callback(error);
      callback(null, url.replace('@', liburi.getCanonicalUsername(data.currentUser.username)));
    }, ASAP);
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

},{"../../spotify-live":312,"spotify-cosmos-api":554,"spotify-liburi":563}],201:[function(require,module,exports){
'use strict';

/**
 * @public
 */

/**
 * Get the context URI from the specified node or its parents.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string} The context URI or empty string if not found.
 */

function getContextFromNodeOrParent(node) {
  var contextNode = node.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
};

/**
 * Get the value for the passed attribute name, either from the passed node
 * or from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeFromNodeOrParent(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
};

exports.getContextFromNodeOrParent = getContextFromNodeOrParent;
exports.getAttributeFromNodeOrParent = getAttributeFromNodeOrParent;

},{}],202:[function(require,module,exports){
'use strict';

module.exports = function getLogContext(target) {
  var currentNode = target;
  var logContext = [];
  while (currentNode) {
    if (currentNode.matches && currentNode.matches('[data-log-context]')) {
      logContext.unshift(currentNode.getAttribute('data-log-context'));
    }
    currentNode = currentNode.parentNode;
  }
  return logContext.join('/') || null;
};

},{}],203:[function(require,module,exports){
'use strict';

var defer = require('prime/defer');

/**
 * Throttle the function calls to only trigger once per tick.
 * This will return a new function that you will use when you want
 * to call your function. Calling it multiple times in the same
 * run loop will only really call it once.
 *
 * @param {function} fn A function.
 * @param {Object=} opt_ctx The context to run the function in ('this').
 *
 * @return {function} A new function.
 */
function throttle(fn, opt_ctx) {
  var queued = false;
  var args;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      defer.frame(function () {
        queued = false;
        fn.apply(opt_ctx, args);
      });
    }
  };
}

module.exports = throttle;

},{"prime/defer":513}],204:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var update = function update(node) {

  var observables = ($(node) || $(document)).search('[data-watch]');

  if (observables) observables.forEach(function (node) {
    node = $(node);
    var key = node.data('watch');

    if (!key) return;

    var observed = node._observed || (node._observed = {});

    if (observed[key]) return;
    observed[key] = true;

    var parent;

    var uriNode = node[0].closest('[data-uri]');
    var uri = uriNode && uriNode.getAttribute('data-uri');

    if (!uri) return;

    var model = live(uri);

    var updateText = function updateText(event) {
      if (key in event) {
        var value = event[key];
        node.text(value == null ? '' : value);
      }
    };

    model.get(key, function (err, value) {
      if (err) throw err;
      var event = {};
      event[key] = value;
      updateText(event);
    });

    model.on('update', updateText);
  });
};

var isAttached = false;

exports.update = function (optNode) {
  if (!isAttached) return;

  update(optNode);
};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;
};

},{"../spotify-elements":142,"../spotify-live":312}],205:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":134,"./expose-debug-global":207}],206:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":207,"spotify-cosmos-api":554}],207:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        try {
          throw new Error();
        } catch (error) {
          if (!/injectedscript/i.test(error.stack)) {
            throw new Error('window.' + name + ' should only be accessed from the console');
          }
        }
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],208:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./expose-debug-global":207}],209:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": "{0} Mal abgespielt",
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Ansicht ist ein Fehler aufgetreten!",
  "ErrorMessage": "Diese Ansicht ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Ansicht ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
};
},{}],210:[function(require,module,exports){
module.exports = {
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": "Οπαδοί",
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": "{0} αναπαραγωγές",
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ράδιο",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Προέκυψε σφάλμα κατά την προβολή αυτής της οθόνης!",
  "ErrorMessage": "Η συγκεκριμένη προβολή δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η προβολή δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
};
},{}],211:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": "{0} plays",
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this view!",
  "ErrorMessage": "This view either does not exist or an error occurred.",
  "OfflineTitle": "This view is not available offline!",
  "OfflineMessage": "Please go online to load."
}
;
},{}],212:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta vista.",
  "ErrorMessage": "Puede ser que esta vista no exista, o bien, que haya ocurrido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Conéctate a la red para cargar."
};
},{}],213:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta vista.",
  "ErrorMessage": "Esta vista no existe o se ha producido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Por favor, conéctate para cargar."
};
},{}],214:[function(require,module,exports){
module.exports = {
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": "Seuraajat",
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": "{0} toistoa",
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tämän näkymän näyttämisessä on ongelmia.",
  "ErrorMessage": "Tätä näkymää ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Tätä näkymää ei voi käyttää offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
};
},{}],215:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": "Abonné",
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors du chargement de cet affichage!",
  "ErrorMessage": "L'affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette vue n'est pas disponible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
};
},{}],216:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": "Abonnés",
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cet affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cet affichage n'est pas disponible hors connexion.",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
};
},{}],217:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": "Követők",
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": "{0} lejátszás",
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Egy hiba miatt nem jeleníthető meg ez az oldal",
  "ErrorMessage": "A kért nézet nem létezik, vagy valamilyen műszaki hiba történt.",
  "OfflineTitle": "Ez a nézet internetkapcsolat nélkül nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
};
},{}],218:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": "{0} permainan",
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan tampilan ini!",
  "ErrorMessage": "Tampilan ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Tampilan ini tidak tersedia offline.",
  "OfflineMessage": "Alihkan ke online untuk memuat."
};
},{}],219:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": "Follower",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": "{0} riproduzioni",
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore in questa vista.",
  "ErrorMessage": "La vista non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa vista non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
};
},{}],220:[function(require,module,exports){
module.exports = {
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "Filter": "フィルター",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": "フォロワー",
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": "{0}回再生",
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "Pause": "一時停止",
  "Play": "曲の再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このビューを表示しようとしているときに問題が発生しました。",
  "ErrorMessage": "このビューが存在しないか、エラーが発生しました。",
  "OfflineTitle": "このページはオフラインで表示できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
};
},{}],221:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": "Volgers",
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": "{0} keer afgespeeld",
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het laden van deze weergave.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze weergave is offline niet beschikbaar!",
  "OfflineMessage": "Ga online om te laden."
};
},{}],222:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": "Obserwatorzy",
  "Following": "Obserwowana",
  "FollowingLabel": "Obserwowana",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": "Liczba odtworzeń: {0}",
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Podczas wyświetlania tego widoku wystąpił błąd!",
  "ErrorMessage": "Ten widok nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ten widok jest niedostępny w trybie offline. ",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
};
},{}],223:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": "{0} reproduções",
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta exibição!",
  "ErrorMessage": "A exibição não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa visualização não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
};
},{}],224:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": "Följare",
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": "{0} uppspelningar",
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här vyn skulle visas!",
  "ErrorMessage": "Den här vyn finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här vyn är inte tillgänglig offline.",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
};
},{}],225:[function(require,module,exports){
module.exports = {
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": "Takipçiler",
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": "{0} dinleme",
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu öğe görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu görünüm yok veya bir hata oluştu.",
  "OfflineTitle": "Bu görünüm çevrimdışıyken kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
};
},{}],226:[function(require,module,exports){
module.exports = {
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": "關注者",
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": "播放了 {0} 次",
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個畫面時出現問題。",
  "ErrorMessage": "這個畫面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法使用這個檢視！",
  "OfflineMessage": "請上網以載入。"
};
},{}],227:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": "{0} main",
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah memaparkan paparan ini!",
  "ErrorMessage": "Paparan ini sama ada tidak wujud atau ralat berlaku.",
  "OfflineTitle": "Paparan ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
};
},{}],228:[function(require,module,exports){
'use strict';

exports.getVersion = require('./src/version').getVersion;
exports.gridOverlay = require('./src/gridOverlay');

},{"./src/gridOverlay":229,"./src/version":230}],229:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
var DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
var GRID_BASELINE = 8;

var overlayElement = null;
var baselineHighlightElement = null;
var gridColor = '';
var highlightGridColor = '';
var gridModes = ['off', 'column', 'baseline'];
var currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  var spotify = global.__spotify;
  var productState = spotify && spotify.product_state;
  var appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      var data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  var newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  var mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  var pointerPos = event.clientY + window.scrollY;
  var yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  var y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = y - 1 + 'px';
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  var color = gridColor || DEFAULT_GRID_COLOR;

  var container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    var row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    var sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    var columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (var i = 0; i < 12; i++) {
      var column = document.createElement('div');
      column.className = 'grid-overlay-col-' + (i + 1) + ' ' + columnClassNames;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    var baselinePercentage = (GRID_BASELINE - 1) / GRID_BASELINE * 100 + '%';

    var backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', 'transparent ' + baselinePercentage + ', ', color + ' ' + baselinePercentage, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  var sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  var labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    var label = document.createElement('span');
    label.className = 'visible-' + size.id;
    label.textContent = size.name;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":554}],230:[function(require,module,exports){
'use strict';

// This should be removed later when nothing is calling this method

exports.getVersion = function () {
  return 1;
};

},{}],231:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../i18n/de.lang":209,"../i18n/el.lang":210,"../i18n/en.lang":211,"../i18n/es-419.lang":212,"../i18n/es.lang":213,"../i18n/fi.lang":214,"../i18n/fr-CA.lang":215,"../i18n/fr.lang":216,"../i18n/hu.lang":217,"../i18n/id.lang":218,"../i18n/it.lang":219,"../i18n/ja.lang":220,"../i18n/nl.lang":221,"../i18n/pl.lang":222,"../i18n/pt-BR.lang":223,"../i18n/sv.lang":224,"../i18n/tr.lang":225,"../i18n/zh-Hant.lang":226,"../i18n/zsm.lang":227,"dup":60}],232:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorTitle", options) : helperMissing.call(depth0, "loc", "ErrorTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorMessage", options) : helperMissing.call(depth0, "loc", "ErrorMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.errorTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.errorMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.errorEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"error-escape\">";
  if (helper = helpers.errorEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineTitle", options) : helperMissing.call(depth0, "loc", "OfflineTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineMessage", options) : helperMissing.call(depth0, "loc", "OfflineMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.offlineTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.offlineMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.offlineEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"offline-escape\">";
  if (helper = helpers.offlineEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"error-version text-muted\">";
  if (helper = helpers.errorVersion) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorVersion); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  ";
  return buffer;
  }

  buffer += "<div class=\"error-and-offline\" data-log-context=\"error-and-offline\">\n  <div class=\"container\">\n    <div class=\"error-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultError), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    <div class=\"offline-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultOffline), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.offlineEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </div>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorVersion), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],233:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  <div class=\"facepile\" data-tooltip title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-tooltip-instant>\n    <div class=\"media-object media-object-image media-object-link media-object-simple media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  options={hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.imageUrl) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n      data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      data-log-context=\"media-object\"\n      data-contextmenu>\n      <div class=\"mo-wrapper\">\n        <div class=\"mo-image-wrapper\">\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n            ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "show-placeholder";
  }

function program4(depth0,data,depth1) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <button\n    type=\"button\"\n    class=\"button facepile-badge\"\n    title=\"";
  if (helper = helpers.badgeTooltip) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeTooltip); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-tooltip\n    data-tooltip-instant\n    data-modal=\"spotify:modal:socialproof:"
    + escapeExpression(((stack1 = (depth1 && depth1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n  >\n    +";
  if (helper = helpers.badgeCount) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeCount); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  </button>\n";
  return buffer;
  }

  stack1 = (helper = helpers.facepile || (depth0 && depth0.facepile),options={hash:{},inverse:self.programWithDepth(4, program4, data, depth0),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options) : helperMissing.call(depth0, "facepile", (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./media/image.hbs":237,"hbsfy/runtime":403}],234:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./facepile-common.hbs');
HandlebarsCompiler.registerPartial('./facepile-common.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  buffer += "<div class=\"facepile-list\">\n	";
  stack1 = self.invokePartial(partials['./facepile-common.hbs'], './facepile-common.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"./facepile-common.hbs":233,"hbsfy/runtime":403}],235:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
var partial$1 = require('./media/controllers.hbs');
HandlebarsCompiler.registerPartial('./media/controllers.hbs', partial$1);
var partial$2 = require('./media/info.hbs');
HandlebarsCompiler.registerPartial('./media/info.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "data-context";
  }

function program3(depth0,data) {
  
  
  return "\"mo-wide-image-wrapper\"";
  }

function program5(depth0,data) {
  
  
  return "\"mo-image-wrapper\"";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" draggable=\"true\">\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  
  return "\n        </div>\n      ";
  }

function program13(depth0,data) {
  
  
  return "\n        </a>\n      ";
  }

  buffer += "<div class=\"media-object media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  options={hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-context=\"media-object\" data-log-data='{ \"name\": \"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }' data-contextmenu>\n  <div class=\"mo-wrapper\">\n    <div class=";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"mo-overlay\"></div>\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/controllers.hbs'], './media/controllers.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    ";
  stack1 = self.invokePartial(partials['./media/info.hbs'], './media/info.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./media/controllers.hbs":236,"./media/image.hbs":237,"./media/info.hbs":238,"hbsfy/runtime":403}],236:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "\" data-log-click=\"add-button\"></button>\n  ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  options={hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}
  if (helper = helpers.currentUserPlaylist) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.currentUserPlaylist); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.currentUserPlaylist) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "\" data-log-click=\"follow-button\"></button>\n    ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    data-button=\"play\"\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}
  if (helper = helpers.range) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.range); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.range) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-range=\"";
  if (helper = helpers.start) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.start); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ",";
  if (helper = helpers.end) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.end); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextPage), {hash:{},inverse:self.program(14, program14, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      data-button=\"play\"\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}
  if (helper = helpers.contextPage) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.contextPage); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.contextPage) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "";
  buffer += "data-context-page=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.trackUri), {hash:{},inverse:self.program(18, program18, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}
  if (helper = helpers.trackUri) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.trackUri); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.trackUri) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        data-button=\"play\"\n      ";
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = "";
  buffer += "data-track-uri=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program18(depth0,data) {
  
  
  return "\n        data-button=\"play-context\"\n      ";
  }

function program20(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "HoldToPreview", options) : helperMissing.call(depth0, "loc", "HoldToPreview", options)))
    + "\"";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <button type=\"button\" data-button=\"contextmenu\" class=\"button button-icon-only button-more mo-more\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\" data-log-click=\"context-menu-button\"></button>\n";
  return buffer;
  }

function program24(depth0,data) {
  
  
  return "\n<button type=\"button\" class=\"button button-icon-only mo-delete\" data-log-click=\"delete-button\"></button>\n";
  }

  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n<button type=\"button\" class=\"button button-play mo-play\" data-log-click=\"play-button\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.range), {hash:{},inverse:self.program(10, program10, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.preview) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.preview); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.preview) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n</button>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.canDelete) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.canDelete); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.canDelete) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],237:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image-background-color\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-image-background\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-wide-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }

  buffer += "<svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n  <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n  <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n  <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n  <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n  <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n  <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n  <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n  <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n</svg>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<span class=\"mo-verified\">\n  <span class=\"spoticon-check-16\"></span>\n</span>\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],238:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./../facepile-common.hbs');
HandlebarsCompiler.registerPartial('./../facepile-common.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "meta";
  }

function program3(depth0,data) {
  
  
  return "description";
  }

function program5(depth0,data) {
  
  
  return "socialproof";
  }

function program7(depth0,data) {
  
  
  return "subtitle";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\" draggable=\"true\">\n    ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\">\n    ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "\n      </div>\n    ";
  }

function program15(depth0,data) {
  
  
  return "\n      </a>\n    ";
  }

function program17(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      <div class=\"mo-subtitle text-muted one-line\">\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}
  if (helper = helpers.artists) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.artists); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.artists) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.owner) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.owner); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.owner) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program18(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"artist-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program20(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"owner-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-description\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = self.invokePartial(partials['./../facepile-common.hbs'], './../facepile-common.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-meta\">";
  if (helper = helpers.meta) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.meta); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"mo-info ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.socialproof), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options={hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-context=\"media-info\">\n  <div class=\"mo-info-wrapper\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        <span class=\"mo-title-border\">\n          ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n          <span class=\"ellipsis\">&nbsp;</span>\n        </span>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div class=\"media-link-hider\"></div>\n    ";
  if (helper = helpers.customContent) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.customContent); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./../facepile-common.hbs":233,"hbsfy/runtime":403}],239:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += " data-navbar-item-matcher=\"";
  if (helper = helpers.matcher) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.matcher); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <a href=\"";
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" draggable=\"false\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n  ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.program(8, program8, data),fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <a data-log-click=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" draggable=\"false\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n  ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <p class=\"navbar-text\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n  ";
  return buffer;
  }

  buffer += "<li class=\"";
  if (helper = helpers.className) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.className); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-navbar-item-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.matcher), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.url), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</li>\n";
  return buffer;
  });

},{"hbsfy/runtime":403}],240:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./navbar-item.hbs');
HandlebarsCompiler.registerPartial('./navbar-item.hbs', partial$0);
var partial$1 = require('./facepile.hbs');
HandlebarsCompiler.registerPartial('./facepile.hbs', partial$1);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "no-overflow-menu";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./navbar-item.hbs'], './navbar-item.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n          <li class=\"overflow-menu-button\" data-navbar-item-id=\"navbar-overflow-menu\">\n            <a>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "</a>\n          </li>\n        ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n            <div class=\"navbar-right facepile-list-container\">\n              ";
  stack1 = self.invokePartial(partials['./facepile.hbs'], './facepile.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            </div>\n          ";
  return buffer;
  }

  buffer += "<div class=\"navbar-fixed-wrapper\" data-sticky-fixed-wrapper>\n  <div class=\"navbar\" data-sticky=\"true\">\n    <div class=\"container\">\n      <ul class=\"nav navbar-nav ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noOverflowMenu), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-navbar=\"navbar\"\n        data-navbar-history-position=\"";
  if (helper = helpers.historyPosition) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.historyPosition); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        data-navbar-active-id=\"";
  if (helper = helpers.activeTab) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.activeTab); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        data-log-context=\"navbar\">\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers['nav-items']) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0['nav-items']); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers['nav-items']) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.noOverflowMenu), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </ul>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"./facepile.hbs":234,"./navbar-item.hbs":239,"hbsfy/runtime":403}],241:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],242:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],243:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, totalCount, mT, opts) {
  var options = opts;
  var minThresh = mT;

  if (!list) {
    return '';
  }

  if (arguments.length < 4) {
    options = minThresh;
    minThresh = 3;
  }

  minThresh = minThresh || 3;

  var len = list.length;
  var thresh = Math.min(minThresh, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden listeners.
  if (totalCount > thresh) {
    ret += options.inverse({
      badgeCount: totalCount - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), totalCount - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":250}],244:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":257}],245:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":249}],246:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');
exports.json = require('./json');

},{"./compare":241,"./duration":242,"./facepile":243,"./href":244,"./humanize-duration":245,"./json":247,"./list":248,"./loc":249,"./name-list-tooltip":250,"./numeral":251,"./share":252,"./slice":253,"./type":254,"./user-reaction":255}],247:[function(require,module,exports){
'use strict';

var json = function json(context) {
  return JSON.stringify(context);
};

json.displayName = 'json';

module.exports = json;

},{}],248:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":396,"mout/array/map":473}],249:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mixIn = require('mout/object/mixIn');
var slice_ = Array.prototype.slice;

var storage = {};

var loc = function loc(key) {
  var value = storage[key];

  if (!value) return '';

  var args = slice_.call(arguments, 1);
  var options = {};

  if (_typeof(args[args.length - 1]) === 'object') {
    options = args.pop();
  }

  var hash = options.hash;

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  mixIn(storage, object);
  return this;
};

module.exports = loc;

},{"mout/object/mixIn":504}],250:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":249}],251:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":335,"mout/lang/isNumber":488}],252:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":257}],253:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":396,"mout/array/forEach":470,"mout/array/map":473,"mout/lang/kindOf":492}],254:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":258}],255:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":249}],256:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":396,"mout/lang/kindOf":492}],257:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],258:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],259:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Translations = require('../spotify-translations');
var glueLocales = require('../spotify-glue-cat/strings');

module.exports = function (localeToStrings) {
  if (!localeToStrings || (typeof localeToStrings === 'undefined' ? 'undefined' : _typeof(localeToStrings)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    return typeof window !== 'undefined' && window.__spotify && window.__spotify.locale || 'en';
  }

  var locales = localeToStrings;
  var i18n = new Translations();
  i18n.injectData(locales[getClientLocale()] || {});

  return {
    locale: getClientLocale,
    get: i18n.get.bind(i18n),

    glueStrings: function glueStrings() {
      return glueLocales[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../spotify-glue-cat/strings":231,"../spotify-translations":353}],260:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:filterlist';
var regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

/**
 * Create a URI representing a filtered variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} query The query string (compatible with Core). Filter
 *     implementations might not look at all values.
 *
 * @return {string} URI of the filtered variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);

  return [base, query, originUri].join(':');
};

/**
 * Get the query string from a filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[1]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The URI of the original list. If the filter URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[2];
};

/**
 * Parse and return all parts of the filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return null;

  return {
    query: decodeURIComponent(matches[1]),
    originUri: 'spotify:' + matches[2]
  };
};

/**
 * Test if the provided URI is a valid filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (filterUri) {
  return regExp.test(filterUri);
};

/**
 * The regular expression that matches filter URIs.
 */
exports.regExp = regExp;

},{}],261:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  changes: 'hm://collection-web/v1/@/changes',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  // Currently, we only store tracks in collection2, and derive albums from
  // these. Because of this, we only get tracks in the pubsub events, but
  // adding/removing a track might have altered the calculated Collection state
  // of its album. To check this, we pass the change set down to
  // the changes endpoint and will receive a list of objects with
  // uri and isInCollection properties that we can forward to live.
  cosmos.sanitizeURL(endpoints.changes, function (error, url) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this map once FESK-1921 is fixed.
    response.body.items = response.body.items.map(function (item) {
      item.type = item.type.toUpperCase();
      return item;
    });
    // End hack alert

    cosmos.post({ url: url, body: response.body }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      response.body.items.forEach(function (item) {
        if (item.hasOwnProperty('isInCollection') && !item.hasOwnProperty('added')) {
          // Patch items to contain added
          item.added = item.isInCollection;
        }
      });
      live(response.body.items);
    });
  });
};

var albumCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:album:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  albumCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', albumCollection.onPublish);
  live.subscribe(regExp, 'wait', albumCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', albumCollection.onPublish);
  live.unsubscribe(regExp, 'wait', albumCollection.onWait);

  albumCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../util/cosmos":308,"./collection":263}],262:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:artist:/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":267}],263:[function(require,module,exports){
(function (global){
'use strict';

// This model will take a URI and create a live model for that URI.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * If the changed property was "added", it will contact
//   the backend to update the stored collection state. If this
//   fails, it will set it to the opposite of what was pusblished.
//
// * On success, broadcast the changes to the rest of the client via
//   cosmos, as "isInCollection" / "isFollowing" and as "added".
//
// This model will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This model will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var prime = require('prime');
var defer = require('prime/defer');

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var cosmos = require('../util/cosmos');

var INSUFFICIENT_STORAGE = 507;

// COLLECTION

var Collection = prime({

  constructor: function constructor(endpoints) {
    var self = this;
    this.endpoints = endpoints;
    this.onPublish = this.onPublish.bind(this);
    this.waitQueue = [];
    this.onWait = this.onWait.bind(this);
    this.fetch = this.fetch.bind(this);
  },

  onPublish: function onPublish(model, data) {
    // If the property is "added", update the backend with the new value
    // If the update fails, revert the state
    // If the update does not fail, broadcast the new state, as "isInCollection" and "added"
    if ('added' in data) {

      var endpoints = this.endpoints;
      var state = !!data.added;

      // optimistic
      model.update({ added: state });

      var method = state ? 'post' : 'delete';
      this._publish(method, [model], function (error, data) {
        if (error) {
          // that's what being optimistic gets you
          model.update({ added: !state });
          if (error.response && error.response.getStatusCode() === INSUFFICIENT_STORAGE) {
            cosmos.post({
              url: 'sp://messages/v1/container/user-message',
              body: { id: 'collection-limit-exceeded' }
            });
          }
        } else {
          cosmos.post({ url: endpoints.broadcast, body: { uri: model.uri, isInCollection: state, added: state } });
          if (data && data.items) {
            data.items.forEach(function (item) {
              // Patch items to contain added
              item.added = item.isInCollection;
              cosmos.post({ url: endpoints.broadcast, body: item });
            });
          }
        }
      });
    }
  },

  onWait: function onWait(model, properties) {
    if (contains(properties, 'added')) {
      this.fetch(model);
    }
  },

  fetch: function fetch(model) {
    var endpoints = this.endpoints;
    var queue = this.waitQueue;

    queue.push(model);

    // The first thing that gets added to the queue should defer a batch fetch
    // for the next tick. On the next tick, it will batch fetch status for all
    // models added to the queue.
    if (queue.length === 1) {
      defer(this._fetchBatch, this);
    }
  },

  _fetchBatch: function _fetchBatch() {
    var queue = this.waitQueue;
    if (queue.length === 0) return;

    // Create a new queue for requests coming after this
    this.waitQueue = [];

    this._contains(queue, function (error, result) {
      // Collection returns 404 for a user without a collection. This is sent as an error,
      // but we will just interpret that as `isInCollection` is false. All other errors
      // we just throw.
      if (error && (!error.response || error.response && error.response.getStatusCode() !== 404)) {
        if (global.console) console.error(error);
        return;
      }

      queue.forEach(function (model, i) {
        var added = false;
        if (!error) added = result[i];
        model.update({ added: added });
      });
    });
  },

  _contains: function _contains(models, callback) {
    var url = this.endpoints.isInCollection;
    var body = this._getRequestBody(models);

    cosmos.post({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body && result.body.found);
    });
  },

  _publish: function _publish(method, models, callback) {
    var url = this.endpoints.updateIsInCollection;
    var body = this._getRequestBody(models);

    cosmos[method]({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body);
    });
  },

  _getRequestBody: function _getRequestBody(models) {
    return {
      items: models.map(function (model) {
        return model.uri;
      }),
      source: global.__spotify && global.__spotify.app_uri || null
    };
  }

});

// ----------------------

Collection.onBroadcast = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var value;
  if ('added' in response.body) value = response.body.added;
  // Deal with older versions of this package that send isInCollection / isFollowing
  else if ('isInCollection' in response.body) value = response.body.isInCollection;

  live(response.body.uri).update({
    added: value
  });
};

module.exports = Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../util/cosmos":308,"mout/array/contains":463,"prime":515,"prime/defer":513}],264:[function(require,module,exports){
'use strict';

var album = require('./album');
var artist = require('./artist');
var playlist = require('./playlist');
var track = require('./track');
var user = require('./user');
var local = require('./local');

exports.register = function () {
  album.register();
  artist.register();
  playlist.register();
  track.register();
  user.register();
  local.register();
};

exports.unregister = function () {
  album.unregister();
  artist.unregister();
  playlist.unregister();
  track.unregister();
  user.unregister();
  local.unregister();
};

},{"./album":261,"./artist":262,"./local":265,"./playlist":266,"./track":268,"./user":269}],265:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var onWait = function onWait(model, properties) {
  if (contains(properties, 'added')) {
    // Neither tracks nor albums or artists can ever be added to YM.
    model.update({ added: false });
  }
};

// Matches local track, albums and artists.
var regExp = exports.matches = /^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../../spotify-live":312,"mout/array/contains":463}],266:[function(require,module,exports){
(function (global){
'use strict';

// The 'playlist' function will be called when a new live object is
// created for the pattern in playlist.matches. We use this function
// to automatically add data to the live model when requested, and to
// push any needed updates to the backend.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was `added`, it will contact
//   the backend to update the stored collection state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var contains = require('mout/array/contains');

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('../util/cosmos');
var bridge = require('../util/bridge').request;

var endpoints = {
  broadcast: 'sp://messages/v1/followstate'
};

function onPublish(model, data) {
  // If the property is "added", update the backend with the new
  // value. If the update fails somewhere along the way, revert the state
  // and broadcast the reverted state to the rest of the client.
  if ('added' in data) {
    model.update({ added: data.added });

    if (model.get('followersCount') != null) {
      model.update({
        followersCount: model.get('followersCount') + (data.added ? 1 : -1)
      });
    }

    updateBackend(model, !!data.added, function (error) {
      if (error) {
        // Revert optimistic change
        model.update({ added: !data.added });

        if (model.get('followersCount') != null) {
          model.update({
            followersCount: model.get('followersCount') + (!data.added ? 1 : -1)
          });
        }
      } else {
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var value;
  if ('added' in response.body) {
    value = response.body.added;
  } else if ('isFollowing' in response.body) {
    value = response.body.isFollowing;
  }

  if (value !== undefined) {
    live(response.body.uri).update({
      added: value
    });
  }
}

function fetchAdded(model) {
  cosmos.get({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata',
    body: {
      policy: {
        followed: true
      }
    }
  }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      added: response.body.metadata.followed
    });
  });
}

function fetchFollowersCount(model) {
  bridge('playlist_subscribers_snapshot', [{ type: 'list', uri: model.uri }, 0, 0], function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      followersCount: data.length
    });
  });
}

function getRequestData(callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(username)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      username: data.currentUser.username
    });
  });
}

function broadcast(model) {
  var value = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: value,
      added: value
    }
  });
}

function updateBackend(model, added, callback) {
  if (added) {
    cosmos.post({
      url: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        uris: [model.uri],
        before: 'start'
      }
    }, function (error, response) {
      if (error) return callback(error);
      model.update({
        added: true
      });
      callback(null);
    });
  } else {
    // Removing using Core needs the `rowId`, which we don't necessarily have,
    // so stick with old bridge message for now. It's only adding that needs to
    // be done using Core to fix KM-8804.
    bridge('library_unsubscribe', [liburi.profileURI(__spotify.username).toURI(), model.uri], function (error, data) {
      if (error) return callback(error, data);
      callback(null, data);
    });
  };
}

var onWait = function onWait(model, properties) {
  var needsAdded = contains(properties, 'added');
  var needsFollowersCount = contains(properties, 'followersCount');
  if (needsAdded) {
    var subscribed = model.get('subscribed');
    if (subscribed !== undefined) {
      model.update({ added: subscribed });
    } else {
      fetchAdded(model);
    }
  }
  if (needsFollowersCount) {
    fetchFollowersCount(model);
  }
};

var regExp = exports.matches = /^spotify:user:[^:]+:playlist:[^:]+$/;

var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'wait', onWait);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'wait', onWait);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../util/bridge":306,"../util/cosmos":308,"mout/array/contains":463,"spotify-liburi":563}],267:[function(require,module,exports){
(function (global){
'use strict';

// This model will, when registered to live, listen for publish
// events on the live model. The publish events are only triggered
// when someone actually wants to update something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was isFollowing, it will contact
//   the backend to update the stored following state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// * If the changed property was isFollowing, it will automatically
//   update followersCount on the live model.
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.
//

var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var requestsInProgress = {};

var endpoints = {
  isFollowing: 'hm://socialgraph/v2/is_following?format=json',
  followCounts: 'hm://socialgraph/v2/counts?format=json',
  updateIsFollowing: 'hm://socialgraph/v2/following?format=json',
  broadcast: 'sp://messages/v1/followstate'
};

function onUpdate(model, data) {

  // Only update followers count if that data was not present in the changed data
  if ('added' in data && !('followersCount' in data)) {
    var followersCount = model.get('followersCount');
    if (followersCount !== undefined) {
      var newFollowersCount = followersCount + (data.added ? 1 : -1);
      model.update({ followersCount: newFollowersCount });
    }
  }
}

function onPublish(model, data) {
  // If the property is added, update the backend with the new value.
  // If the update fails, revert the model state.
  // If the update is successful, broadcast the state to the client.
  if ('added' in data) {
    // if there is a request in course, do not launch a new request
    // as this can mess up with the Backend
    if (requestsInProgress[model.uri]) {
      return;
    }
    requestsInProgress[model.uri] = true;

    // we're optimistic this will work
    model.update({ 'added': data.added });

    updateBackend(model, !!data.added, function (error) {
      // request finished, we can accept more requests now
      delete requestsInProgress[model.uri];
      if (error) {
        // such is life.
        model.update({ added: !data.added });
      } else {
        model.update({ added: data.added });
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var body = response.body;
  var data = {};

  if ('added' in body) data.added = body.added;
  // Also accept broadcast from older versions that only send "isFollowing"
  else if ('isFollowing' in body) data.added = body.isFollowing;

  if ('followersCount' in body) data.followersCount = body.followersCount;
  if ('followingCount' in body) data.followingCount = body.followingCount;

  live(body.uri).update(data);
}

function onWait(model, properties) {
  if (intersection(properties, followProperties).length) getRequestData(model, function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    updateIsFollowing(model, data);
    updateCounts(model, data);
  });
}

function updateIsFollowing(model, requestData, opt_callback) {
  var options = {
    url: endpoints.isFollowing,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var value = response.body[0].is_following;
    model.update({ added: value });

    if (opt_callback) opt_callback();
  });
}

function updateCounts(model, requestData, opt_callback) {
  var options = {
    url: endpoints.followCounts,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var body = response.body[0];

    model.update({
      followersCount: body.followers_count,
      followingCount: body.following_count
    });

    if (opt_callback) opt_callback();
  });
}

function getRequestData(model, callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(uri)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
      // rather than spotify:user:someone%21). `currentUser(uri)` returns a
      // uri-encoded user name.
      source_uri: decodeURIComponent(data.currentUser.uri),
      target_uris: [decodeURIComponent(model.uri)]
    });
  });
}

function updateBackend(model, isFollowing, callback) {

  getRequestData(model, function (error, data) {
    if (error) return callback(error);
    var requestMethod = isFollowing ? 'post' : 'delete';
    cosmos[requestMethod]({ url: endpoints.updateIsFollowing, body: data }, function (error) {
      if (error) return callback(error);
      callback(null);
    });
  });
}

function broadcast(model) {
  var added = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: added,
      added: added,
      followersCount: model.get('followersCount'),
      followingCount: model.get('followingCount')
    }
  });
}

var followProperties = ['added', 'followersCount', 'followingCount'];

var broadcastSubscription;

exports.register = function (regExp) {
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'publish', onPublish);

  // reset the requestsInProgress variable
  requestsInProgress = {};

  if (!broadcastSubscription) {
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  }
};

exports.unregister = function (regExp) {
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../util/cosmos":308,"mout/array/intersection":472}],268:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var items = response.body.items;
  items.forEach(function (item) {
    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this once FESK-1921 is fixed.
    if (item.type.toUpperCase() === 'TRACK') {
      var uri = 'spotify:track:' + item.identifier;
      live(uri).update({ added: !item.removed });
    }
  });
};

var trackCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:track:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  trackCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', trackCollection.onPublish);
  live.subscribe(regExp, 'wait', trackCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', trackCollection.onPublish);
  live.unsubscribe(regExp, 'wait', trackCollection.onWait);

  trackCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../util/cosmos":308,"./collection":263}],269:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":267}],270:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/album
 */
'use strict';

var live = require('../spotify-live');

var liburi = require('spotify-liburi');

var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');

var bridge = require('./util/bridge').request;

function isLocalAlbum(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ALBUM;
}

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalAlbum(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      var data = {
        local: true,
        name: uriObject.album,
        artists: [{
          uri: 'spotify:local:',
          name: '',
          local: true
        }]
      };
      if (uriObject.artist) {
        data.artists[0].uri = liburi.localArtistURI(uriObject.artist).toURI();
        data.artists[0].name = uriObject.artist;
        data.artists[0].local = true;
      }
      model.update(data);
    }
  } else {
    bridge('album_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalAlbum(model.uri)
  });
}

var idCounter = 1000;

function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

function updateRows(model) {
  var descriptor = { type: 'list', uri: model.uri };

  bridge('album_tracks_snapshot', [descriptor, 0, 0, false], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    bridge('album_tracks_snapshot', [descriptor, 0, payload.length, false], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var discs = [];
      var uriId = liburi.from(model.uri).id;

      var rows = payload.metadata && payload.metadata.map(function (trackdata, i) {
        var track = mixIn({ uri: payload.array[i] }, trackdata);
        var discNum = track.disc ? track.disc - 1 : 0;
        track.unavailable = !track.playable;
        setLocalProperty(track);
        if (!discs[discNum]) {
          discs[discNum] = {
            rows: [],
            uri: uriId ? liburi.albumURI(uriId, discNum + 1).toURI() : ''
          };
        }
        var uri = getRowUri(track.uri);
        var trackObject = {
          track: track,
          uri: uri
        };
        discs[discNum].rows.push(trackObject);
        return trackObject;
      });

      model.update({ rows: rows, discs: discs });
    });
  });
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    track.album.local = isLocalAlbum(track.album.uri);
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        artist.local = isLocalArtist(artist.uri);
      }
    }
  }
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasRows = contains(properties, 'rows');
  var hasDiscs = contains(properties, 'discs');

  var metaFields = ['artists', 'image', 'images', 'name', 'playable', 'type', 'availability', 'date', 'label', 'copyrights'];

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasRows || hasDiscs) updateRows(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/bridge":306,"mout/array/contains":463,"mout/array/intersection":472,"mout/object/mixIn":504,"spotify-liburi":563}],271:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/application
 */
'use strict';

var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var AppState = require('../spotify-navigation/app-state');

var BACKOFF = 100;

function onMessage(message) {
  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      live('spotify:application').update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      live('spotify:application').update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      live('spotify:application').update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

function applicationReplaceUri(model, event) {

  // This is intended to work like history.replace in the browser.

  // Desktop can also replace further back, so the current appURI needs
  // to be passed.
  // Link can't replace further back anyway, so anything thruthy as the
  // second argument will just replace the current.

  model.get('appURI', function (error, appUri) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    bridge('application_open_uri', [event.uri, appUri]);
  });
}

var regExp = exports.matches = /^spotify:application$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.addEventListener('message', onMessage);
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"../spotify-navigation/app-state":331,"./util/bridge":306,"mout/array/contains":463}],272:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/artist
 */
'use strict';

var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalArtist(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      model.update({
        local: true,
        name: uriObject.artist
      });
    }
  } else {
    bridge('artist_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      if (!payload.image && !model.get('image')) payload.image = '';
      if (!payload.images && !model.get('images')) payload.images = [];
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalArtist(model.uri)
  });
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasMetadata = false;
  var metaFields = ['image', 'images', 'name', 'popularity'];
  for (var i = 0, l = properties.length; i < l; i++) {
    if (contains(metaFields, properties[i])) {
      hasMetadata = true;
      break;
    }
  }

  if (hasMetadata) updateMetadata(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:artist:|^spotify:local:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/bridge":306,"mout/array/contains":463,"spotify-liburi":563}],273:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:client-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change. Would be great with a future live API
  // to see if someone has implemented a specific model.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'client_storage',
    name: 'broadcast_client_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'client_storage',
    name: 'set_client_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);
  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/cosmos":308,"mout/array/combine":462,"mout/array/contains":463,"mout/array/remove":474,"mout/object/forOwn":500}],274:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var liburi = require('spotify-liburi');

var BACKOFF = 100;

function updateCurrentUser(model) {
  bridge('user_metadata', ['spotify:user:@'], function (error, payload) {
    if (error) {
      if (global.__spotify && global.__spotify.username) {
        var username = global.__spotify.username;
        model.update({
          currentUser: {
            uri: liburi.profileURI(username).toURI(),
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: liburi.profileURI(payload.username).toURI(),
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  var __spotify = global.__spotify || {};
  var containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    var update = {};
    for (var i = 0, property; property = properties[i]; i++) {
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  model.update({
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    var username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

var regExp = exports.matches = /^spotify:client$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/bridge":306,"spotify-liburi":563}],275:[function(require,module,exports){
'use strict';

var live = require('../spotify-live');
var cosmos = require('./util/cosmos');

function onWait(model, properties) {
  model.on('wait', function (keys) {
    if (keys.indexOf('episode') > -1) {
      cosmos.get({
        url: 'sp://core-show/unstable/decorate',
        body: { items: [model.uri] }
      }, function (error, data) {
        if (error) throw error;

        var episode = data.body.items[model.uri];
        model.update({ episode: episode });
      });
    }
  });
}

var regExp = exports.matches = /^spotify:episode:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../spotify-live":312,"./util/cosmos":308}],276:[function(require,module,exports){
'use strict';

var album = require('./album');
var application = require('./application');
var artist = require('./artist');
var client = require('./client');
var clientStorage = require('./client-storage');
var sessionStorage = require('./session-storage');
var player = require('./player');
var playlist = require('./playlist');
var sortlist = require('./sortlist');
var track = require('./track');
var user = require('./user');
var add = require('./add');
var localFiles = require('./local-files');
var listVariant = require('./list-variant');
var episode = require('./episode');

exports.register = function () {
  album.register();
  application.register();
  artist.register();
  client.register();
  clientStorage.register();
  sessionStorage.register();
  player.register();
  playlist.register();
  sortlist.register();
  track.register();
  user.register();
  add.register();
  localFiles.register();
  listVariant.register();
  episode.register();
};

exports.unregister = function () {
  album.unregister();
  application.unregister();
  artist.unregister();
  client.unregister();
  clientStorage.unregister();
  sessionStorage.unregister();
  player.unregister();
  playlist.unregister();
  sortlist.unregister();
  track.unregister();
  user.unregister();
  add.unregister();
  localFiles.unregister();
  listVariant.unregister();
  episode.unregister();
};

},{"./add":264,"./album":270,"./application":271,"./artist":272,"./client":274,"./client-storage":273,"./episode":275,"./list-variant":277,"./local-files":278,"./player":283,"./playlist":287,"./session-storage":288,"./sortlist":296,"./track":304,"./user":305}],277:[function(require,module,exports){
/**
 * @module spotify-live-models/list-variant
 */
'use strict';

var contains = require('mout/array/contains');
var showUnplayableTracks = require('./util/unplayable-tracks-playlist-setting.js');
var legacySortUris = require('./sorting/legacy-sort-uris');

var live = require('../spotify-live');
var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');
var URI = require('spotify-liburi');

var SESSION_STORAGE = 'spotify:session-storage';
var CLIENT_STORAGE = 'spotify:client-storage';
var SORT_VARIANT_KEY = 'list-variant-';
var STRING_FILTER_KEY = 'list-filter-string-';

var sessionStorageListeners = {};

function onWait(model, properties) {
  if (!contains(properties, 'listVariant')) {
    return;
  }

  var uri = getOriginUri(model.uri);

  // listVariant objects are shared amongst all variants.
  var listVariant = live(uri).get('listVariant');
  if (!listVariant) {
    listVariant = live({
      origin: {
        uri: uri
      }
    });
    listVariant.on('wait', onVariantWait.bind(null, listVariant));
  }

  model.update({ listVariant: listVariant });

  // If the model is a variant, set that list variant on the origin too
  // so it can be accessed there for the next variant to ask.
  if (uri !== model.uri) {
    live(uri).update({ listVariant: listVariant });
  }
}

function onVariantWait(model, properties) {
  if (contains(properties, 'currentUri')) {
    addAndWatchCurrentUri(model);
    // This will fulfill and watch all other properties
    return;
  }

  if (contains(properties, 'filterString')) {
    addAndWatchFilterString(model);
  }
  if (contains(properties, 'sortQuery') || contains(properties, 'sortDirection') || contains(properties, 'sortUri')) {
    addAndWatchSortQuery(model);
  }
  if (contains(properties, 'showUnplayable')) {
    addAndWatchUnplayable(model);
  }
}

function addAndWatchCurrentUri(model) {

  model.on('update', update);
  update();

  function update() {
    var props = 'filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)';
    model.query(props, function (error, data) {
      if (error) {
        console.error('Error when getting', props, ':', Error);
        return;
      }

      var result = data.origin.uri;
      var filters = [];

      if (data.filterString) {
        filters.push('text contains ' + encodeURIComponent(data.filterString));
      }

      if (!data.showUnplayable) {
        filters.push('playable eq true');
      }

      if (filters.length) {
        result = filterUriUtils.create(result, filters.join(','));
      }

      var sortUriParams = data.sortUri && sortUriUtils.parse(data.sortUri);

      if (sortUriParams) {
        result = sortUriUtils.create(result, sortUriParams.direction, sortUriParams.query);
      }

      model.update({
        currentUri: result
      });
    });
  }
}

var showUnplayablePref;
var updateUnavailablePrefOn = [];

function addAndWatchUnplayable(model) {
  var uri = model.get('origin').uri;
  var type = URI.fromString(uri).type;

  if (type !== URI.Type.PLAYLIST) {
    model.update({ showUnplayable: true });
    return;
  }

  updateUnavailablePrefOn.push(model);
  if (showUnplayablePref != null) {
    model.update({ showUnplayable: showUnplayablePref });
    return;
  }

  showUnplayableTracks.subscribe(function (error, showUnplayable) {
    // Cache this globally as we will never cancel this subscribe here.
    // The same setting is valid for all models.
    if (error) {
      console.error(error);
      showUnplayable = false; // Should default to hide unplayable.
    }

    showUnplayablePref = showUnplayable;
    for (var i = 0; i < updateUnavailablePrefOn.length; i++) {
      updateUnavailablePrefOn[i].update({ showUnplayable: showUnplayable });
    }
  });
}

function addAndWatchSortQuery(model) {
  var uri = model.get('origin').uri;

  var clientStorage = live(CLIENT_STORAGE);
  var key = SORT_VARIANT_KEY + uri;
  if (clientStorage.get('implemented')) {
    updateSortParams(model, uri, key);
    clientStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateSortParams(model, uri, key);
      }
    });
  } else {
    // There is no clientStorage. Update the model with defaults.
    var update = getDefaultQueryParams(uri);
    model.update(update);
  }
}

function updateSortParams(model, uri, key) {
  var clientStorage = live(CLIENT_STORAGE);

  clientStorage.get(key, function (error, variant) {
    // Respond with the sort variant if it's a valid sort URI
    var sortParams = variant && sortUriUtils.parse(variant);
    if (!error && sortParams) {
      // Check for legacy sort URIs and convert them by publishing
      // the updated version on client-storage
      var convertedFromLegacy = legacySortUris.legacyQueries[sortParams.query];

      if (convertedFromLegacy != null && convertedFromLegacy !== sortParams.query) {
        // Fix the legacy query on storage
        var fixedUri = sortUriUtils.create(uri, sortParams.direction, convertedFromLegacy);
        var publish = {};
        publish[key] = fixedUri;
        clientStorage.publish(publish);
        // This will trigger another update which will then set the sort params.
        return;
      }

      model.update({
        sortQuery: sortParams.query,
        sortDirection: sortParams.direction, // this is 'asc' or 'desc'
        sortUri: variant
      });
    } else if (variant === uri) {
      // This was unsorted.
      model.update({
        sortQuery: null,
        sortDirection: null,
        sortUri: null
      });
    } else {
      // There was nothing valid in store. Update the model with defaults.
      var update = getDefaultQueryParams(uri);
      model.update(update);
    }
  });
}

function getDefaultQueryParams(uri) {
  var sortQuery = null;
  var sortDirection = null;
  var sortUri = null;

  var isLocalFiles = uri === 'spotify:internal:local-files';
  if (isLocalFiles) {
    // Local files should be sorted by trackname by default
    sortQuery = 'track(name)';
    sortDirection = 'asc';
    sortUri = sortUriUtils.create(uri, sortDirection, sortQuery);
  }

  return {
    sortQuery: sortQuery,
    sortDirection: sortDirection,
    sortUri: sortUri
  };
}

function addAndWatchFilterString(model) {
  var uri = model.get('origin').uri; // The variant object itself doesn't have a uri, this is the one for the list it's about
  var sessionStorage = live(SESSION_STORAGE);
  var key = STRING_FILTER_KEY + uri;

  if (sessionStorage.get('implemented')) {
    updateFilterString(model, uri, key);
    sessionStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateFilterString(model, uri, key);
      }
    });
  } else {
    model.update({ 'filterString': '' });
  }
};

function updateFilterString(model, uri, key) {
  var sessionStorage = live(SESSION_STORAGE);

  sessionStorage.get(key, function (error, value) {
    model.update({ 'filterString': value || '' });
  }, live.ASAP);
}

function getOriginUri(uri) {
  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

function updateRegisteredStatus(status) {
  registered = status;
  live('spotify:list-variant').update({ implemented: status });
}

var regExp = exports.matches = /^spotify:/;
var registered;
exports.register = function () {
  if (registered) return;

  live.subscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(true);
};

exports.unregister = function () {
  if (!registered) return;

  updateUnavailablePrefOn = [];
  showUnplayablePref = null;

  live.unsubscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(false);
};

},{"../spotify-live":312,"../spotify-live-filter-uri":260,"../spotify-live-sort-uri":310,"./sorting/legacy-sort-uris":290,"./util/unplayable-tracks-playlist-setting.js":309,"mout/array/contains":463,"spotify-liburi":563}],278:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/local-files
 */
'use strict';

var contains = require('mout/array/contains');

var live = require('../spotify-live');
var listOperations = require('spotify-live-list-operations');
var liburi = require('spotify-liburi');
var Range = require('../spotify-range2');
var cosmos = require('./util/cosmos');

var regExp = /^spotify:internal:local-files$/;

function onWait(model, properties) {
  if (contains(properties, 'allows')) getAllows(model);
  if (contains(properties, 'rows')) getRows(model);
}

function getAllows(model) {
  model.update({
    allows: {
      insertTracks: false,
      removeTracks: false
    }
  });
}

function createRows(data) {
  var rows = new Array(data.length);

  for (var i = 0, l = data.length; i < l; i++) {
    var track = data[i];

    setLocalProperty(track);

    // We want timestamp in milliseconds, but the client gives it in seconds.
    var dateAdded = track.dateAdded * 1000;

    var row = {
      uri: getRowUri(track.uri),
      track: track,
      dateAdded: dateAdded
    };

    rows[i] = row;

    delete track.dateAdded;
    delete track.addedBy;
  }

  return rows;
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

function getRows(model) {
  cosmos.get({ url: 'sp://local-files/v1/tracks' }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update({
      rows: createRows(response.body)
    });

    cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      onChange(model, response.body);
    });
  });
}

function onChange(model, event) {
  switch (event.type) {
    case 'removed':
      onTracksRemoved(model, event.data);break;
    case 'added':
      onTracksAdded(model, event.data);break;
    case 'moved':
      onTracksMoved(model, event.data);break;
    case 'changed':
      onMetadataChanged(model, event.data);break;
  }
}

function onMetadataChanged(model, data) {

  // The positions we get could in some cases be for multiple ranges.
  //
  // We need to remove each range individually, so that we can re-add
  // the same range with updated data right after removing the range.
  // The reason we can't just update rows with new data is that the
  // metadata might cause the row to get a new URI (since local files
  // contain the metadata in the URI).

  var ranges = Range.fromIndices(data.positions);

  var startOfRangeInChangeset = 0;

  for (var rangeIndex = 0, range; range = ranges[rangeIndex]; rangeIndex++) {
    var indices = range.toIndices();
    var rangeLength = range.length;
    var tracks = new Array(indices.length);

    for (var i = 0; i < rangeLength; i++) {
      tracks[i] = data.tracks[startOfRangeInChangeset + i];
    }

    // Remove range and re-add it with new data
    var removeOperations = listOperations.getRemoveOperations(indices);
    model.get('rows').update(removeOperations);
    addTracksToList(model, tracks, indices[0]);

    startOfRangeInChangeset += rangeLength;
  }
}

function onTracksMoved(model, data) {
  var moveOperations = listOperations.getMoveOperations(data.positions, data.position);
  model.get('rows').update(moveOperations);
}

function onTracksRemoved(model, data) {
  var removeOperations = listOperations.getRemoveOperations(data.positions);
  model.get('rows').update(removeOperations);
}

function onTracksAdded(model, data) {
  addTracksToList(model, data.tracks, data.position);
}

function addTracksToList(model, tracks, index) {
  var rows = createRows(tracks);

  var insertOperations = listOperations.getInsertOperations(rows, index);
  model.get('rows').update(insertOperations);
}

var idCounter = 1000;
function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

var registered = false;

exports.register = function () {
  if (registered) return;
  registered = true;
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;
  live.unsubscribe(regExp, 'wait', onWait);
};

exports.matches = regExp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"../spotify-range2":352,"./util/cosmos":308,"mout/array/contains":463,"spotify-liburi":563,"spotify-live-list-operations":564}],279:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var ARTIST_CONTEXT_URL = 'hm://artistplaycontext/';

function getContext(contextUri, options, opt_callback) {

  var url = contextUri.split(':').join('/');
  var resolverUrl = ARTIST_CONTEXT_URL + url + '/km';
  var postObject = { url: resolverUrl };

  cosmos.get(postObject, opt_callback);
}

module.exports = {
  getContext: getContext
};

},{"../util/cosmos":308}],280:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/control
 * @private
 */
'use strict';

var cosmosPlayer = require('./cosmos-player');
var playerApi = require('./player-api');
var playlistResolver = require('./playlist-resolver');
var artistResolver = require('./artist-resolver');

var dataUtils = require('./data');

var cosmos = require('../util/cosmos');

/**
 * Check AB test if it should use new artist context resolver.
 *
 * @param {Function=} callback Callback function.
 **/
function shouldUseArtistContextPlayerResolver(callback) {
  var ARTIST_CONTEXT_TEST = 'Rollout_short_artist_context_desktop';
  cosmos.post({
    url: 'sp://abba/v1/flags',
    body: { flags: [ARTIST_CONTEXT_TEST] }
  }, function (_, response) {
    var flags = response && response.body && response.body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === ARTIST_CONTEXT_TEST && flags[0].cell;

    callback(featureFlagCell === 'Rollout');
  });
}

/**
 * Request to play a list of track URIs.
 *
 * @param {Array.<string>} trackUris Array of track URIs.
 * @param {?Array.<string>} opt_ids Array of one id per track. Not needed when the context never needs to be updated.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Callback function.
 */
function playTrackUris(trackUris, opt_ids, playOptions, opt_callback) {
  playerApi.play(trackUris, opt_ids, playOptions, opt_callback);
}

/**
 * Request to play a context through the cosmos track resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromResolver(contextUri, playOptions, opt_callback) {
  playerApi.playFromResolver(contextUri, playOptions, opt_callback);
}

/**
 * Play a context directly, only supported on context player
 *
 * @param {Object} context Context object that CP can deal with.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playContext(context, playOptions, opt_callback) {
  playerApi.playContext(context, playOptions, opt_callback);
}

/**
 * Request to play a context through the playlist resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromPlaylistResolver(contextUri, playOptions, opt_callback) {
  // For playlist playback we don't need to support ranges, so we'll
  // always just pick the first.
  var skipToIndex = {};

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uids) {
    skipToIndex.track_uid = playOptions.uids[0];
  } else if (playOptions.uid) {
    skipToIndex.track_uid = playOptions.uid;
  }

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uris) {
    skipToIndex.track_uri = playOptions.uris[0];
  } else if (playOptions.trackUri) {
    skipToIndex.track_uri = playOptions.trackUri;
  }

  var preparePlayOptions = {};
  if (Object.keys(skipToIndex).length) {
    preparePlayOptions.skip_to_index = skipToIndex;
  }

  var playOrigin = {
    view_uri: playOptions.context,

    // fills in source_start & source_end
    // example values: browse, playlist-owned-by-self-non-collaborative
    feature_identifier: playOptions.source,

    // fills in referer
    // example values: spotify:app:browse
    referrer_identifier: playOptions.contextPlayerReferrer,

    // fills in referrer version
    feature_version: playOptions.referrerVersion
  };

  var options = {
    prepare_play_options: preparePlayOptions,
    play_origin: playOrigin
  };

  playlistResolver.play(contextUri, options, opt_callback);
}

/**
 * Request to play a single track.
 *
 * @param {string} uri The track URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playTrack(uri, playOptions, opt_callback) {
  playOptions.context = uri;
  playOptions.track = uri;
  playOptions.index = 0;
  playTrackUris([uri], null, playOptions, opt_callback);
}

/**
 * Request to play tracks found in the list of rows.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playRows(rows, playOptions, opt_callback) {
  var index = playOptions.index;
  var range = playOptions.range;

  if (index === null && range) {
    dataUtils.getFirstPlayableRow(rows, range, function (error, index) {
      if (error && opt_callback) return opt_callback(error);
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var trackUris = dataUtils.getTracksFromRows(rows);
      playOptions.index = index;

      playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
    });
  } else {
    var trackUris = dataUtils.getTracksFromRows(rows);
    playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
  }
}

/**
 * Request to play artist context.
 *
 * @param {string} contextUri Context URI.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromArtist(uri, playOptions, opt_callback) {
  shouldUseArtistContextPlayerResolver(function (playFromArtistResolver) {
    if (playFromArtistResolver) {
      artistResolver.getContext(uri, playOptions, function (error, data) {
        if (error && opt_callback) return opt_callback(error);
        if (error) {
          if (global.console) console.error(error);
          return;
        }

        var contextObject = data.body;
        playContext(contextObject, playOptions, opt_callback);
      });
    } else {
      // If artist resolver is not enabled yet use regular resolver
      playFromResolver(uri, playOptions, opt_callback);
    }
  });
}

/**
 * Request to update the player with tracks from the provided rows list.
 * This will update the player silently without interrupting playback.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithRows(rows, playOptions, opt_callback) {

  var tracks = dataUtils.getTracksFromRows(rows);

  // Context Player matches on UIDs so let's not provide index
  delete playOptions.index;
  playerApi.update(tracks, rows.keys, playOptions, opt_callback);
}

/**
 * Request to update the player with tracks from the cosmos track resolver.
 * This will update the player silently without interrupting playback.
 *
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithResolver(playOptions, opt_callback) {

  /*
    Todo:
    When currently playing from tracklist, keys need to be passed on to the new playlist and folder resolver
  */

  cosmosPlayer.update(playOptions, null, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  playerApi.pause(opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  playerApi.resume(opt_callback);
}

/**
 * Request to skip to the previous track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmosPlayer.skipPrev(opt_callback);
}

/**
 * Request to skip to the next track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmosPlayer.skipNext(opt_callback);
}

exports.playTrack = playTrack;
exports.playRows = playRows;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.playFromArtist = playFromArtist;
exports.updateWithRows = updateWithRows;
exports.updateWithResolver = updateWithResolver;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.playFromPlaylistResolver = playFromPlaylistResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/cosmos":308,"./artist-resolver":279,"./cosmos-player":281,"./data":282,"./player-api":284,"./playlist-resolver":285}],281:[function(require,module,exports){
/**
 * @module spotify-live-models/player/cosmos-player
 * @private
 */
'use strict';

var cosmos = require('../util/cosmos');

var PLAYER_URI = 'sp://player/v2/main';
var TRACK_RESOLVER_URI = 'hm://track-resolver/v1?uri=';

var deepFillIn = require('mout/object/deepFillIn');
var isStationUri = require('../station').isStationUri;

var ACTIONS = {
  PLAY: 'play',
  PAUSE: 'pause',
  RESUME: 'resume',
  UPDATE: 'update',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

/**
 * Request to play a list of URIs or a resolvable context URI.
 *
 * @param {Object} options Object with options and data of what to play.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Callback function.
 */
function play(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.PLAY;

  postPlayerState(state, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.PAUSE } }, opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.RESUME } }, opt_callback);
}

/**
 * Request to skip playback back.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_PREV } }, opt_callback);
}

/**
 * Request to skip playback forward.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_NEXT } }, opt_callback);
}

/**
 * Request to update the player with the new state. This will not interupt
 * playback if the context is the same.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Optional callback function.
 */
function update(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.UPDATE;

  // Up the index by one, since the comsos player expects the next track when updating to a different context.
  state.index++;

  // If the new index is past the end of the list, make it the last index of
  // the list. This will make it work for the case where the list only contains
  // a single track. For lists containing more tracks, this will make the player
  // continue playing the current track as a lone track (without any context)
  // and then pick up the right context with the right highlight and all after
  // that track has played.
  if (state.tracks && state.tracks.length <= state.index) {
    state.index = state.tracks.length - 1;
  }

  postPlayerState(state, opt_callback);
}

/**
 * Post the state object to the cosmos player.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {Function=} opt_callback Optional callback function.
 */
function postPlayerState(state, opt_callback) {
  if (state.context) {
    cosmos.sanitizeURL(state.context, function (error, uri) {
      if (error) return opt_callback(error);
      state.context = uri;

      if (!state.tracks) {
        if (/^spotify:user:[^:]+:(playlist:)/.test(uri)) state.next_page_url = uri;else state.next_page_url = TRACK_RESOLVER_URI + encodeURI(uri);

        // Set tracks to an empty array since cosmos player on core js expects it.
        // REMOVE ME! 2014-10-24, see KM-3914.
        state.tracks = [];
      }

      cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
    });
  } else {
    cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
  }
}

/**
 * Request to get the current state of the cosmos player.
 *
 * @param {Function} callback Callback function.
 */
function getState(callback) {
  cosmos.get({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });
}

/**
 * Request to get the current state of the cosmos player whenever the player
 * changes.
 *
 * @param {Function} callback Callback function.
 *
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribe(callback) {
  var subscription = cosmos.subscribe({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });

  return {
    unsubscribe: function unsubscribe() {
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

/**
 * Create a state object for the cosmos player.
 *
 * @param {string} contextUri  Context URI.
 * @param {Object} playOptions An object with play options.
 *
 * @return {Object} An object with state in a format that the cosmos player understands.
 */
function createCosmosState(contextUri, playOptions) {

  var isStationContext = isStationUri(contextUri);
  var defaultState = {
    context: null,
    index: null,
    track: null,
    options: {
      can_repeat: true,
      can_shuffle: !isStationContext,
      can_skip_prev: !isStationContext,
      can_skip_next: true,
      can_seek: true,
      use_dmca_rules: false,
      repeat: false,
      repeat_track: false,
      shuffle_context: false
    },
    play_origin: {
      source: 'unknown',
      reason: 'unknown',
      referrer: 'unknown',
      referrer_version: 'unknown',
      referrer_vendor: 'unknown'
    }
  };

  var state = {
    context: contextUri,
    play_origin: {
      source: playOptions.source,
      reason: playOptions.reason,
      referrer: playOptions.referrer,
      referrer_version: playOptions.referrerVersion
    }
  };

  if ('tracks' in playOptions) state.tracks = playOptions.tracks;
  if ('index' in playOptions) state.index = playOptions.index;
  if ('track' in playOptions) state.track = playOptions.track;

  deepFillIn(state, defaultState);

  return state;
}

exports.play = play;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.update = update;
exports.getState = getState;
exports.subscribe = subscribe;

},{"../station":297,"../util/cosmos":308,"mout/object/deepFillIn":494}],282:[function(require,module,exports){
/**
 * @module spotify-live-models/player/data
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');

var playerApi = require('./player-api');

/**
 * Default values for play options.
 */
var PLAY_OPTIONS_DEFAULTS = {
  page: null,
  uid: null,
  trackUri: null,
  index: null,
  source: 'unknown',
  reason: 'unknown'
};

/**
 * Get the first playable row from range in a list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 * @param {Range} range A range object.
 * @param {Function} callback A callback where the second argument is the
 *     index of the first playable row. If no playable track is found, the
 *     index will be the first index in the range.
 */
function getFirstPlayableRow(rows, range, callback) {
  var index = range.start;

  isRowPlayable(rows.get(index), function playableCallback(error, playable) {
    if (playable) return callback(null, index);
    if (index === range.end - 1) return callback(null, range.start);

    isRowPlayable(rows.get(++index), playableCallback);
  });
}

/**
 * Check if the row is playable.
 *
 * @param {LiveObject?} row A row live object. If this is falsy, the callback
 *     is returned with false immediately.
 * @param {Function} callback A callback where the second argument is the
 *     boolean flag for playable. The callback may run synchronously or
 *     asynchronously.
 */
function isRowPlayable(row, callback) {
  if (!row) return callback(null, false);

  row.query('track(playable)', function (error, data) {
    if (error) return callback(error);
    callback(null, data.track.playable);
  }, live.ASAP);
}

/**
 * Get options for play actions based on a data object and other state
 * like referrer set on the player or application object.
 *
 * @param {Object} data A data object.
 * @param {Function} callback A callback, where the second argument is a data
 *     object with the options.
 */
function getPlayOptions(data, callback) {
  getReferrer(function (error, viewUri, baseUri) {
    if (error) return callback(error);

    Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function (key) {
      if (data[key] === undefined) {
        data[key] = PLAY_OPTIONS_DEFAULTS[key];
      }
    });

    if (data.range) {
      data.range = new Range(data.range[0], data.range[1]);
    }

    data.referrer = viewUri;
    data.contextPlayerReferrer = baseUri;
    data.referrerVersion = getReferrerVersion();

    callback(null, data);
  });
}

/**
 * Get a list of track URIs from a live list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 *
 * @return {Array.<string>} Array of track URIs. If a row is not set in the list,
 *     or if the row doesn't have a track object with a URI, an 'undefined' value
 *     will be put in that position in the output array.
 */
function getTracksFromRows(rows) {
  return rows.map(function (row) {
    var track = row && row.get('track');
    return track && track.uri;
  });
}

/**
 * Get the latest player state, in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 */
function getPlayerState(callback) {
  playerApi.getState(callback);
}

/**
 * Subscribe to the cosmos player to get the latest player state,
 * in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribeForPlayerState(callback) {
  return playerApi.subscribe(callback);
}

/**
 * Get the referrer for the player. This is usually the path back to the app in
 * the state where the playback started. It can be set by the user in the `referrer`
 * property of the player live object. If nothing is set there, it will generate
 * the referrer by combining the app URI with the app arguments.
 *
 * @param {Function} callback A callback where the second argument is the referrer.
 */
function getReferrer(callback) {
  // 'referrer' corresponds to fullURI below
  var referrer = live('spotify:player').get('referrer');
  var referrerBaseUri = live('spotify:player').get('referrerBaseUri');
  if (referrer) {
    if (!referrerBaseUri) {
      console.warn('referrer field is set on the player model (' + referrer + '), but referrerBaseUri isn\'t');
    }
    return callback(null, referrer, referrerBaseUri || '');
  }

  live('spotify:application').get('appURI', 'arguments', function (error, uri, args) {
    if (error) return callback(error);
    var fullUri = args ? uri + ':' + args : uri;
    callback(null, fullUri, uri);
  });
}

/**
 * Get the referrer version. This is usually the version of the app. It can be set
 * by the user in the `version` property of the application live object. If nothing
 * is set there, it will use the default version '0.0.0'.
 *
 * @return {string} The version string.
 */
function getReferrerVersion() {
  return live('spotify:application').get('version') || '0.0.0';
}

exports.getReferrer = getReferrer;
exports.getReferrerVersion = getReferrerVersion;
exports.getFirstPlayableRow = getFirstPlayableRow;
exports.isRowPlayable = isRowPlayable;
exports.getPlayOptions = getPlayOptions;
exports.getTracksFromRows = getTracksFromRows;
exports.getPlayerState = getPlayerState;
exports.subscribeForPlayerState = subscribeForPlayerState;

},{"../../spotify-live":312,"../../spotify-range2":352,"./player-api":284}],283:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player
 */
'use strict';

var live = require('../../spotify-live');
var URI = require('spotify-liburi');
var cosmos = require('spotify-cosmos-api');

var playerApi = require('./player-api');
var playbackControl = require('./control');
var dataUtils = require('./data');
var updatesUtils = require('./updates');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var createStationPlayContext = require('../station/create-play-context');
var createStationPlayOptions = require('../station/create-play-options');
var isStationUri = require('../station').isStationUri;

var TYPE_TRACK = 'track';
var TYPE_TRACK_RESOLVER = 'track-resolver';
var TYPE_ROWS = 'rows';
var TYPE_CP_RESOLVER_PLAYLIST = 'context-player-resolver-playlist';
var TYPE_CP_CONTEXT = 'context-player-context';
var TYPE_CONTEXT_OBJECT = 'context-object';
var TYPE_STATION_CONTEXT = 'context-station-context';
var TYPE_CP_ARTIST_CONTEXT = 'context-player-artist';
var TYPE_CONTEXT_EPISODE = 'context-episode';
var VARIANT_KEY = 'list-variant-';
var lastPlayRequestId = 0;

// This data store will keep context objects keyed by context URI. The values
// are context objects in the format of spotify-player Context:
// https://ghe.spotify.net/spotify-sdk/spotify-player/blob/master/lib/v2/types.js#L164
var contextDataStore = {};

/**
 * Handler for when properties are requested from the model.
 *
 * @param {LiveObject} model The player live object.
 */
function onWait(model) {
  updateState(model);
}

/**
 * Handler for when the model needs to be updated by polling the player.
 *
 * @param {LiveObject} model The player live object.
 */
function onSync(model) {
  updateState(model);
}

/**
 * Handler for when the real player is updated.
 *
 * @param {Error?} error An error object, or null.
 * @param {Object} data Data object in the format of this live model.
 */
function onPlayerStateUpdate(error, data) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var model = live('spotify:player');
  if (model.get('pending')) return;
  model.update(data);
}

/**
 * Handler for when the model receives the 'update' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onUpdate(model) {
  var index = model.get('index') && model.get('index').get('track');
  if (index != null) {
    updatesUtils.setPlayingIndex(index);
  }

  updatesUtils.clean(model);
}

/**
 * Handler for when the model receives the 'play' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event The event object with data about what to play.
 *     Can contain the following properties:
 *       `context` (string, context URI)
 *       `index` (number, index within context to play)
 *       `uid` (string, uid within context to play)
 *       `page` (number, index for the context player page)
 *       `range` (array of two values, start and end index)
 *       `uids` (array of uids representing an index or a range)
 *       `uris` (array of uris connected to the uids)
 *       `source` (string)
 *       `reason` (string)
 */
function onPlay(model, event) {
  var context = event.context;
  if (!context) return;

  // The `index` property might be `null`, which should mean that no specific
  // index should be played.
  if (typeof event.index !== 'number') {
    delete event.index;
  }

  var playRequestId = ++lastPlayRequestId;

  // Update the model optimistically
  model.update(playerApi.addContext({
    isPlaying: true,
    isPaused: false,
    index: event.index === undefined ? null : { page: 0, track: event.index },
    track: event.trackUri === undefined ? null : { uri: event.trackUri },
    contextUpdatedCrossFrame: false
  }, context));

  // Get options for the play action based on event data and other state
  // Todo: getPlayOptions creates options that fit the cosmos/v1 implementation.
  // We could probably do this a bit later from cosmos-player.js
  dataUtils.getPlayOptions(event, function (error, options) {
    if (error || !options.context) return updateState(model); // Revert state

    // Canonical contexts can have sorted and/or filtered state that needs
    // to be respected client-wide. We therefore query for the correct variant
    // to be played.
    // For spotify:internal uris on the other hand, we don't look for variants.
    // This would also be the case for contexts that already represent variants.
    // Please see docs for details.
    if (/^spotify:internal:/.test(options.context)) {
      playWithOptions(model, playRequestId, options);
      return;
    }

    if (live('spotify:list-variant').get('implemented')) {
      live(options.context).query('listVariant(currentUri, sortUri)', function (error, data) {
        if (error) return updateState(model); // Revert state

        // Abort if a new play request has happened since this request started
        if (lastPlayRequestId !== playRequestId) {
          return;
        }

        options.context = data.listVariant.currentUri;

        playWithOptions(model, playRequestId, options);
      });
    } else {
      playWithOptions(model, playRequestId, options);
    }
  });
}

/**
 * Handler for when the model receives the 'pause' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onPause(model) {
  if (model.get('isPlaying') === false || model.get('isPaused') === true) {
    return;
  }

  model.update({ isPaused: true });

  playbackControl.pause(function (error) {
    if (error) return model.update({ isPaused: false });
  });
}

/**
 * Handler for when the model receives the 'resume' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onResume(model) {
  if (model.get('isPlaying') === true && model.get('isPaused') === false) {
    return;
  }

  model.update({ isPaused: false });

  playbackControl.resume(function (error) {
    if (error) return model.update({ isPaused: true });
  });
}

/**
 * Handler for when the model receives the 'skip-previous' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipPrev() {
  // Skip prev often starts playback, but not when you're on the first track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipPrev();
}

/**
 * Handler for when the model receives the 'skip-next' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipNext() {
  // Skip next often starts playback, but not when you're on the last track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipNext();
}

/**
 * Handler for when the model receives the 'update-context' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event An event object with a `context` property (string).
 */
function onUpdateContext(model, event) {
  var contextUri = event.context;
  if (!contextUri) return;

  var context = live(contextUri);
  var playRequestId = ++lastPlayRequestId;

  var currentIndex = model.get('index') && model.get('index').get('track');
  var currentContext = model.get('variant');

  // Update player model optimistically with context and no index.
  // We can't know the index yet, so we must set it to nothing to
  // not get wrong highlights.
  model.update(playerApi.addContext({
    index: null,
    pending: true,
    contextUpdatedCrossFrame: false
  }, contextUri));

  // We need the rows list to be able to get the index and play the list.
  live(contextUri).get('rows', function (error, rowsList) {
    if (error) {
      model.update({ pending: false });
      if (global.console) console.error(error);
      return;
    }

    var options = { context: contextUri };
    dataUtils.getPlayOptions(options, function (error, options) {

      // Abort if a new play request has happened since this request started
      if (lastPlayRequestId !== playRequestId) {
        return;
      }

      // Store which row is currently playing, so that we can get the index
      // of the playing row in another list.
      updatesUtils.setPlayingIndex(currentIndex, currentContext.get('rows'));

      // Find the index of the currently playing track in new list, to do an
      // optimistic update. This is not optional, since the actual player only appends
      // the next context and will not send an update until the next skip.
      // (If it does, because of play/pause for example, it will still report the old
      // list that we're not showing in the UI)

      // At the same time, find the index that we will use to actually update the playback
      var updateIndices = updatesUtils.getPlayingAndUpdateIndicesInList(rowsList);
      options.index = updateIndices.update;
      if (updateIndices.playing != null) model.update({ index: { page: 0, track: updateIndices.playing } });

      if (model.get('playOrigin') && model.get('playOrigin').get('referrerIdentifier') !== options.referrer) {
        model.update({ contextUpdatedCrossFrame: true });
      }

      playbackControl.updateWithRows(rowsList, options, function (error) {
        model.update({ pending: false });
        if (error) return updateState(model); // Revert state
      });

      updatesUtils.listen(rowsList, options, function (options) {
        playbackControl.updateWithRows(rowsList, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      });
    });
  });
}

/**
 * Request to start playback based on passed options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {string} playRequestId The ID for this request.
 * @param {Object} options Object with options and data of what to play.
 */
function playWithOptions(model, playRequestId, options) {
  var contextUri = options.context;
  var resolverType = getPlaybackResolverType(contextUri);

  if (resolverType === TYPE_TRACK) {
    playbackControl.playTrack(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_TRACK_RESOLVER) {
    playbackControl.playFromResolver(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_ROWS) {
    var isSortedList = sortUriUtils.isValid(contextUri);

    // If it's a sorted list that is played by rows, we want to request all the track
    // URIs of the sorted list and then play that list of tracks. We will wait for all
    // tracks to be fetched and sorted, to allow clicking play on a media object in
    // Browse for example and have it play the stored sorted variant of the playlist.
    if (isSortedList) {
      getSortedRows(contextUri, function (error, rowsList) {
        if (error) return updateState(model); // Revert state

        // Abort if a new play request has happened since this request started
        if (lastPlayRequestId !== playRequestId) {
          return;
        }

        playRows(model, rowsList, options);
      });

      // Play any other context from the rows list
    } else {
      live(contextUri).query('rows(track(uri))', function (err) {
        if (!err && lastPlayRequestId === playRequestId) {
          playRows(model, live(contextUri).get('rows'), options);
        }
      });
    }
  } else if (resolverType === TYPE_CP_RESOLVER_PLAYLIST) {
    playbackControl.playFromPlaylistResolver(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_CONTEXT_OBJECT) {
    var context = contextDataStore[contextUri];
    playbackControl.playContext(context, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_CP_CONTEXT) {

    var context = {
      url: 'context://' + contextUri,
      entity_uri: contextUri
    };

    playbackControl.playContext(context, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_STATION_CONTEXT) {
    var station = live(contextUri);
    station.query('rows', function (err) {
      if (!err) {
        playbackControl.playContext(createStationPlayContext(station), createStationPlayOptions(station, options), function (error) {
          if (error) return updateState(model); // Revert state
        });
      }
    });
  } else if (resolverType === TYPE_CP_ARTIST_CONTEXT) {
    playbackControl.playFromArtist(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_CONTEXT_EPISODE) {
    var episodeQueryTimeout = 3000;
    live(contextUri).query('episode(name, manifestId, show(name))', function (error, data) {
      if (error) return updateState(model); // Revert state

      var episode = data.episode;
      var context = {
        'uri': contextUri,
        'pages': [{
          'tracks': {
            'uri': contextUri,
            'metadata': {
              'title': episode.name,
              'album_title': episode.show.name,
              'media.type': 'video',
              'media.manifest_id': episode.manifestId
            }
          }
        }],
        'restrictions': {
          'disallow_skipping_prev_reasons': ['disallow-video'],
          'disallow_skipping_next_reasons': ['disallow-video'],
          'disallow_toggling_repeat_context_reasons': ['disallow-video'],
          'disallow_toggling_repeat_track_reasons': ['disallow-video'],
          'disallow_toggling_shuffle_reasons': ['disallow-video']
        }
      };

      if (!options.player_options_override) {
        options.player_options_override = {};
      }
      // Avoid repeating context when playing episode
      // This might be removed in future when we have proper shows support
      options.player_options_override.repeating_context = false;
      options.player_options_override.repeating_track = false;

      playbackControl.playContext(context, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    }, episodeQueryTimeout);
  }
}

/**
 * Request to start playback based on passed rows list and options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {LiveList} rowsList The rows live list.
 * @param {Object} options Object with options and data of what to play.
 */
function playRows(model, rowsList, options) {
  playbackControl.playRows(rowsList, options, function (error) {
    if (error) return updateState(model); // Revert state

    updatesUtils.listen(rowsList, options, function (options) {
      playbackControl.updateWithRows(rowsList, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    });
  });
}

/**
 * Get the type of playback resolver to use for a certain context URI.
 *
 * @param {string} contextUri Context URI.
 *
 * @return {string} A resolver type. One of 'track-resolver', 'rows' or 'track'.
 */
function getPlaybackResolverType(contextUri) {
  var contextType = URI.from(contextUri).type;

  var isTrack = contextType === URI.Type.TRACK;
  var isPlaylist = contextType === URI.Type.PLAYLIST;
  var isPlaylistFolder = contextType === URI.Type.FOLDER;
  var isArtist = contextType === URI.Type.ARTIST;
  var isSortedList = sortUriUtils.isValid(contextUri);
  var isFilteredList = filterUriUtils.isValid(contextUri);
  var isStation = isStationUri(contextUri);
  var isEpisode = contextType === URI.Type.EPISODE;

  if (isTrack) return TYPE_TRACK;

  if (isPlaylist) {
    return TYPE_CP_RESOLVER_PLAYLIST;
  }

  if (isPlaylistFolder) {
    return TYPE_CP_CONTEXT;
  }

  if (isStation) return TYPE_STATION_CONTEXT;

  var originContextType, originUri;
  if (isSortedList) {
    originUri = sortUriUtils.parse(contextUri).originUri;

    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    if (filterUriUtils.isValid(originUri)) originUri = filterUriUtils.parse(originUri).originUri;

    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  if (isFilteredList) {
    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    originUri = filterUriUtils.parse(contextUri).originUri;
    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  var contextData = contextDataStore[contextUri];
  if (contextData) {
    return TYPE_CONTEXT_OBJECT;
  }

  // If it's a different URI, check if we have rows
  var rowsList = live(contextUri).get('rows');
  if (rowsList && rowsList.length) {
    return TYPE_ROWS;
  }

  // If it's an artist context but context object or rows were not defined
  if (isArtist) {
    return TYPE_CP_ARTIST_CONTEXT;
  }

  if (isEpisode) {
    return TYPE_CONTEXT_EPISODE;
  }

  // If no rows are available, final hope is on the track resolver
  return TYPE_TRACK_RESOLVER;
}

/**
 * Get the stored variant of the list. For example, if a user has sorted a
 * playlist, that is stored in the client, so playing the playlist from another
 * place should play the stored sorted variant.
 *
 * @param {string} listUri The normal list URI.
 * @param {Function} callback Callback function where second argument is the
 *     URI of the variant to play. This could be the original list URI.
 */
function getStoredSortUri(listUri, callback) {
  live('spotify:client').query('containerFeatures(clientStorage)', function (error, data) {
    if (error) return callback(null, listUri);

    var defaultUri = listUri;

    if (data.containerFeatures.clientStorage) {
      var key = VARIANT_KEY + listUri;
      var clientStorage = live('spotify:client-storage');

      // Check whether the client storage live model has been registered.
      // This is so that we can check this without making this a
      // breaking change. Would be great with a future live API to see
      // if someone has implemented a specific model.
      if (clientStorage.get('implemented')) {
        clientStorage.get(key, function (error, variant) {
          if (error) return callback(null, defaultUri);

          // Respond with the sort variant if it's a valid sort URI
          if (variant && sortUriUtils.isValid(variant) || variant === listUri) {
            return callback(null, variant);
          }

          // Fall back to the regular playlist URI if it's not valid
          callback(null, defaultUri);
        });
      } else {

        // Fall back to the regular playlist URI if client storage is not implemented
        callback(null, defaultUri);
      }
    } else {
      callback(null, defaultUri);
    }
  });
}

/**
 * Get the live list for the rows of the sorted URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 * @param {Function} callback Callback function where second argument is the
 *     sorted live list.
 */
function getSortedRows(sortUri, callback) {
  var playlistUri = sortUriUtils.getOriginUri(sortUri);

  // Get the rows list for the regular playlist.
  // We could have queried for the track of every row, but by not querying we
  // avoid the conversions from live objects to plain objects.
  live(playlistUri).get('rows', function (error, rows) {
    if (error) return callback(error);

    // Get the live models for all rows.
    rows.get(0, rows.length, function (error) {
      if (error) return callback(error);

      // When we know we have the rows, we can safely sort the list
      live(sortUri).get('rows', function (error, rowsList) {
        if (error) return callback(error);

        // Finally return the sorted rows list
        callback(null, rowsList);
      });
    });
  });
}

/**
 * Update the player model with the current data of the cosmos player model.
 *
 * @param {LiveObject} model The player live object.
 */
function updateState(model) {
  dataUtils.getPlayerState(function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(data);
  });
}

var regExp = exports.matches = /^spotify:player$/;
var registered;
var playerSubscription;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'play', onPlay);
  live.subscribe(regExp, 'pause', onPause);
  live.subscribe(regExp, 'resume', onResume);
  live.subscribe(regExp, 'skip-previous', onSkipPrev);
  live.subscribe(regExp, 'skip-next', onSkipNext);
  live.subscribe(regExp, 'update-context', onUpdateContext);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'sync-position', onSync);

  playerSubscription = dataUtils.subscribeForPlayerState(onPlayerStateUpdate);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'play', onPlay);
  live.unsubscribe(regExp, 'pause', onPause);
  live.unsubscribe(regExp, 'resume', onResume);
  live.unsubscribe(regExp, 'skip-previous', onSkipPrev);
  live.unsubscribe(regExp, 'skip-next', onSkipNext);
  live.unsubscribe(regExp, 'update-context', onUpdateContext);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'sync-position', onSync);

  playerSubscription.unsubscribe();
  playerSubscription = null;
};

exports.setContextData = function (contextUri, contextData) {
  contextDataStore[contextUri] = contextData;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../../spotify-live-filter-uri":260,"../../spotify-live-sort-uri":310,"../station":297,"../station/create-play-context":298,"../station/create-play-options":299,"./control":280,"./data":282,"./player-api":284,"./updates":286,"spotify-cosmos-api":554,"spotify-liburi":563}],284:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/player-api
 * @private
 */
'use strict';

var dataUtils = require('./data');
var cosmosUtil = require('../util/cosmos');

var live = require('../../spotify-live');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');

var PlayerApi = require('spotify-player/lib/v2');
var cosmos = require('spotify-cosmos-api');

var TRACK_RESOLVER_URI = 'hm://track-resolver/v2?uri=';

var player;

function getPlayer(callback) {

  if (player) {
    callback(player);
    return;
  }

  // One of a fixed list of features, since this is used for logging. It should
  // be the readable name of the feature, for example "radio", "album", "playlist"
  // and it should be the same for a given feature across platforms.
  // The list is probably this:
  // https://ghe.spotify.net/datainfra/log-parser/blob/master/spotify/log_parser/messages_specs.py#L29
  var featureIdentifier;

  // The version of the feature itself
  var featureVersion;

  var appManifest = global.__spotify && global.__spotify.app_manifest;
  if (appManifest) {
    featureVersion = appManifest.BundleVersion || null;
    featureIdentifier = appManifest.BundleIdentifier || null;
  }

  // Hard coded overwrites for apps where we needed to choose a new
  // BundleIdentifier for compat reasons
  // Todo: This is incomplete and would better be fixed by letting features
  // provide values specifically for this. See KM-6973.
  var overwrites = {
    'playlist-desktop': 'playlist'
  };

  if (featureIdentifier && overwrites[featureIdentifier]) featureIdentifier = overwrites[featureIdentifier];

  // The uri of the view that's supposed to show the context where the track is
  // playing, including arguments. That's called referrer in terms of the
  // player live model.
  dataUtils.getReferrer(function (error, viewUri, baseUri) {
    if (error && console) {
      console.error('The player API could not be initialized due to a missing referrer!', error);
      return;
    }

    var options = baseUri ? { referrerIdentifier: baseUri } : null;

    player = new PlayerApi.Player(cosmos.resolver, viewUri, featureIdentifier, featureVersion, options);
    callback(player);

    // The viewUri on this player instance can't ever change, so since we cache
    // it we have to destroy it when arguments change.
    live('spotify:application').on('update', function (data) {
      if ('arguments' in data) {
        player = null;
      }
    });
  });
}

function play(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {
    var tracks = new Array(trackUris.length);
    for (var i = 0; i < trackUris.length; i++) {
      var trackUri = trackUris[i];

      var track = { uri: trackUri };

      if (opt_rowIds) {
        track.uid = '' + opt_rowIds[i];
      }

      tracks[i] = track;
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    var options = {};
    if (typeof playOptions.index === 'number') {
      options.skip_to_index = {
        page: 0,
        track: playOptions.index
      };
    }

    player.play(context, options, opt_callback);
  });
}

function playContext(context, playOptions, opt_callback) {
  if (playOptions.uid || playOptions.uri || playOptions.page) {
    playOptions.skip_to = {};
    if (playOptions.uid) {
      playOptions.skip_to.track_uid = playOptions.uid;
    } else if (playOptions.uri) {
      playOptions.skip_to.track_uri = playOptions.uri;
    }

    // Together with UID send page_index property, so Connect can
    // figure out where to look for a track that needs to
    // be played. (Connect doesn't support UIDs at the moment).
    if (playOptions.page) {
      playOptions.skip_to.page_index = playOptions.page;
    }
  }

  getPlayer(function (player) {
    player.play(context, playOptions || {}, opt_callback);
  });
}

function update(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {

    var length = trackUris.length;
    var tracks = new Array(length);

    // Todo: When currently playing from the new playlist and folder resolver,
    // uids provided by the core resolver need to be used.

    for (var i = 0; i < length; i++) {

      tracks[i] = {
        uri: trackUris[i]
      };
      if (opt_rowIds) tracks[i].uid = '' + opt_rowIds[i];
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    player.update(context, opt_callback);
  });
}

function playFromResolver(contextUri, playOptions, opt_callback) {
  getPlayer(function (player) {
    cosmosUtil.sanitizeURL(contextUri, function (error, uri) {
      if (error) {
        if (opt_callback) opt_callback(error);
        return;
      }

      var context = {
        entity_uri: uri
      };

      var options = null;
      if (typeof playOptions.index === 'number') {
        options = {
          skip_to_index: {
            page: 0,
            track: playOptions.index
          }
        };
      } else if (playOptions.trackUri) {
        options = {
          skip_to_index: {
            track_uri: playOptions.trackUri
          }
        };
      }

      context.pages = [{ page_url: TRACK_RESOLVER_URI + encodeURI(uri) }];

      player.play(context, options, opt_callback);
    });
  });
}

var cancelSubscribe;

function subscribe(callback, options) {
  cancelSubscribe = false;
  options = options || {};

  var subscription;
  getPlayer(function (player) {
    if (cancelSubscribe) return;
    subscription = player.subscribe(function (error, response) {
      if (error) {
        return callback(error);
      }
      callback(null, addContext(response.getJSONBody()));
    }, options);
  });

  return {
    unsubscribe: function unsubscribe() {
      cancelSubscribe = true;
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

function getState(callback) {
  getPlayer(function (player) {
    player.getState(function (error, response) {
      if (error) {
        callback(error, null);
      } else {
        callback(null, addContext(response.getJSONBody()));
      }
    });
  });
}

function pause(opt_callback) {
  getPlayer(function (player) {
    player.pause(opt_callback);
  });
}

function resume(opt_callback) {
  getPlayer(function (player) {
    player.resume(opt_callback);
  });
}

function clear() {
  player = null;
}

/**
 * Adds the context to a given player state.
 *
 * @param {Object} data Input data in the format of the cosmos player live model (v2).
 * @param {string?} opt_uri Optional URI to be used in first place.
 * @return {Object} Data object.
 */
function addContext(data, opt_uri) {
  var uri = opt_uri || // We provide the URI of the context.
  data.context_metadata['zelda.context_uri'] || // Best case scenario.
  data.context_uri || // No special context, use the standard one.
  data.track && data.track.uri || // If a track is present, use it.
  null; // Nothing found; there's nothing being played.

  var context = getOriginUri(uri);

  // Avoid writing it into the context. People should always use the context object.
  delete data.context_uri;

  if (uri) {
    data.variant = { uri: uri };
    data.context = { uri: context };
  } else {
    data.variant = null;
    data.context = null;
  }

  // Track and index are flagged as "optional", meaning that when the player is stopped
  // will not be returned. Because of the way "live" works (waiting for properties until
  // they're set), it could happen that we wait forever for "track" and "index". For
  // aoviding this, we set them both to "null".
  data.track = data.track || null;
  data.index = data.index || null;

  if (data.track) {
    data.uid = data.track.uid;
    delete data.track.uid;
  } else {
    data.uid = null;
  }

  return removeUnderscores(data);
}

/**
 * Returns the original URI from a given filtered & sorted URI. For example, given
 * this URL:
 *
 * spotify:internal:sortlist:desc:track(name):internal:filterlist:playable%20eq%20true:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * This method would return:
 *
 * spotify:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * @param {string} uri An internal URI format with sort and/or query parts.
 * @return {string} The original URI.
 */
function getOriginUri(uri) {
  if (!uri) {
    return uri;
  }

  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

/**
 * Transforms C++ syntax for variable names and keys (underscore_names) to the JS format
 * (camelCase).
 */
function removeUnderscores(data) {
  var transformedKey;

  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      transformedKey = key.replace(/_(.)/g, function (str, chr) {
        return chr.toUpperCase();
      });

      if (data[key] instanceof Object) {
        data[transformedKey] = removeUnderscores(data[key]);
      } else {
        data[transformedKey] = data[key];
      }

      if (transformedKey !== key) {
        delete data[key];
      }
    }
  }

  return data;
}

exports.play = play;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.pause = pause;
exports.resume = resume;
exports.update = update;
exports.subscribe = subscribe;
exports.getState = getState;
exports.clear = clear;
exports.addContext = addContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":312,"../../spotify-live-filter-uri":260,"../../spotify-live-sort-uri":310,"../util/cosmos":308,"./data":282,"spotify-cosmos-api":554,"spotify-player/lib/v2":565}],285:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var coreSortParams = require('../../spotify-core-sort-params');

var PLAYLIST_RESOLVER = 'sp://core-playlist/v1/playlist/';

// Todo: This is playlist-desktop/src/core-datasource/parse-uri.js
// but it's much easier to make it common when we OneRepo™.
function parseURI(uri) {
  var parsedSortUri = sortUriUtils.parse(uri);
  if (parsedSortUri) uri = parsedSortUri.originUri;
  var parsedFilterUri = filterUriUtils.parse(uri);
  if (parsedFilterUri) uri = parsedFilterUri.originUri;
  return {
    uri: uri,
    sort: parsedSortUri,
    filter: parsedFilterUri
  };
}

function play(contextUri, options, opt_callback) {

  var parsed = parseURI(contextUri);

  var query = [];
  if (parsed.sort) {
    var direction = parsed.sort.direction === 'desc' ? 'DESC' : 'ASC';
    query.push('sort=' + encodeURIComponent(coreSortParams(parsed.sort.query, direction)));
  }

  var filters = [];
  if (parsed.filter) {
    var filtersFromQuery = parsed.filter.query.split(',').map(function (filter) {
      return encodeURIComponent(filter);
    });
    filters.push.apply(filters, filtersFromQuery);
  }
  if (filters.length) {
    query.push('filter=' + filters.join(','));
  }

  // Include a contextUri that is then reflected as the context in the player state
  query.push('uri=' + encodeURIComponent(contextUri));

  var queryString = '';
  if (query.length) {
    queryString = '?' + query.join('&');
  }

  var url = encodeURIComponent(parsed.uri);
  var resolverUrl = PLAYLIST_RESOLVER + url + '/play' + queryString;
  var postObject = { url: resolverUrl };
  if (options) postObject.body = options;

  cosmos.post(postObject, opt_callback);
}

module.exports = {
  play: play
};

},{"../../spotify-core-sort-params":136,"../../spotify-live-filter-uri":260,"../../spotify-live-sort-uri":310,"../util/cosmos":308}],286:[function(require,module,exports){
/**
 * @module spotify-live-models/player/updates
 * @private
 */
'use strict';

var lastRowsList;
var lastRowsListUri;
var lastRowsListHandler;
var lastRowsListReferrer;
var playerRowKey;
var playerKeys;

/**
 * Listen for updates on a rows list and update the player when
 * changes happen.
 *
 * @param {LiveList} rowsList A live list of rows.
 * @param {Object} options Object with options and data of what to play.
 * @param {Function} handler A handler function that gets called whenever
 *     the list is updated. Gets called with one argument: an options object.
 */
function listen(rowsList, options, handler) {
  if (lastRowsList) {
    removeRowsListener();
  }

  lastRowsList = rowsList;
  lastRowsListUri = options.context;
  lastRowsListReferrer = options.contextPlayerReferrer;

  lastRowsListHandler = function lastRowsListHandler() {
    // Todo: Only add this for TPM.
    options.index = getPlayingAndUpdateIndicesInList(rowsList).update;
    handler(options);
  };

  rowsList.on('update', lastRowsListHandler);
}

/**
 * Check if the last added rows listener is still valid for the current
 * player state, and clean up the update handler if it's not valid.
 *
 * @param {LiveObject} model The player live object.
 */
function clean(model) {
  if (!lastRowsListHandler) return;

  var context = model.get('variant');

  // Remove listener if the player context is no longer the same
  if ((context && context.uri) !== lastRowsListUri) {
    removeRowsListener();

    // Remove listener if the player referrer is no longer the same
  } else {
    var origin = model.get('playOrigin');
    var playerReferrer = origin && origin.get('referrerIdentifier');

    if (playerReferrer !== lastRowsListReferrer && !model.get('contextUpdatedCrossFrame')) {
      removeRowsListener();
    }
  }
}

/**
 * Save which item is currently playing.
 *
 * @param {number} index The index for the playing row.
 */
function setPlayingIndex(index, optRowsList) {
  if (!lastRowsList && !optRowsList) {
    return;
  }

  // If the index is out of bounds (e.g. is -1 because the track is not found),
  // then just keep the old playerRowKey.
  if (index < 0) {
    return;
  }

  var list = optRowsList || lastRowsList;

  playerRowKey = list.keys[index] || null;
  playerKeys = list.keys.slice();
}

/**
 * Remove the saved rows listener data.
 */
function removeRowsListener() {
  if (lastRowsList) {
    lastRowsList.off('update', lastRowsListHandler);
  }

  lastRowsList = null;
  lastRowsListUri = '';
  lastRowsListHandler = null;
  lastRowsListReferrer = '';
}

/**
 * Get the index of the playing row in the provided list.
 *
 * @param {LiveList} rowsList A live list of rows.
 *
 * @return {number} The index of the playing row, or -1 if not found.
 */
function getPlayingAndUpdateIndicesInList(rowsList) {
  if (!playerRowKey) return { update: -1, playing: -1 };

  // Find the currently playing row in the new list
  var playingIndexInNewList = rowsList.keys.indexOf(playerRowKey);
  var updateIndex = playingIndexInNewList;

  // If the playing row was not found in the new list, loop through the row
  // keys of the list that the player is currently playing from, and try to
  // find the next row key that exist both in the currently playing list and
  // the new list.
  if (playingIndexInNewList === -1) {
    var indexInPlayerList = playerKeys.indexOf(playerRowKey);
    for (var i = indexInPlayerList, l = playerKeys.length; i < l; i++) {
      updateIndex = rowsList.keys.indexOf(playerKeys[i]);
      if (updateIndex > -1) {

        // Index must be -1 since we've moved down several rows. The cosmos
        // player wants the index of the next row, so before passing it to
        // cosmos, the index will be incremented again.
        updateIndex--;

        break;
      }
    }
  }

  return {
    update: updateIndex,
    playing: playingIndexInNewList
  };
}

/**
 * Check if the player is currently playing from a rows list.
 *
 * @param {string} opt_uri Context URI. If passed, it checks for that specific URI.
 *
 * @return {boolean} True if it is playing from a rows list, false otherwise.
 */
function isPlayingFromRowsContext(opt_uri) {
  if (opt_uri) return lastRowsListUri === opt_uri;

  return !!lastRowsList;
}

exports.setPlayingIndex = setPlayingIndex;
exports.listen = listen;
exports.clean = clean;
exports.getPlayingAndUpdateIndicesInList = getPlayingAndUpdateIndicesInList;
exports.isPlayingFromRowsContext = isPlayingFromRowsContext;

},{}],287:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/playlist
 */
'use strict';

var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');
var intersection = require('mout/array/intersection');
var interpolate = require('interpolate');

var live = require('../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('./util/cosmos');
var bridgeRequest = require('./util/bridge').request;
var debug = require('debug')('spotify-live-models:playlist');

var CLIENT = 'spotify:client';
var BACKOFF = 100;

var OFFLINE_STATUS = {
  NO: 'no',
  WAITING: 'waiting',
  DOWNLOADING: 'downloading',
  YES: 'yes'
};

var endpoints = {
  broadcast: 'sp://messages/v1/playliststate',
  'core-playlist': 'sp://core-playlist/v1/playlist'
};

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  live(response.body.uri).update(response.body);
}

var offlineSubscriptions = {};

// This bridge call is only available in the C++ bridge and is used for
// updating subscribed/following state for the playlist.
function bridgeWaitAny(model) {
  bridgeRequest('playlist_event_wait_any', [model.uri], function (error, event) {
    // Bridge (tested in Zelda) has a bug [1] where the callbacks for
    // playlist_event_wait_any are mixed up, so that the response is
    // for a different playlist than the one that was requested.
    // By updating the live model for the URI in the event, and then
    // listen again for that model, we will update the correct models.
    // This should be removed when the bug is fixed. However, nothing
    // will break if it's still there.
    //
    // [1] https://jira.spotify.net/browse/KM-1241
    var eventModel = event && event.data.uri ? live(event.data.uri) : model;
    if (error) {
      setTimeout(function () {
        bridgeWaitAny(eventModel);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      event.data.isFollowing = event.data.subscribed;
      event.data.added = event.data.subscribed;
      eventModel.update(event.data);
    }

    bridgeWaitAny(eventModel);
  });
}

function bridgeWait(model) {
  bridgeRequest('playlist_event_wait', [model.uri], function (error, event) {
    if (error) {
      // Hotfix 2014-10-20: We are matching temporary playlists with this model, and we're not sure
      // what the implications are if we wouldn't. For now we give up when we see a 'invalid-uri'
      // message
      if (error.name !== 'invalid-uri') {
        setTimeout(function () {
          bridgeWait(model);
        }, BACKOFF);
      }
      if (global.console) console.error(error);
      return;
    }

    // The only thing we need to care about here is 'change', other types like
    // 'insert', 'remove', 'move' aren't dealt with via bridge anymore.
    if (event.type === 'change') {
      model.update(event.data);
    }

    bridgeWait(model);
  });
}

function updateMetadata(model, needsImage) {
  bridgeRequest('playlist_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update(payload);

    // If the payload does not contain any images
    // we need to make a separate bridge request
    if (needsImage && !payload.images) {
      updateImage(model);
    }
  });
}

function updateImage(model) {
  bridgeRequest('playlist_profile', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    if (!payload.image) payload.image = '';
    if (!payload.images) payload.images = [];
    model.update(payload);
  });
}

function updatePopularity(model) {
  bridgeRequest('playlist_popularity', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(payload);
  });
}

function updateAnnotatedData(model) {
  var uriObject = liburi.from(model.uri);
  if (!uriObject || !uriObject.username || !uriObject.id) {
    debug('invalid uri for annotated data: %o', model.uri);
    model.update({ annotatedImage: null });
    return;
  }

  var encodedUsername = encodeURIComponent(uriObject.username);
  var playlistId = liburi.hexToId(uriObject.id);

  var url = interpolate('hm://playlist-annotate/v1/annotation/user/{username}/playlist/{id}', {
    username: encodedUsername,
    id: playlistId
  });

  cosmos.get({ url: url + '?format=json&bust=' + Date.now() }, function (error, response) {
    if (error) {
      model.update({
        annotatedImage: null
      });
      return;
    }

    var body = response.body;
    model.update({
      annotatedImage: body && body.picture || null
    });
  });
}

function onWait(model, properties) {
  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineStatus = contains(properties, 'offlineStatus');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  var needsPlayable = contains(properties, 'playable');
  var needsPopularity;
  var needsImage;
  var needsMetadata;
  var needsAnnotatedData;
  var needsFormatListType = contains(properties, 'formatListType');

  var metaFields = ['collaborative', 'subscribed', 'published', 'name', 'owner', 'description', 'allows'];

  properties.forEach(function (key) {
    if (key === 'popularity') needsPopularity = true;
    if (key === 'image' || key === 'images') {
      needsImage = true;
    }
    if (key === 'annotatedImage') {
      needsAnnotatedData = true;
    }
    if (!needsMetadata && contains(metaFields, key)) needsMetadata = true;
  });

  if (needsMetadata) updateMetadata(model, needsImage);else if (needsImage) updateImage(model);

  if (needsAnnotatedData) updateAnnotatedData(model);

  if (needsPopularity) updatePopularity(model);

  if (needsShouldBeOffline || needsOfflineProgress || needsOfflineStatus) updateOffline(model);

  if (needsPlayable) updateAndSubscribePlayable(model);

  if (needsFormatListType) updateFormatListType(model);
}

function onInit(model) {
  bridgeWait(model);
  if (global._getSpotifyModule) {
    bridgeWaitAny(model);
  }
}

function onPublish(model, properties) {
  // Only shouldBeOffline is handled here
  if (!properties.hasOwnProperty('shouldBeOffline')) {
    return;
  }

  live(CLIENT).query('session(capabilities(offlineSync))', function (error, data) {
    if (error && global.console) console.error(error);
    if (error || !data.session.capabilities.offlineSync) {
      sendCantOfflineMessage();
    } else {
      var shouldBeOfflineValue;

      if ('shouldBeOffline' in properties) shouldBeOfflineValue = !!properties.shouldBeOffline;

      if (shouldBeOfflineValue !== undefined) {
        // optimistic update, this gets reverted somewhere else
        updateModelWithOffline(model, { offline_availability: shouldBeOfflineValue ? 'yes' : 'no' });
        publishShouldBeOffline(model, shouldBeOfflineValue);
      }
    }
  }, live.ASAP);
}

function onUpdate(model, data) {
  if ('offlineStatus' in data) {
    var shouldBeOffline = model.get('shouldBeOffline');
    var isDownloading = data.offlineStatus === OFFLINE_STATUS.DOWNLOADING;
    var shouldSubscribe = shouldBeOffline && isDownloading;

    if (shouldSubscribe) {
      subscribeToOfflineProgress(model);
    } else {
      unsubscribeToOfflineProgress(model);
    }
  }
}

function updateOffline(model) {
  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOffline(model, resource);
    } else {
      updateModelWithOffline(model, { offline_availability: 'no' });
      if (global.console) console.error(error);
    }
  });
}

function updateModelWithOffline(model, resource) {
  var shouldBeOffline = false;
  var progress;

  switch (resource.offline_availability) {
    case OFFLINE_STATUS.WAITING:
      shouldBeOffline = true;
      progress = 0;
      break;
    case OFFLINE_STATUS.DOWNLOADING:
      shouldBeOffline = true;
      break;
    case OFFLINE_STATUS.YES:
      shouldBeOffline = true;
      progress = 1;
      break;
    case OFFLINE_STATUS.NO:
      progress = 0;
      break;
  }

  // Updating this one will cause the 'update' event to start listening for
  // progress changes and update offlineProgress.
  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineStatus: resource.offline_availability
  });

  if (progress !== undefined) {
    model.update({
      offlineProgress: progress
    });
  }
}

function updateAndSubscribePlayable(model) {
  // Todo: It would be nice to take the users cache state into account,
  // a ticket for that: KM-8283. 'playable' would then change meaning from
  // 'according to track metadata' to 'according to track metadata and cache
  // state when offline', but that can be seen as a progressive enhancement.
  var playableRows = endpoints['core-playlist'] + '/' + encodeURIComponent(model.uri) + '/metadata?&filter=playable%20eq%20true';
  cosmos.subscribe({
    url: playableRows,
    body: {
      policy: {
        length: true
      }
    }
  }, function (error, response) {
    if (!error) {
      model.update({ playable: !!response.body.metadata.length });
    } else {
      console.error(error);
    }
  });
}

function updateFormatListType(model) {
  var url = 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata';

  cosmos.get({ url: url }, function (error, response) {
    var formatListType = 'playlist';
    if (!error && response.body && response.body.metadata && response.body.metadata.formatListType) {
      formatListType = response.body.metadata.formatListType;
    }
    model.update({
      formatListType: formatListType
    });
  });
}

function subscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (subscription) {
    return;
  }
  offlineSubscriptions[model.uri] = cosmos.subscribe({ url: 'sp://offline/v1/progress?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var progress = response.body.progress;
      model.update({ offlineProgress: progress.percent_complete / 100 || 0 });

      // unsubscribe to offline progress messages when the download is complete
      // (sometimes after a complete download we receive a progress event of 0)
      if (progress.percent_complete === 100) {
        unsubscribeToOfflineProgress(model);
      }
    } else {
      model.update({ offlineProgress: 0 });
      if (global.console) console.error(error);
    }
  });
}

function unsubscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (!subscription) {
    return;
  }

  subscription.cancel();
  delete offlineSubscriptions[model.uri];
}

function publishShouldBeOffline(model, enabled) {
  var method = enabled ? 'post' : 'delete';
  cosmos[method]({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (error) {
      updateModelWithOffline(model, {
        offline_availability: enabled ? 'no' : 'yes'
      });
    }
  });
}

function sendCantOfflineMessage() {
  cosmos.post({
    url: 'sp://messages/v1/container/user-message',
    body: {
      id: 'cant-offline-playlists'
    }
  });
}

var regExp = exports.matches = /^spotify:user:(.*):playlist|^spotify:internal:temp_playlist:|^spotify:temp-playlist:/;
var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'update', onUpdate);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'update', onUpdate);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/bridge":306,"./util/cosmos":308,"debug":369,"interpolate":405,"mout/array/contains":463,"mout/array/intersection":472,"mout/object/mixIn":504,"spotify-liburi":563}],288:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/session-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:session-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/session-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'session_storage',
    name: 'broadcast_session_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'session_storage',
    name: 'set_session_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);

  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/cosmos":308,"mout/array/combine":462,"mout/array/contains":463,"mout/array/remove":474,"mout/object/forOwn":500}],289:[function(require,module,exports){
"use strict";

/**
 * This module splits up a list into many chunks.
 *
 * @module spotify-live-models/sorting/chunker
 * @private
 */

/**
 * Splits up an array of data into smaller chunks.
 *
 * @param {Array} list The array to be split up.
 * @param {number=} opt_size Optional size of each chunk.
 *
 * @return {Array} Array of chunks, where each chunk is an array of data.
 */
module.exports = function (list, opt_size) {

  function split(array, segments) {
    segments = segments || 2;
    var results = [];
    if (array == null) {
      return results;
    }

    var minLength = Math.floor(array.length / segments);
    var remainder = array.length % segments;
    var i = 0;
    var len = array.length;
    var segmentIndex = 0;
    var segmentLength;

    while (i < len) {
      segmentLength = minLength;
      if (segmentIndex < remainder) {
        segmentLength++;
      }

      results.push(array.slice(i, i + segmentLength));

      segmentIndex++;
      i += segmentLength;
    }

    return results;
  }

  var size = opt_size || 50;
  var chunkCount = Math.ceil(list.length / size);
  var chunks = split(list, chunkCount);

  return chunks;
};

},{}],290:[function(require,module,exports){
/**
 * This file contains transformations from legacy sort queries to new sort
 * queries. We need this because when a user sorts by a certain column, we store
 * the full URI for that list and the sort query is part of the URI. Whenever
 * we change the sort query of a column, we will break sorting for users who
 * have a stored sort state with the old query. That's why we need to maintain
 * this conversion from old to new to make the right list load for all users.
 *
 * When to remove a conversion needs to be weighed case by case I guess. If a
 * user sorts by a certain column and doesn't launch the client for three months
 * and we change the query during that time, it's expected to still work for
 * that user when logging in the next time.
 *
 * History of this file is in the play-desktop app,
 * https://ghe.spotify.net/zelda/client-zelda-js/blob/master/apps/playlist-desktop/src/legacy-sort-uris.js
 */
'use strict';

exports.legacyQueries = {
  // Change date: 2015-03-16
  'track(album(name))': 'track(album(name),disc,number)',
  // Change date: 2015-03-16
  'track(artists(name))': 'track(artists[0:1](name),album(name),disc,number)',
  // Change date: 2015-03-17, value changed 2015-07-14 because we introduced the conversion below.
  'track(addedBy)': 'addedBy(name)',
  // Change date: 2015-07-14
  'track(addedBy(name))': 'addedBy(name)',
  // Change date: 2015-06-26
  'timeSinceAdded': 'timeSinceAdded,track(album(name),disc,number)'
};

},{}],291:[function(require,module,exports){
'use strict';

/**
 * This module helps posting chunked data to/from a worker.
 *
 * @module spotify-live-models/sorting/poster
 * @private
 */

/**
 * Posts data from/to a worker.
 *
 * @param {Object} worker A web worker.
 * @param {Array} chunks Array of split up data.
 * @param {number} index Index of the current chunk to post. Initiate the
 *     poster with 0, and it posts all data sequentially until all data
 *     is posted.
 * @param {string} id An ID for the full payload.
 */
module.exports = function poster(worker, chunks, index, id) {
  'use strict';

  var data = {
    items: chunks[index],
    id: id
  };

  if (index === chunks.length - 1) {
    data.last = true;
  }

  worker.postMessage(data);

  if (!data.last) {
    poster(worker, chunks, index + 1, id);
  }
};

},{}],292:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module sorts an array of data in the best possible way.
 * If Web Workers are supported, it will spawn new workers and
 * sort on different threads to speed it up.
 *
 * @module spotify-live-models/sorting/sort
 * @private
 */

var chunker = require('./chunker');
var poster = require('./poster');
var sorter = require('./sorter');
var sortWorker = require('./sortworker');
var defer = require('prime/defer');

var workerFile;
var workers = {};
var callbacks = {};
var waitingForReset = {};

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * The local sorter that sorts on the main thread.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
*/
function localSorter(sortUri, items, callback) {
  items = sorter(items);

  // Saving the callback as the latest callback for this sorted list
  // will allow us to only respond with the latest sorted values (if
  // multiple sort calls were made at the same time).
  callbacks[sortUri] = callback;

  // Make the callback async
  defer(function () {

    // Only allow the latest callback to run
    if (callback === callbacks[sortUri]) {
      delete callbacks[sortUri];

      callback(null, items);
    }
  });
}

/**
 * The Web Worker sorter.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
function workerSorter(sortUri, items, callback) {
  var worker = workers[sortUri];

  // If we already have a worker for this sorted list, reset that worker
  // and tell it to sort the new data. By saving the callback we make sure
  // that the original worker event handler will run the latest callback
  // when the sorting is done.
  if (worker) {
    callbacks[sortUri] = callback;
    waitingForReset[sortUri] = (waitingForReset[sortUri] || 0) + 1;
    var id = (++idCounter).toString(36);
    lastIds[sortUri] = id;
    worker.postMessage({ reset: true, newId: id });
    sendItemsToWorker(items, worker, id);
    return;
  }

  worker = new Worker(workerFile);
  workers[sortUri] = worker;
  callbacks[sortUri] = callback;

  var id = (++idCounter).toString(36);
  lastIds[sortUri] = id;
  sendItemsToWorker(items, worker, id);

  var result = { items: [] };

  worker.addEventListener('message', function (event) {
    onWorkerMessage(event, result, sortUri);
  }, false);
}

/**
 * Event handler for receiving a message from a worker.
 * This will handle collecting all chunks of data and post it to the latest
 * callback when all chunks have been received.
 *
 * @param {Event} event An event object from the worker 'message' event.
 * @param {Object} result An object with a property `items` for the sorted items.
 * @param {string} sortUri The sort URI for the current sort.
 */
function onWorkerMessage(event, result, sortUri) {

  // When the main thread tells the worker to reset, the worker will respond with
  // a message to reset the array of already sorted items.
  if (event.data.reset) {
    waitingForReset[sortUri]--;
    result.items.length = 0;
    return;
  }

  // Skip messages that don't belong to the latest sort
  if (event.data.id !== lastIds[sortUri]) {
    return;
  }

  // If we are still waiting for reset messages, don't continue to add more items
  // to the list of sorted items.
  if (waitingForReset[sortUri]) {
    return;
  }

  // If we are not waiting for any resets, just save the chunk of sorted items.
  result.items = result.items.concat(event.data.items);

  // When all data has been passed over from the worker, kill the worker and run
  // the latest registered callback for this sorted list.
  if (event.data.last) {
    workers[sortUri].terminate();

    var callback = callbacks[sortUri];
    delete callbacks[sortUri];
    delete workers[sortUri];

    callback(null, result.items);
  }
}

/**
 * Create the Web Worker file path.
 * Since the worker can't share objects with the main thead, we can't share
 * dependencies. To solve this, we convert the dependencies to strings and pass
 * them as arguments to the worker file.
 * To circumvent the need of a separate file for the worker, we make the worker
 * itself and the passed dependencies a single string and make a blob out of it.
 * From the blob we can get a URL that we can pass to the worker constructor.
 *
 * @return {string} Blob URL that can be passed to the worker.
 */
function createWorkerFile() {
  var workerStr = sortWorker.toString();
  var sortStr = sorter.toString();
  var chunkerStr = chunker.toString();
  var posterStr = poster.toString();
  var argsStr = [sortStr, chunkerStr, posterStr].join(', ');
  var stringWorker = '(' + workerStr + ')(' + argsStr + ')';

  var blob = new Blob([stringWorker], { type: 'text/javascript' });
  var url = URL.createObjectURL(blob);

  return url;
}

/**
 * Send the provided items to the provided worker. It will do this by splitting
 * the items into chunks and sending the chunks.
 *
 * @param {Array} items An array of items.
 * @param {Worker} worker A worker instance.
 * @param {string} id The ID for the payload.
 */
function sendItemsToWorker(data, worker, id) {
  var chunks = chunker(data);
  poster(worker, chunks, 0, id);
}

/**
 * Get the sort function to use.
 * If Web Workers are supported, it will use that, otherwise it will use the
 * default sorter on the main thread.
 * Having the code in a function allows for testing where worker support can
 * be removed and added while running the tests.
 *
 * @return {Function} The sorter function.
 */
function getSorter() {
  if (global.Worker && global.Blob && global.URL) {
    if (!workerFile) {
      workerFile = createWorkerFile();
    }
    return workerSorter;
  } else {
    return localSorter;
  }
}

/**
 * Sort the data using the best supported method.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
module.exports = function (sortUri, items, callback) {
  var sort = getSorter();
  sort(sortUri, items, callback);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chunker":289,"./poster":291,"./sorter":293,"./sortworker":294,"prime/defer":513}],293:[function(require,module,exports){
'use strict';

/**
 * This module sorts an array of data.
 *
 * @module spotify-live-models/sorting/sorter
 * @private
 */

/**
 * Sorts an array of data. Supports multiple levels of values
 * (if two items are the same, it tests the values in the next level).
 *
 * @param {Array.<Object>} data Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @return {Array.<Object>} A new array of the same objects that were
 *     passed in, but sorted.
 */
module.exports = function (data) {
  'use strict';

  data.sort(function (a, b) {

    var length = a.data.length;

    for (var i = 0; i < length; i++) {
      var aValue = a.data[i];
      var bValue = b.data[i];

      var aNumber = parseInt(aValue, 10);
      var bNumber = parseInt(bValue, 10);

      var aStartsWithNumber = !isNaN(aNumber);
      var bStartsWithNumber = !isNaN(bNumber);

      if (aStartsWithNumber && bStartsWithNumber) {
        if (aNumber < bNumber) return -1;
        if (aNumber > bNumber) return 1;
      } else if (aStartsWithNumber) {
        return -1;
      } else if (bStartsWithNumber) {
        return 1;
      }

      if (aValue.localeCompare) {
        var value = aValue.localeCompare(bValue);
        if (value !== 0) return value;
      } else {
        if (aValue < bValue) return -1;
        if (aValue > bValue) return 1;
      }
    }
  });

  return data;
};

},{}],294:[function(require,module,exports){
'use strict';

/**
 * This is the Web Worker file that sorts the data and passes it back again.
 * The file cannot be passed directly to new Worker(), as it needs some
 * dependencies. These dependencies are required before creating the worker,
 * and then serialized together with this file into a single blob, which is
 * used to create the worker.
 *
 * @module spotify-live-models/sorting/sortworker
 * @private
 */

/**
 * Sort worker.
 *
 * @param {Function} sort Function that sorts an array of data based on a
 *     property.
 * @param {Function} chunk Function that splits up data into chunks.
 * @param {Function} post Function that posts chunks of data back to main
 *     thread.
 * @param {Object} opt_worker Optional worker instance (mainly for testability).
 */
module.exports = function (sort, chunk, post, opt_worker) {
  'use strict';

  var worker = opt_worker || self;

  var itemsToSort = [];
  var id = null;

  worker.addEventListener('message', function (event) {

    // When the main thread tells the worker to reset, the worker will respond with
    // a message to reset the array of already sorted items.
    if (event.data.reset) {
      itemsToSort.length = 0;
      id = event.data.newId;
      worker.postMessage({ reset: true, newId: id });
      return;
    }

    // Only set the stored id for the first message
    if (id === null) {
      id = event.data.id;
    }

    // If the event id does not match the stored id, don't do anything.
    // This allows a sort to be aborted in the middle.
    if (id !== event.data.id) {
      return;
    }

    itemsToSort = itemsToSort.concat(event.data.items);

    if (event.data.last) {
      var sortedItems = sort(itemsToSort);
      var chunks = chunk(sortedItems);
      post(worker, chunks, 0, id);
    }
  }, false);
};

},{}],295:[function(require,module,exports){
'use strict';

/**
 * Get the row values used for sorting.
 *
 * @module spotify-live-models/sorting/values
 * @private
 */

/**
 * Get the values from the row based on the passed mask.
 * String values will be sanitized (lowercase, removing articles like 'the' etc).
 * The values can then be used for sorting.
 *
 * @param {Object} mask A mask object from the query parser.
 * @param {Object} row Row data object.
 *
 * @return {Array>} Array of values to sort on.
 *
 * @example
 * var parse = require('../../spotify-live/util/parser');
 * var mask = parse('track(name), track(artists(name))').mask;
 * var row = {track: {name: 'Track', artists: [{name: 'Artist'}]}};
 * var values = getValues(mask, row);
 * console.log(values);
 * // ['track', 'artist']
 */
function getValues(mask, row) {
  var result = [];
  mask.forEach(function (m) {
    var k = m.key;
    var value = row[k];

    // If the value is an array, we will concatenate all the
    // values with a comma in between, so that sorting takes
    // all values into account. An example is sorting tracks
    // based on 'artists(name)', where there can be many
    // artists for a track. We will in that case concatenate
    // all artists with comma in between and use a string with
    // all the artists when we compare in the sort function.
    if (Array.isArray(value)) {
      if (m.mask) {
        var values = [];
        for (var i = 0, l = value.length; i < l; i++) {
          values = values.concat(getValues(m.mask, value[i]));
        }
        result.push(values.join(', '));
      } else {
        result.push(value.join(', '));
      }
    } else {
      if (m.mask) result.push.apply(result, getValues(m.mask, value));else result.push(value);
    }
  });

  result = sanitizeStrings(result);

  return result;
}

/**
 * Sanitize string values. This includes trimming whitespace, converting
 * the string to lower case and removing common articles like 'the'.
 *
 * @param {Array} values Array of values.
 *
 * @return {Array} A new array of sanitized values.
 */
function sanitizeStrings(values) {
  var numberRe = /\b[0-9]+\b/g;
  var pad = '000000';

  return values.map(function (value) {
    if (typeof value !== 'string') return value;

    value = value.toLowerCase();

    // Remove the first article
    var articles = ['the ', '(the) '];
    for (var i = 0, article; article = articles[i]; i++) {
      if (value.indexOf(article) === 0) {
        value = value.replace(article, '');
        break;
      }
    }

    // Zero-pad numbers for natural numeric sorting (i.e. 2 before 10)
    value = value.replace(numberRe, function (match) {
      if (match.length >= pad.length) return match;
      return pad.substr(0, pad.length - match.length) + match;
    });

    return value.trim();
  });
}

module.exports = getValues;

},{}],296:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/sortlist
 */
'use strict';

var live = require('../spotify-live');
var mixIn = require('mout/object/mixIn');

var Range = require('../spotify-range2');
var diff = require('../spotify-live/util/diff');
var parse = require('../spotify-live/util/parser');
var sortUriUtils = require('../spotify-live-sort-uri');
var listOperations = require('spotify-live-list-operations');

var sort = require('./sorting/sort');
var getValues = require('./sorting/values');

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * Event handler for the live 'init' event on sorted models. Keeps sorted model
 * and tracking model in sync (properties, not rows).
 *
 * This will set up an update listener for the tracking model, so that any
 * changes to the tracking model are also applied to the sort model.
 *
 * This also sets up a publish listener for the sorted model, so that anything
 * that is published on the sorted model gets published on the tracking model,
 * which can then update backend with the data and then update the tracking
 * model with the correct data, which will then trickle back down to the
 * sorted model.
 *
 * @param {LiveObject} sortModel The sorted live model.
 */
function onInit(sortModel) {
  var trackingModel = getTrackingModel(sortModel.uri);

  lastIds[sortModel.uri] = (++idCounter).toString(36);

  // Update the sorted model when any property on the tracking model changes (except rows)
  trackingModel.on('update', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    sortModel.update(updateObject);
  });

  // Update the tracking model when any property on the sort model changes (except rows)
  sortModel.on('publish', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    trackingModel.publish(updateObject);
  });
}

/**
 * Event handler for the live 'wait' event on sorted models.
 * This will fetch any requested property from the tracking model, or if
 * rows are requested, it will perform a sort of the rows from the tracking
 * model.
 *
 * It will also listen for changes. If a change is published on the sorted list,
 * it will be republished on the tracking list. When the tracking list is updated
 * with the new data (maybe after a save on the backend), the sorted list will be
 * updated and resorted if needed.
 *
 * @param {LiveObject} sortModel The sorted live model.
 * @param {Array} properties Array of properties that the model is waiting for.
 */
function onWait(sortModel, properties) {
  var trackingModel = getTrackingModel(sortModel.uri);

  properties.forEach(function (key) {

    // Requesting rows will create a live list of rows, perform sorting,
    // fill the list with the sorted items and also start to listen for changes.
    if (key === 'rows') {
      setRowsProperty(sortModel, trackingModel);

      // Requesting any other property than rows will just get that property from
      // the tracking model.
    } else {
      trackingModel.get(key, function (error, value) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        var obj = {};
        obj[key] = value;
        sortModel.update(obj);
      });
    }
  });
}

/**
 * Set the `rows` property on the sort model. It will create a new live list
 * and perform sorting based on the rows of the tracking model. It will also
 * set up listeners for any changes to the lists to automatically keep
 * everything in sync.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveObject} trackingModel The live object for the list the sorted
 *     list is tracking.
 */
function setRowsProperty(sortModel, trackingModel) {
  var sortParams = sortUriUtils.parse(sortModel.uri);
  var direction = sortParams.direction;
  var query = sortParams.query;

  // Start the first sort
  performRowSorting(trackingModel, sortModel, query, direction);

  // Whenever a publish call happens on the sorted list, publish it to the
  // tracking list.
  sortModel.get('rows', function (error, sortList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    sortList.on('publish', function (operations) {
      var trackingList = trackingModel.get('rows');
      if (!trackingList) return;
      syncRows(trackingList, operations, 'publish');
    });
  });

  // We need to get the rows list of the tracking model to be able to know the
  // length of the list, so that we can create the rows list for the sorted list.
  trackingModel.get('rows', function (error, trackingList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Listen for updates on the tracking list and apply the changes (and
    // maybe resort if needed) on the sorted list.
    trackingList.on('update', function (operations) {
      var sortList = sortModel.get('rows');
      if (!sortList) return;
      var mustSort = syncRows(sortList, operations, 'update');
      if (mustSort) performRowSorting(trackingModel, sortModel, query, direction);
    });
  });
}

/**
 * Get the tracking model for a sort URI.
 * For an ascending sort URI, the tracking model would be the original list.
 * For a descending sort URI, the tracking model would be the ascending sort list.
 *
 * @param {string} sortUri The sort URI.
 *
 * @return {LiveObject} The live object for the tracking model.
 */
function getTrackingModel(sortUri) {
  var parsed = sortUriUtils.parse(sortUri);
  var direction = parsed.direction;
  var originUri = parsed.originUri;
  var query = parsed.query;

  // We can use the sorting from the ascending list when requesting the
  // descending list, by just depending on the ascending list. Asking for
  // data from the ascending list will make that list ask for the data
  // from the original list and then sort it, and then the descending list
  // will reverse that.
  if (direction === 'desc') {
    return live(sortUriUtils.create(originUri, 'asc', query));
  } else {
    return live(originUri);
  }
}

/**
 * Get data that is needed for performing a sort.
 *
 * @param {Array.<Object>} rows Array of objects of metadata about the rows.
 * @param {Object} mask A mask object from the query parser.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 *
 * @return {Array.<Object>} A new array of items used for sorting. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @example
 * {
 *   data: ['Name of Song', 'Whatever', 100, 0],
 *   key: '0'
 * }
 */
function getSortData(rows, mask, trackingList) {
  return rows.map(function (row, i) {
    var array = getValues(mask, row);
    array.push(i);
    return { data: array, key: trackingList.keys[i] };
  });
}

/**
 * Perform sorting of all rows in a list.
 *
 * @param {LiveObject} trackingModel The model that the sort model is tracking.
 *     For ascending lists, this is the original model. For descending lists,
 *     this is the ascending sort model.
 * @param {LiveObject} sortModel The model to perform the sort on.
 * @param {string} sortQuery The sort query (live compatible query).
 * @param {string} sortDirection The sort direction ('asc' or 'desc').
 */
function performRowSorting(trackingModel, sortModel, sortQuery, sortDirection) {
  lastIds[sortModel.uri] = (++idCounter).toString(36);
  var sortId = lastIds[sortModel.uri];

  // Querying the rows of the tracking model might perform a sort. An example is when
  // getting the sort for a descending list, it will query the rows from the ascending
  // list, which will in turn query the rows from the original list and then perform a
  // sort. When the ascending sort is done, the query will be done and the descending
  // list can just use the ascending list and reverse it.
  trackingModel.get('rows', function (error, rows) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Create a list of loaded rows. This allows partial loading of a list,
    // and the sorted version will only contain the loaded rows.
    var rowsToSort = [];
    var keys = [];
    for (var i = 0, l = rows.length; i < l; i++) {
      if (rows.get(i)) {
        rowsToSort.push(rows.get(i));
        keys.push(rows.keys[i]);
      }
    }

    // Empty lists won't sort anyway, so quit here, but empty the sorted list
    // to make it up to date.
    if (rowsToSort.length === 0) {
      var sortList = sortModel.get('rows');
      if (sortList) {
        sortList.update([{
          type: 'remove',
          index: 0,
          length: sortList.length
        }]);
      } else {
        sortModel.update({ rows: [] });
      }
      return;
    }

    var partialTrackingList = live([]);

    partialTrackingList.update([{
      type: 'insert',
      index: 0,
      values: rowsToSort,
      keys: keys
    }]);

    // Now we have a list containing only the loaded rows
    partialTrackingList.query(sortQuery, function (error, rows) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // If direction is descending, the tracking model is ascending. Simply reverse that.
      if (sortDirection === 'desc') {
        updateListWithReversedData(sortModel, partialTrackingList);

        // For an ascending sort, perform a real sort.
      } else {

        var mask = parse(sortQuery).mask;
        var sortData = getSortData(rows, mask, partialTrackingList);

        sort(sortModel.uri, sortData, function (error, sortedData) {
          if (error) {
            if (global.console) console.error(error);
            return;
          }
          if (lastIds[sortModel.uri] !== sortId) return;
          updateListWithSortedData(sortModel, partialTrackingList, sortedData);
        });
      }
    });
  });
}

/**
 * Update the sorted live list with the right data after a sort.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 * @param {Array.<Object>} sortedItems Array of sorted items. Each item is
 *     an object with a property `key`, which is a string for the row ID.
 */
function updateListWithSortedData(sortModel, trackingList, sortedItems) {
  var sortList = sortModel.get('rows');

  // Copy the rows from the list that the sorted list is tracking,
  // if the sorted list has no tracks yet. Only for the first time.
  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  var length = sortedItems.length;
  var keys = new Array(length);
  var values = new Array(length);

  for (var i = 0, l = sortedItems.length; i < l; i++) {
    keys[i] = sortedItems[i].key;
    values[i] = trackingList.valueOf(keys[i]);
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    keys: keys,
    values: values
  }]);
}

/**
 * Update the sorted live list with the data of the list it is tracking,
 * but reversed.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 */
function updateListWithReversedData(sortModel, trackingList) {
  var sortList = sortModel.get('rows');

  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    length: trackingList.length,
    values: trackingList.values.slice().reverse(),
    keys: trackingList.keys.slice().reverse()
  }]);
}

/**
 * Converting the passed in operations to be relative to the list that was
 * passed in. Passing operations for a sorted list can convert the operations
 * to be used for the original list. This also updates (or publishes) the list
 * with the converted operations.
 *
 * @param {LiveList} rows The list to sync operations to.
 * @param {Array.<Object>} operations Array of operation objects.
 * @param {string} mode The mode for updates. 'update' or 'publish'.
 *
 * @return {boolean} True if a resort must happen after applying the operations.
 */
function syncRows(rows, operations, mode) {
  var mustSort = false;

  operations.forEach(function (operation) {
    var newOperations = [];

    switch (operation.type) {

      // If rows are removed from the tracking list, we can "simply" remove
      // the same rows from the sorted model.
      case 'remove':
        newOperations = convertRemoveOperationForList(rows, operation);
        break;

      // If rows are inserted in the tracking list, we must add the rows to
      // the sorted list and resort. Where we insert doesn't matter as we will
      // perform a new sort anyway.
      case 'insert':
        newOperations = [{
          type: 'insert', index: 0,
          values: operation.values, keys: operation.keys
        }];
        mustSort = true;
        break;

      // If rows are moved in the tracking list, we don't need to perform any
      // new moves directly, but we will need to perform a resort, as sorting
      // uses stable sort (falls back on index in original list if compared
      // values are the same).
      case 'move':
        mustSort = true;
        break;
    }

    if (mode === 'publish') {
      rows.publish(newOperations);
    } else if (mode === 'update') {
      rows.update(newOperations);
    }
  });

  return mustSort;
}

/**
 * Convert a remove operation from one list to an operation that can
 * be used in another list. An example is when we have an operation that
 * happened in the original list, we need to convert that to operations
 * that can be applied to the sorted list.
 *
 * @param {LiveList} list The live list to create the operations for.
 * @param {Object} operation The input 'remove' operation.
 *
 * @return {Array.<Object>} Array of remove operation objects.
 */
function convertRemoveOperationForList(list, operation) {
  var indices = [];
  var operationKeys = operation.keys;

  list.keys.forEach(function (key, i) {
    if (operationKeys.indexOf(key) > -1) indices.push(i);
  });

  return listOperations.getRemoveOperations(indices);
}

var regExp = exports.matches = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"../spotify-live-sort-uri":310,"../spotify-live/util/diff":313,"../spotify-live/util/parser":315,"../spotify-range2":352,"./sorting/sort":292,"./sorting/values":295,"mout/object/mixIn":504,"spotify-live-list-operations":564}],297:[function(require,module,exports){
'use strict';

/**
 * @module spotify-live-models/station
 */

var live = require('../spotify-live');

// Utilities
var trackToRow = require('./station/track-to-row');
var contains = require('mout/array/contains');
var spotifyURI = require('spotify-liburi');
var messageProxy = require('./station/station-message-proxy.js');
var thumbActions = require('./station/thumb-actions');

var appUri; // The app where this live model is being used.

var URI = exports.URI = 'spotify:station:';
var regExp = exports.matches = new RegExp('^' + URI + '(' + '((artist:|album:|track:)[a-zA-Z0-9]{22})' + '|' + '(user:[^:]+:' + '(playlist:[a-zA-Z0-9]{22}|top:tracks|toplist))' + '|' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + '|' + '(genre:[a-zA-Z0-9]*)' + ')');
exports.isStationUri = regExp.test.bind(regExp);

var DEFAULT_FETCH_COUNT = 15;

// Station Types
var PLAYLIST = 'playlist';
var TRACK = 'track';
var ALBUM = 'album';
var ARTIST = 'artist';
var GENRE = 'genre';
var CLUSTER = 'cluster';
var UNKNOWN = 'unknown';

var registered = false;
var queryReplySubscription;
var metadataUpdateSubscription;

var trackingRows = []; // A list of stations that need row updates.
var trackingMetadata = []; // A list of stations that need metadata updates.

/**
 * Get the station's base seed from the live model uri
 * @param {Object} model
 * @return {String}
 */
function getBaseSeedFromUri(model) {
  var seed = model.uri.replace(/^spotify:station:/, 'spotify:');
  return decodeURIComponent(seed);
}

/**
 * Get the station type
 * @param {String} seed
 * @return {String}
 */
function getType(seed) {
  var uri = spotifyURI.from(seed);
  if (!uri) {
    return UNKNOWN;
  }
  var contextType = uri.type;
  if (contextType === spotifyURI.Type.PLAYLIST) {
    return PLAYLIST;
  } else if (contextType === spotifyURI.Type.ARTIST) {
    return ARTIST;
  } else if (contextType === spotifyURI.Type.ALBUM) {
    return ALBUM;
  } else if (contextType === spotifyURI.Type.TRACK) {
    return TRACK;
  } else if (seed.indexOf('spotify:genre:') === 0) {
    return GENRE;
  } else if (seed.indexOf(':cluster:') > 0) {
    return CLUSTER;
  } else {
    return UNKNOWN;
  }
}

/**
 * Thumb up a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbUp(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.UP
  });
}

/**
 * Thumb down a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbDown(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.DOWN
  });
}

/**
 * Post a request for data from the container (station-manager in zlink).
 * @param {Object} model
 * @param {Array} properties
 * @param {Boolean} needsRows
 * @param {Integer} fetchCount
 */
function requestStationData(model, properties, needsRows, fetchCount) {
  var count = needsRows ? fetchCount || model.get('fetchCount') : false;
  messageProxy.request({
    'appUri': appUri,
    'stationUri': model.get('uri'),
    'metadata': properties,
    'trackCount': count
  });
}

/**
 * Get the appURI to compare against the referrerIdentifier from the player
 */
function getAppUri() {
  live('spotify:application').query('appURI', function (error, data) {
    if (!error) {
      appUri = data.appURI;
    }
  });
}

/**
 * Callback for rows wait event.
 * @param {Object} model
 * @param {Array} ranges
 */
function onRowsWait(model, ranges) {
  if (ranges && ranges.length > 0) {
    var fetchCount = 0;
    var largestTrack = 0;
    ranges.forEach(function (a) {
      if (a.end > largestTrack) {
        largestTrack = a.end;
      }
    });
    fetchCount = largestTrack - model.get('rows').length;
    requestStationData(model, [], true, fetchCount);
  }
}

/**
 * Subscriber for request reply messages
 * @param {Object} opts
 */
function onRequestReply(opts) {
  var sentAppUri = opts.appUri;
  var stationUri = opts.stationUri;
  var station = opts.station;
  if (sentAppUri === appUri) {
    if (station.hasOwnProperty('tracks')) {
      if (trackingRows.indexOf(stationUri) !== -1) {
        var timeStamp = new Date().getTime();
        station.rows = station.tracks.map(trackToRow.bind(null, timeStamp));
      }
      // Never keep a tracks object in the station (needs to be rows).
      delete station.tracks;
    }
    live(stationUri).update(station);
  }
}

/**
 * Subscriber for updateMetadata messages
 * @param {Object} opts
 */
function onUpdateMetadata(opts) {
  var stationUri = opts.stationUri;
  var metadata = opts.metadata;
  if (trackingMetadata.indexOf(stationUri) === -1) {
    return;
  }
  if (metadata.hasOwnProperty('tracks')) {
    if (trackingRows.indexOf(stationUri) !== -1) {
      var timeStamp = new Date().getTime();
      metadata.rows = metadata.tracks.map(trackToRow.bind(null, timeStamp));
    }
    // Never keep a tracks object in the station (needs to be rows).
    delete metadata.tracks;
  }
  live(stationUri).update(metadata);
}

/**
 * When the model intializes
 * @param {Object} model
 */
function onInit(model) {
  var baseSeed = getBaseSeedFromUri(model);
  if (!baseSeed) {
    return;
  }
  model.update({
    baseSeed: baseSeed,
    type: getType(baseSeed),
    added: false, // set this by default
    fetchCount: DEFAULT_FETCH_COUNT
  });
  model.on('update', function onModelUpdate(properties) {
    if (properties.hasOwnProperty('rows')) {
      model.get('rows').on('wait', onRowsWait.bind(null, model));
      model.off('update', onModelUpdate);
    }
  });
  trackingMetadata.push(model.get('uri'));
}

/**
 * Model publish listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onPublish(model, properties) {
  if (properties.hasOwnProperty('added')) {
    var added = properties.added;
    if (typeof added === 'boolean') {
      model.update({ added: added });
      messageProxy.add({
        'stationUri': model.get('uri'),
        'add': added
      });
    } else {
      console.error('Added can only be a boolean');
    }
  }
}

/**
 * Unset props listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onWait(model, properties) {
  var rowsIndex = -1;
  var needsMetadata;
  var metaFields = ['name', 'subtitle', 'relatedArtists', 'image', 'nextPageUrl'];

  properties.forEach(function (key, index) {
    if (key === 'rows') {
      rowsIndex = index;
    }
    if (!needsMetadata && contains(metaFields, key)) {
      needsMetadata = true;
    }
  });

  if (rowsIndex !== -1) {
    trackingRows.push(model.get('uri'));
    properties.splice(rowsIndex, 1);
    requestStationData(model, properties, true);
  } else if (needsMetadata) {
    requestStationData(model, properties);
  }
}

exports.register = function (stationMessageProxy) {
  if (registered) {
    return;
  }
  registered = true;

  // used only for testing
  if (stationMessageProxy) {
    messageProxy = stationMessageProxy;
  }

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'thumb-up', onThumbUp);
  live.subscribe(regExp, 'thumb-down', onThumbDown);
  live.subscribe(regExp, 'publish', onPublish);
  queryReplySubscription = messageProxy.subscribeTo_requestReply(onRequestReply);
  metadataUpdateSubscription = messageProxy.subscribeTo_updateMetadata(onUpdateMetadata);
  getAppUri();
};

exports.unregister = function () {
  if (!registered) {
    return;
  }
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'thumb-up', onThumbUp);
  live.unsubscribe(regExp, 'thumb-down', onThumbDown);
  live.unsubscribe(regExp, 'publish', onPublish);
  queryReplySubscription.cancel();
  metadataUpdateSubscription.cancel();
  trackingRows = [];
  trackingMetadata = [];
};

},{"../spotify-live":312,"./station/station-message-proxy.js":301,"./station/thumb-actions":302,"./station/track-to-row":303,"mout/array/contains":463,"spotify-liburi":563}],298:[function(require,module,exports){
'use strict';

var rowToPlayerTrack = require('./row-to-player-track');

var PLAYER_RESTRICTIONS = {
  'disallow_toggling_repeat_context_reasons': ['disallow-radio'],
  'disallow_toggling_repeat_track_reasons': ['disallow-radio'],
  'disallow_toggling_shuffle_reasons': ['disallow-radio']
};

/**
 * Create an array of tracks formatted for the context player
 * @param {Object} model
 * @return {Array} tracks array
 */
function createPlayerTracks(model) {
  var rows = model.get('rows');
  if (!rows) {
    return [];
  }
  return rows.values.map(rowToPlayerTrack);
}

/**
 * Construct a context object for context-player
 * @param {Object} model station live model
 * @return {Object} context
 */
module.exports = function createPlayContext(model) {
  return {
    'entity_uri': model.get('uri'),
    'pages': [{
      'tracks': createPlayerTracks(model),
      'next_page_url': model.get('nextPageUrl')
    }],
    'metadata': {
      'context_description': model.get('name')
    },
    'restrictions': PLAYER_RESTRICTIONS
  };
};

},{"./row-to-player-track":300}],299:[function(require,module,exports){
'use strict';

var PLAYER_OPTIONS = {
  'shuffling_context': false,
  'repeating_context': false,
  'repeating_track': false
};

/**
 * This is neccesary because you dont get pages back from the context-player.
 * So if you want to resume a station with a set of rows (not pages)
 * you have to know the index of the last played row,
 * which you can get by comparing currentTrackUid with the row's Uid.
 * @param {Object} model station live model
 * @return {Int} index
 */
function getLastIndex(model) {
  var rows = model.get('rows');
  var currentTrackUid = model.get('currentTrackUid');

  if (!rows || !currentTrackUid) {
    return 0;
  }

  var currentIndex;

  var foundRow = rows.values.some(function (row, index) {
    if (row.get('uid') === currentTrackUid) {
      currentIndex = index;
      return true;
    }
  });

  return foundRow ? currentIndex : 0;
};

/**
 * Creates the context-player options for a station context
 * @param {Object} model station model
 * @param {Object} options optional
 * @return {Object} playOptions
 */
module.exports = function createPlayOptions(model, options) {
  if (options && (options.index || options.index === 0)) {
    var trackIndex = options.index;
  } else {
    var trackIndex = getLastIndex(model);
  }
  var playOptions = {
    'skip_to_index': {
      'page': 0,
      'track': trackIndex
    },
    'player_options_override': PLAYER_OPTIONS
  };
  if (options && options.uid) {
    playOptions.uid = options.uid;
  }
  return playOptions;
};

},{}],300:[function(require,module,exports){
'use strict';

/**
 * Converts a station row into a track for the context-player
 * @param {Object} row station row
 * @return {Object} track
 */

module.exports = function rowToPlayerTrack(row) {
  return {
    'uid': row.get('uid'),
    'uri': row.get('track').get('uri'),
    'album_uri': row.get('track').get('albumUri'),
    'artist_uri': row.get('track').get('artistUri'),
    'metadata': {
      'image_url': row.get('track').get('image'),
      'radio.thumb': row.get('thumb')
    }
  };
};

},{}],301:[function(require,module,exports){
'use strict';

/**
 * Station Message Proxy
 * This module is used to standarize the I/O of station messages
 * posted and subscribed by apps with stations. Mainly used to manage
 * the communication between apps and the station-manager in zlink.
 * For example: posting to the request message endpoint, certain object keys
 * are required, and when you add a subscriber
 * to that request endpoint, that function receives the same key/values.
 *
 * In the app:
 * stationMessageProxy.request({
 *  'appUri': 'spotfiy:app:stations',
 *  'stationUri': 'spotify:station:genre:rock',
 *  'metadata': true,
 *  'rowCount': 15
 * });
 *
 * In station-manager:
 * stationMessageProxy.subscribeTo_request(function(obj){
 *  obj.appUri // 'spotfiy:app:stations'
 *  obj.stationUri // 'spotify:station:genre:rock',
 *  obj.metadata // true
 *  obj.rowCount // 15
 * });
 */

var bridge = require('../../spotify-bridge-request');

// Message Uris
var baseUri = 'sp://messages/v1/station/';
var URIS = {
  ADD: baseUri + 'add',
  CREATE: baseUri + 'create',
  THUMB: baseUri + 'thumb',
  REQUEST: baseUri + 'request',
  REQUEST_REPLY: baseUri + 'request/reply',
  UPDATE_METADATA: baseUri + 'update/metadata',
  UPDATE_LAST_PLAYED: baseUri + 'update/lastPlayed',
  REQUEST_ALL: baseUri + 'request-all',
  REQUEST_ALL_REPLY: baseUri + 'request-all/reply',
  REQUEST_SAVED: baseUri + 'request-saved',
  REQUEST_SAVED_REPLY: baseUri + 'request-saved/reply'
};

// Module's Name
var NAME = 'station-message-proxy';

// Message Body Keys (the only valid keys that these proxy methods accept)
var KEY_APP_URI = 'appUri';
var KEY_STATION_URI = 'stationUri';
var KEY_METADATA = 'metadata';
var KEY_TRACK_COUNT = 'trackCount';
var KEY_STATION = 'station';
var KEY_ADD = 'add';
var KEY_THUMB = 'thumb';
var KEY_TRACK_URI = 'trackUri';
var KEY_SAVED_STATIONS = 'saved_stations';
var KEY_USER_STATIONS = 'user_stations';
var KEY_GENRE_STATIONS = 'genre_stations';
var KEY_RECOMMENDED_STATIONS = 'recommended_stations';
var KEY_CLUSTER_STATIONS = 'cluster_stations';
var KEY_CLUSTER_FORMAT_NAME = 'cluster_format_name';

/**
 * A hasmap of all the available methods you can call and 'subscribeTo'
 * and their required object keys.
 */
var API_METHODS = {
  'add': {
    'requiredKeys': [KEY_STATION_URI, KEY_ADD],
    'uri': URIS.ADD
  },
  'request': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_METADATA, KEY_TRACK_COUNT],
    'uri': URIS.REQUEST
  },
  'requestReply': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_STATION],
    'uri': URIS.REQUEST_REPLY
  },
  'updateMetadata': {
    'requiredKeys': [KEY_STATION_URI, KEY_METADATA],
    'uri': URIS.UPDATE_METADATA
  },
  'updateLastPlayed': {
    'requiredKeys': [KEY_STATION_URI],
    'uri': URIS.UPDATE_LAST_PLAYED
  },
  'thumb': {
    'requiredKeys': [KEY_STATION_URI, KEY_TRACK_URI, KEY_THUMB],
    'uri': URIS.THUMB
  },
  'requestAll': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_ALL
  },
  'requestAllReply': {
    'requiredKeys': [KEY_CLUSTER_FORMAT_NAME, KEY_CLUSTER_STATIONS, KEY_USER_STATIONS, KEY_RECOMMENDED_STATIONS, KEY_GENRE_STATIONS],
    'uri': URIS.REQUEST_ALL_REPLY
  },
  'requestSaved': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_SAVED
  },
  'requestSavedReply': {
    'requiredKeys': [KEY_SAVED_STATIONS],
    'uri': URIS.REQUEST_SAVED_REPLY
  }
};

function _cosmosError(fnName, error) {
  if (error) {
    console.error(NAME + ':' + fnName + ': ' + error);
  }
}

function _createSubscribeWrapper(fnName, subscriber) {
  return function wrapper(error, response) {
    if (error || !response || !response.body) {
      console.error(NAME + ':' + fnName + ' ', error);
      return;
    }
    var body;
    try {
      body = JSON.parse(response.body);
    } catch (e) {
      console.error(NAME + ':' + fnName + ': ' + e);
      return;
    }
    subscriber(body);
  };
}

function _subscribe(fnName, uri, subscriber) {
  if (typeof subscriber !== 'function') {
    throw new Error(NAME + ':' + fnName + ' needs a function.');
  }
  return bridge.cosmos({ method: 'SUB', uri: uri }, _createSubscribeWrapper('subscribeTo' + fnName, subscriber));
}

function _post(fnName, uri, requiredKeys, opts) {
  var body = {};
  requiredKeys.forEach(function (key) {
    if (!opts.hasOwnProperty(key)) {
      throw new Error(NAME + ':' + fnName + ':request missing keys: ' + requiredKeys);
    }
    body[key] = opts[key];
  });

  bridge.cosmos({ method: 'POST', uri: uri, body: JSON.stringify(body) }, _cosmosError.bind(null, 'request'));
}

var API = {};

Object.keys(API_METHODS).forEach(function (method) {
  API[method] = _post.bind(null, method, API_METHODS[method].uri, API_METHODS[method].requiredKeys);

  API['subscribeTo_' + method] = _subscribe.bind(null, method, API_METHODS[method].uri);
});

// Only for unit tests - do not use these directly
API.URIS = URIS;

module.exports = API;

},{"../../spotify-bridge-request":134}],302:[function(require,module,exports){
'use strict';

module.exports = {
  UP: 'ups',
  DOWN: 'downs'
};

},{}],303:[function(require,module,exports){
'use strict';

/**
 * Convert track objects coming from station-manager into a row.
 * @param {Object} track
 * @return {Object} row
 */

module.exports = function trackToRow(timeStamp, track, index) {
  var metadata = track.metadata || {};
  var artistUri = track.artist_uri || metadata.artist_uri;
  var albumUri = track.album_uri || metadata.album_uri;
  var uid = track.uid;

  if (!track.uid) {
    var id = track.uri.replace('spotify:track:', '');
    uid = timeStamp + id + index;
  }

  return {
    uid: uid,
    uri: uid,
    thumb: metadata['radio.thumb'] || '',
    track: {
      uri: track.uri,
      name: metadata.title,
      image: metadata.image_url,
      artistUri: artistUri,
      albumUri: albumUri,
      artists: [{ name: metadata.artist_name, uri: artistUri }],
      album: { name: metadata.album_title, uri: albumUri }
    }
  };
};

},{}],304:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/track
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var bridge = require('./util/bridge').request;
var cosmos = require('./util/cosmos');
var util = require('./util/common');

var BACKOFF = 100;
var localFilesRequest = null;

var metaFields = ['album', 'artists', 'availability', 'disc', 'duration', 'explicit', 'image', 'local', 'name', 'number', 'placeholder', 'playable', 'popularity', 'linkedTrack'];

function onWait(model, properties) {
  // Set the 'unavailable' property based on the 'playable' property
  if (contains(properties, 'unavailable')) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({ unavailable: !playable });
    });
  }

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);

  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  if (needsShouldBeOffline || needsOfflineProgress) {
    updateOffline(model);
  }
}

function updateMetadata(model) {
  bridge('track_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    util.setLocalProperties(payload);
    payload.image = largestImage(payload);

    // The linkedTrack is not available everywhere, so do fallback
    if (payload.linkedTrack) {
      payload.linkedTrack = { uri: payload.linkedTrack };
    } else {
      payload.linkedTrack = null;
    }

    model.update(payload);
  });
}

function largestImage(trackMetadata) {
  var imageURI = trackMetadata.image;
  var largestSize;

  if (trackMetadata.images) {
    for (var i = 0; i < trackMetadata.images.length; i++) {
      var currentImage = trackMetadata.images[i];
      if (!largestSize || currentImage[0] > largestSize) {
        largestSize = currentImage[0];
        imageURI = currentImage[1];
      }
    }
  }

  return imageURI;
}

function updateOffline(model) {

  // Local tracks are available offline if they are playable
  if (liburi.fromString(model.uri).type === liburi.Type.LOCAL) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        shouldBeOffline: playable,
        offlineProgress: playable ? 1 : 0
      });
    });
    return;
  }

  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOfflineData(model, resource);
    } else {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we handle it like the client doesn't support offline.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        updateModelWithOfflineData(model, { offline_availability: 'no' });
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOfflineData(model, resource) {
  var shouldBeOffline = false;
  var offlineProgress = 0;

  switch (resource.offline_availability) {
    case 'waiting':
      shouldBeOffline = true;offlineProgress = 0;break;
    case 'downloading':
      shouldBeOffline = true;offlineProgress = 0.5;break;
    case 'yes':
      shouldBeOffline = true;offlineProgress = 1;break;
  }

  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineProgress: offlineProgress
  });
}

function waitForLocalFilesChange() {
  localFilesRequest = cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
    if (!registered) return;

    if (error) {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we bail out and don't do anything.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        return;
      }
      if (global.console) console.error(error);
      return;
    }

    var event = response.body;
    var data = event.data;
    var type = event.type;
    var isAdded = type === 'added';
    var isRemoved = type === 'removed';

    if (isAdded || isRemoved) {
      data.tracks.forEach(function (track) {
        live(track.uri).update({
          shouldBeOffline: isAdded,
          offlineProgress: isAdded ? 1 : 0,
          playable: isAdded
        });
      });
    }
  });
}

function waitForTrackChange() {
  bridge('track_event_wait_any', [], function (error, event) {
    if (!registered) return;

    if (error) {
      setTimeout(function () {
        waitForTrackChange();
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    waitForTrackChange();

    if (event.type === 'change') {
      if (event.data.playable !== undefined) {
        event.data.unavailable = !event.data.playable;
      }
      live(event.data.uri).update(event.data);
    }
  });
}

var regExp = exports.matches = /^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);

  waitForLocalFilesChange();

  // Only desktop has support for track relinking
  if (!!global._getSpotifyModule) waitForTrackChange();
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);

  if (localFilesRequest) {
    localFilesRequest.cancel();
    localFilesRequest = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/bridge":306,"./util/common":307,"./util/cosmos":308,"mout/array/contains":463,"mout/array/intersection":472,"spotify-liburi":563}],305:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/user
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var intersection = require('mout/array/intersection');
var bridge = require('./util/bridge').request;

function updateMetadata(model) {
  bridge('user_metadata', [model.uri], function (error, payload) {
    if (error && global.console) console.error(error);

    if (!payload) payload = {};

    payload.username = payload.username || liburi.from(model.uri).username;
    payload.name = payload.name || payload.username;
    payload.image = payload.image || '';
    payload.images = payload.images || [];

    if (payload.subscribed == null) {
      payload.subscribed = false;
    }

    if (payload.currentUser == null) {
      live('spotify:client').query('currentUser(uri)', function (error, data) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({ currentUser: model.uri === data.currentUser.uri });
      });
    }

    model.update(payload);
  });
}

function updateArtist(model) {
  bridge('user_associated_artist', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    var artist = payload.artist ? { uri: payload.artist } : null;
    model.update({ artist: artist });
  });
}

function onWait(model, properties) {
  var hasArtist = contains(properties, 'artist');
  var metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasArtist) updateArtist(model);
}

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":312,"./util/bridge":306,"mout/array/contains":463,"mout/array/intersection":472,"spotify-liburi":563}],306:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":134}],307:[function(require,module,exports){
'use strict';

var liburi = require('spotify-liburi');

function setLocalProperties(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

/**
 * Export public interface
 */
module.exports = {
  setLocalProperties: setLocalProperties
};

},{"spotify-liburi":563}],308:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/util/cosmos
 * @private
 */

'use strict';

var cosmos = require('spotify-cosmos-api');

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":554}],309:[function(require,module,exports){
'use strict';

var Preferences = require('../../spotify-preferences');

var preferences = null;
var showUnplayableTracks = null;

var isInitialized = false;
var initCallbacks = [];

/**
 * Initialize the module and start listening for preference updates.
 */

function init(callback) {

  initCallbacks.push(callback);
  if (initCallbacks.length > 1) {
    // We already kicked of the subscription
    return;
  }

  subscribe(function (error, value) {
    if (!error) {
      showUnplayableTracks = !!value;
    }
    isInitialized = true;

    var cb;
    while (cb = initCallbacks.pop()) {
      cb(showUnplayableTracks);
    }
  });
}

/**
 * Subscribe for changes of the 'Show Unplayable Tracks' preference.
 *
 * @param {Function} callback Callback function that gets called for
 *                            each change.
 *
 * @return {Object} An object with a `cancel` method.
 */
function subscribe(callback) {
  var preferences = new Preferences('ui');

  return preferences.subscribe('show_unplayable_tracks', function (error, value) {
    if (error) return callback(error);
    callback(null, !!value);
  });
}

exports.subscribe = subscribe;

},{"../../spotify-preferences":351}],310:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:sortlist';
var regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

/**
 * Create a URI representing a sorted variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} direction The direction of the sorted list ('asc' or 'desc').
 * @param {string} query The query string (compatible with spotify-live). Sorting
 *     implementations might not look at all values. The list of produced values
 *     from the query will be tried in order from left to right. If two items have
 *     the same value, it will look at the next produced value from this query.
 *     Any spaces in the query will be removed.
 *
 * @return {string} URI of the sorted variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, direction, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);
  query = query.replace(/%20/g, '');

  return [base, direction, query, originUri].join(':');
};

/**
 * Get the direction of the sorted list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
 *     invalid, this returns an empty string.
 */
exports.getDirection = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return matches[1];
};

/**
 * Get the query string from a sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[2]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The URI of the original list. If the sort URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[3];
};

/**
 * Parse and return all parts of the sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return null;

  return {
    direction: matches[1],
    query: decodeURIComponent(matches[2]),
    originUri: 'spotify:' + matches[3]
  };
};

/**
 * Test if the provided URI is a valid sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (sortUri) {
  return regExp.test(sortUri);
};

/**
 * The regular expression that matches sort URIs.
 */
exports.regExp = regExp;

},{}],311:[function(require,module,exports){
'use strict';

var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');

/**
 * Create a URI representing a wrapped variant of a list.
 *
 * @param {object} opts The options.
 * @param {string} opts.originUri The origin uri.
 * @param {object?} opts.filter The filter, if any
 * @param {object?} opts.sort The sorting, if any
 *
 * @return {string} URI of the wrapped variant of the list.
 */
exports.create = function (opts) {
  var uri = opts.originUri;
  if (opts.filter) {
    uri = filterUriUtils.create(uri, opts.filter.query);
  }
  if (opts.sort) {
    uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
  }
  return uri;
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the wrapped list.
 *
 * @return {string} The URI of the original list. If the wrapped URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (wrappedUri) {
  var parsed = exports.parse(wrappedUri);
  return parsed && parsed.originUri || '';
};

/**
 * Parse and return all parts of the wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {object} An object with properties `originUri`, `sort` and `filter`.
 */
exports.parse = function (wrappedUri) {
  var sort = sortUriUtils.parse(wrappedUri);
  var filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
  if (!(sort || filter)) return null;

  return {
    originUri: filter && filter.originUri || sort && sort.originUri,
    sort: sort,
    filter: filter
  };
};

/**
 * Test if the provided URI is a valid wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (wrappedUri) {
  return !!exports.parse(wrappedUri);
};

},{"../spotify-live-filter-uri":260,"../spotify-live-sort-uri":310}],312:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('prime');
var defer = require('prime/defer');
var Emitter = require('prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isArray = require('mout/lang/isArray');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');
var keys = require('mout/object/keys');

// finally
var flow = require('finally');

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// debugging
var debug = require('debug')('spotify-live');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        debug(self, 'waiting for', self._waiting);
      } else {
        debug(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        debug(self, self._waiting);
      } else {
        debug(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    flow().parallel(values, function (objectValue, i) {
      var control = this;
      queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
        if (error) return control.break(error);
        if (!wasSync) isSync = false;
        if (data[keys[i]]) deepMixIn(data[keys[i]], dataValue);else data[keys[i]] = dataValue;
        control.done();
      });
    }).finally(function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;

  var filtered = [];

  flow().parallel(array, function (item, i) {
    var ctrl = this;

    if (isLiveObject(item)) {
      item._get([left], function (error, wasSync) {
        if (error) return ctrl.break(error);
        if (!wasSync) isSync = false;
        var value = item._data[left];
        if (satisfies(value, op, right)) filtered[i] = item;
        ctrl.done();
      });
    } else if (isPlainObject(item)) {
      if (satisfies(item[left], op, right)) filtered[i] = item;
      ctrl.done();
    } else {
      // filter objects only
      ctrl.done();
    }
  }).finally(function (error) {
    if (error) return callback(error);
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) clean.push(filtered[i]);
    }callback(null, clean, isSync);
  });
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  // single filter.
  // must be sequential.
  flow().sequential(selector.filters, function (conditions) {
    var sequential = this;

    var ref = [];

    // list of conditions in a single filter.
    // can be parallel.
    flow().parallel(conditions, function (condition) {
      var parallel = this;

      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallel.done();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallel.break(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallel.done();
          });
        }
      } else {

        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallel.break(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallel.done();
          });
        };

        if (isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallel.break(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }

      // parallel finished
    }).finally(function (error) {
      if (error) return sequential.break(error);
      list = ref;
      sequential.continue();
    });

    // sequential finished
  }).finally(function (error) {
    if (error) return callback(error);

    var data = [];

    // final parallel
    flow().parallel(list, function (item, i) {
      var control = this;
      queryAny(item, selector, function (err, res, wasSync) {
        if (!wasSync) isSync = false;
        if (data[i]) deepMixIn(data[i], res);else data[i] = res;
        control.done(err);
      });
    }).finally(function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-range2":352,"./util/ordered-set":314,"./util/parser":315,"./util/throttle":316,"debug":369,"finally":373,"mout/array/combine":462,"mout/array/difference":464,"mout/array/filter":467,"mout/array/map":473,"mout/lang/isArray":486,"mout/lang/isPlainObject":490,"mout/lang/isRegExp":491,"mout/object/deepMixIn":496,"mout/object/keys":502,"mout/object/pick":505,"mout/string/escapeRegExp":507,"prime":515,"prime/defer":513,"prime/emitter":514}],313:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],314:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../spotify-range2":352,"./diff":313,"mout/array/forEach":470,"prime":515}],315:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],316:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.frame = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.frame(run, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"prime/defer":513}],317:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":318}],318:[function(require,module,exports){
module.exports={
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "numeral": "es-ES",
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "numeral": "es-ES",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "numeral": "nl-nl",
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "numeral": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY"
  }
}
},{}],319:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

module.exports = function log(schema, data) {
  /*eslint-disable camelcase */
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */

  var messageDebug = debug('spotify-logger:' + qualifiedName);
  var requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v1/log',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
    messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
  });
};

},{"./schemer":321,"debug":369,"spotify-cosmos-api":554}],320:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

function schemeBody(schema, data) {
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  return body;
}

module.exports.create = function create(schema, callback) {
  var body = {
    message_name: schema.name,
    version: schema.schema_version
  };
  /*eslint-enable camelcase */
  cosmos.resolver.post({
    url: 'sp://logging/v1/create_pending_message',
    body: body
  }, function (error, response) {

    if (error) {
      callback(error, null);
      return;
    }
    var reply = response.getJSONBody();
    if (!reply.hasOwnProperty('message_id')) {
      callback(new Error('pendingLog: message_id not present', reply), null);
      return;
    }
    callback(null, reply.message_id);
  });
};

module.exports.update = function update(schema, messageId, data, callback) {
  var body = schemeBody(schema, data);
  body.message_id = messageId;
  /*eslint-enable camelcase */

  cosmos.resolver.post({
    url: 'sp://logging/v1/update_pending_message',
    body: body
  }, function (error, response) {
    if (error) return callback(error);

    callback(null);
  });
};

module.exports.send = function send(schema, messageId) {

  var body = {
    message_id: messageId,
    message_name: schema.name
  };
  // Logging cosmos endpoint requires all values to be strings.
  var qualifiedName = schema.name + schema.schema_version;
  cosmos.resolver.post({
    url: 'sp://logging/v1/send_pending_message',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
  });
};

},{"./schemer":321,"debug":369,"spotify-cosmos-api":554}],321:[function(require,module,exports){
'use strict';

var validation = require('../../avro-validator');
var debug = require('debug')(require('../package.json').name + ':');

module.exports = function (schema, data) {

  debug(schema.name);

  var name = data.message_name;
  var version = data.message_version;
  var copy = Object.assign({}, data);

  if (version !== schema.schema_version) throw new Error('' + 'Invalid message version: received Message with message_version ' + version + ' but the Schema requires version ' + schema.schema_version);

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  var fields = schema.fields.map(function (f) {
    var type = f.type;
    var value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      var firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../../avro-validator":39,"../package.json":325,"debug":369}],322:[function(require,module,exports){
'use strict';

var schema = require('../schemas/ClientEvent3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":319,"../schemas/ClientEvent3.json":327}],323:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UIInteraction4.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":319,"../schemas/UIInteraction4.json":329}],324:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UserDragAndDropInteraction1.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":319,"../schemas/UserDragAndDropInteraction1.json":330}],325:[function(require,module,exports){
module.exports={
  "name": "spotify-logger",
  "version": "1.0.0",
  "description": "Generate / consume log-parser schemas in JS",
  "bin": {
    "spotify-logger-schemas-generator": "bin/schemas-generator",
    "spotify-logger-messages-generator": "bin/messages-generator"
  },
  "main": "lib/log.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "author": "Drew Petersen <drewp@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}
},{}],326:[function(require,module,exports){
'use strict';

var schema = require('../schemas/EndVideo9.json');
var pendingLog = require('../lib/pendingLog');

module.exports = {
  schema: schema,
  create: pendingLog.create.bind(null, schema),
  update: pendingLog.update.bind(null, schema),
  send: pendingLog.send.bind(null, schema)
};

},{"../lib/pendingLog":320,"../schemas/EndVideo9.json":328}],327:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],328:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "EndVideo",
  "namespace": "com.spotify.Message",
  "doc": "Information about a video played by the client",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "sequence_number",
      "type": [
        "null",
        "long"
      ],
      "doc": "Sequence number of message",
      "default": null
    },
    {
      "name": "file_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "ID of the video manifest",
      "default": null
    },
    {
      "name": "playback_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "ID of the unique playback",
      "default": null
    },
    {
      "name": "feature_identifier",
      "type": [
        "null",
        "string"
      ],
      "doc": "The identifier of the feature that started playback",
      "default": null
    },
    {
      "name": "feature_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the feature that started playback",
      "default": null
    },
    {
      "name": "view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "The URI of the view that started playback",
      "default": null
    },
    {
      "name": "reason_start",
      "type": [
        "null",
        "string"
      ],
      "doc": "Why the video was started",
      "default": null
    },
    {
      "name": "reason_end",
      "type": [
        "null",
        "string"
      ],
      "doc": "Why the video ended (trackdone, trackerror, etc.)",
      "default": null
    },
    {
      "name": "ms_played",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total milliseconds played, including overlapping time ranges",
      "default": null
    },
    {
      "name": "ms_total_est",
      "type": [
        "null",
        "long"
      ],
      "doc": "Duration of the video in milliseconds (constant if VOD, variable if live)",
      "default": null
    },
    {
      "name": "live",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "Is the video being streamed live?",
      "default": null
    },
    {
      "name": "ms_manifest_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "The time it took to fetch the manifest in milliseconds (may be 0 if cached or prefetched)",
      "default": null
    },
    {
      "name": "n_seekback",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times user seeked backwards",
      "default": null
    },
    {
      "name": "ms_seekback",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total amount of milliseconds jumped when performing seekbacks throughout playback.",
      "default": null
    },
    {
      "name": "n_seekfwd",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times user seeked forwards",
      "default": null
    },
    {
      "name": "ms_seekfwd",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total amount of milliseconds jumped when performing seek forwards throughout playback.",
      "default": null
    },
    {
      "name": "ms_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time from initiating video playback to first frame ready to play in milliseconds",
      "default": null
    },
    {
      "name": "ui_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time from UI interaction to first frame ready to play in milliseconds (may be -1 if not user-initiated)",
      "default": null
    },
    {
      "name": "start_offset_ms",
      "type": [
        "null",
        "long"
      ],
      "doc": "The offset at which the video started playing in milliseconds",
      "default": null
    },
    {
      "name": "ms_initial_buffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time between first segment load and first frame ready to play in milliseconds",
      "default": null
    },
    {
      "name": "ms_seek_rebuffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total time spent re-buffering from a seek in milliseconds",
      "default": null
    },
    {
      "name": "ms_stalled",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total time where playback stalled in milliseconds (excluding initial buffering and seek rebuffering)",
      "default": null
    },
    {
      "name": "max_ms_seek_rebuffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum time spent re-buffering from a single seek",
      "default": null
    },
    {
      "name": "max_ms_stalled",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum time stalled from a single stall",
      "default": null
    },
    {
      "name": "n_stalls",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times playback was stopped because of empty buffer (excluding initial buffering and seek rebuffering)",
      "default": null
    },
    {
      "name": "shuffle",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "If playback was initiated while in shuffle mode",
      "default": null
    },
    {
      "name": "max_continous",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum continuous time range played in milliseconds",
      "default": null
    },
    {
      "name": "union_played",
      "type": [
        "null",
        "long"
      ],
      "doc": "Union of all played time ranges in milliseconds (cannot exceed duration)",
      "default": null
    },
    {
      "name": "play_context",
      "type": [
        "null",
        "string"
      ],
      "doc": "The context from which this track was played (spotify URI)",
      "default": null
    },
    {
      "name": "audiocodec",
      "type": [
        "null",
        "string"
      ],
      "doc": "The primarily played audio codec (in RFC6381 notation)",
      "default": null
    },
    {
      "name": "videocodec",
      "type": [
        "null",
        "string"
      ],
      "doc": "The primarily played video codec (in RFC6381 notation)",
      "default": null
    },
    {
      "name": "play_track",
      "type": [
        "null",
        "string"
      ],
      "doc": "Spotify URI for the track (ex. spotify:episode:abc)",
      "default": null
    },
    {
      "name": "incognito_mode",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "Whether playback was initiated in incognito mode",
      "default": null
    },
    {
      "name": "provider",
      "type": [
        "null",
        "string"
      ],
      "doc": "The playback rule that provided the video, e.g., \"mft/inject_random_track\" or \"queue\"",
      "default": null
    },
    {
      "name": "referrer",
      "type": [
        "null",
        "string"
      ],
      "doc": "Either a remote site or a spotify app which initiated the request",
      "default": null
    },
    {
      "name": "referrer_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the referrer, where applicable",
      "default": null
    },
    {
      "name": "referrer_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The vendor of the referrer, where applicable",
      "default": null
    },
    {
      "name": "streaming_rule",
      "type": [
        "null",
        "string"
      ],
      "doc": "The streaming rule in effect for this track",
      "default": null
    },
    {
      "name": "gaia_dev_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Remote control that started the playback. Same as \"dev-id\" in \"Gaia\" messages sent by that device. \"none\" if non-Gaia playback.",
      "default": null
    },
    {
      "name": "start_bitrate",
      "type": [
        "null",
        "long"
      ],
      "doc": "Bitrate at which playback started (bits/s)",
      "default": null
    },
    {
      "name": "full_screen",
      "type": [
        "null",
        "long"
      ],
      "doc": "Milliseconds played while video is in a modal or fullscreen state",
      "default": null
    },
    {
      "name": "time_weighted_bitrate",
      "type": [
        "null",
        "long"
      ],
      "doc": "Average bitrate weighted by the amount of time video played at each bitrate",
      "default": null
    },
    {
      "name": "prefetched_bytes",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total number of bytes prefetched for the selected content",
      "default": null
    },
    {
      "name": "prefetched_bytes_loaded",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total number of prefetched bytes played back",
      "default": null
    },
    {
      "name": "key_system",
      "type": [
        "null",
        "string"
      ],
      "doc": "The DRM key system",
      "default": null
    },
    {
      "name": "ms_key_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "The time it took to fetch and install the DRM key in milliseconds.",
      "default": null
    },
    {
      "name": "total_bytes",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total segment bytes downloaded",
      "default": null
    },
    {
      "name": "local_time_ms",
      "type": [
        "null",
        "long"
      ],
      "doc": "The local time at which playback was initiated (Unix timestamp in milliseconds)",
      "default": null
    },
    {
      "name": "connection_type_start",
      "type": [
        "null",
        "string"
      ],
      "doc": "connection type (i.e. wifi, 3G) at the start of the stream",
      "default": null
    },
    {
      "name": "connection_type_end",
      "type": [
        "null",
        "string"
      ],
      "doc": "connection type (i.e. wifi, 3G) at the end of the stream",
      "default": null
    },
    {
      "name": "ms_played_background",
      "type": [
        "null",
        "long"
      ],
      "doc": "Milliseconds played in background (audio-only). Always subset of ms-played.",
      "default": null
    }
  ],
  "schema_version": 9
}

},{}],329:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the feature page (e.g., Music, Start Page, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "block_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of block on page",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 4
}
},{}],330:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist-desktop\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],331:[function(require,module,exports){
'use strict';

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */

function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI()
  });
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

module.exports = AppState;

},{}],332:[function(require,module,exports){
'use strict';

module.exports = {
  AppState: require('./app-state'),
  Navigator: require('./navigator')
};

},{"./app-state":331,"./navigator":333}],333:[function(require,module,exports){
(function (global){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var AppState = require('./app-state');
var _global = global.top || global;

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of known events.
 */
Navigator.EVENTS = {
  OPEN_STATE: 'navigation_open_state'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  var name = message.data.type;
  if (name === Navigator.EVENTS.OPEN_STATE) {
    var appState = AppState.unserialize(message.data.state);
    this.emitSync(name, { state: appState });
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  _global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  _global.removeEventListener('message', this._messageHandler);
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state) {
  _global.postMessage({
    type: Navigator.EVENTS.OPEN_STATE,
    state: state.serialize()
  }, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":331,"spotify-eventemitter":559,"spotify-inheritance/inherit":562}],334:[function(require,module,exports){
'use strict';

module.exports = function (numeral) {
  return {
    delimiters: {
      thousands: ',',
      decimal: '.'
    },
    abbreviations: {
      thousand: 'k',
      million: 'm',
      billion: 'b',
      trillion: 't'
    },
    ordinal: function ordinal(number) {
      var b = number % 10;
      return ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
      symbol: '$'
    }
  };
};

},{}],335:[function(require,module,exports){
'use strict';

var numeral = require('./numeraljs/numeral');
var locales = require('../spotify-locales');

module.exports = function (currentLanguage) {

  // We need to explicitly require all languages listed in spotify-locales
  // so that Quickstart can access them at runtime
  // (dynamic paths can't be cached).
  var languages = {
    'de': require('./numeraljs/languages/de'),
    // Custom en.js file
    'en': require('./en')(numeral),
    // es-419 falls back to es-es in Numeral.js
    'es-ES': require('./numeraljs/languages/es-ES'),
    'fi': require('./numeraljs/languages/fi'),
    'fr': require('./numeraljs/languages/fr'),
    'fr-CA': require('./numeraljs/languages/fr-CA'),
    'hu': require('./numeraljs/languages/hu'),
    'id': require('./numeraljs/languages/id'),
    'it': require('./numeraljs/languages/it'),
    'ja': require('./numeraljs/languages/ja'),
    'nl-nl': require('./numeraljs/languages/nl-nl'),
    'pl': require('./numeraljs/languages/pl'),
    'pt-br': require('./numeraljs/languages/pt-br'),
    'sv': require('./numeraljs/languages/sv'),
    'tr': require('./numeraljs/languages/tr')
  };

  var numeralLocale = locales(currentLanguage, 'numeral');
  if (!languages[numeralLocale]) {
    numeralLocale = 'en';
  }
  numeral.language(numeralLocale, languages[numeralLocale]);
  numeral.language(numeralLocale);

  return numeral;
};

},{"../spotify-locales":317,"./en":334,"./numeraljs/languages/de":336,"./numeraljs/languages/es-ES":337,"./numeraljs/languages/fi":338,"./numeraljs/languages/fr":340,"./numeraljs/languages/fr-CA":339,"./numeraljs/languages/hu":341,"./numeraljs/languages/id":342,"./numeraljs/languages/it":343,"./numeraljs/languages/ja":344,"./numeraljs/languages/nl-nl":345,"./numeraljs/languages/pl":346,"./numeraljs/languages/pt-br":347,"./numeraljs/languages/sv":348,"./numeraljs/languages/tr":349,"./numeraljs/numeral":350}],336:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : German (de) – generally useful in Germany, Austria, Luxembourg, Belgium
 * author : Marco Krage : https://github.com/sinky
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],337:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : spanish Spain
 * author : Hernan Garcia : https://github.com/hgarcia
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],338:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Finnish
 * author : Sami Saada : https://github.com/samitheberber
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],339:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (Canada) (fr-CA)
 * author : Léo Renaud-Allaire : https://github.com/renaudleo
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],340:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (fr)
 * author : Adam Draper : https://github.com/adamwdraper
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],341:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Hungarian (hu)
 * author : Peter Bakondy : https://github.com/pbakondy
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'E', // ezer
            million: 'M', // millió
            billion: 'Mrd', // milliárd
            trillion: 'T' // trillió
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: ' Ft'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],342:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Indonesian (id)
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'ribu',
            million: 'juta',
            billion: 'miliar',
            trillion: 'triliun'
        },
        ordinal: function ordinal(number) {
            // According to Spotify's internal Indonesian specialist,
            // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
            // they just use the word (equivalent to writing: first, second,
            // third, instead of 1st, 2nd, 3rd). And as we don't have such
            // capability to translate all numbers to words, this function
            // returns an empty string and wherever there's a ordinal, it will
            // just show up as the cardinal number.
            return '';
        },
        currency: {
            symbol: 'Rp'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],343:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : italian Italy (it)
 * author : Giacomo Trombi : http://cinquepunti.it
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mila',
            million: 'mil',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],344:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : japanese
 * author : teppeis : https://github.com/teppeis
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: '千',
            million: '百万',
            billion: '十億',
            trillion: '兆'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '¥'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],345:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : netherlands-dutch (nl-nl)
 * author : Dave Clayton : https://github.com/davedx
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mln',
            billion: 'mrd',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            var remainder = number % 100;
            return number !== 0 && remainder <= 1 || remainder === 8 || remainder >= 20 ? 'ste' : 'de';
        },
        currency: {
            symbol: '€ '
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],346:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : polish (pl)
 * author : Dominik Bulaj : https://github.com/dominikbulaj
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'tys.',
            million: 'mln',
            billion: 'mld',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'PLN'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],347:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : portuguese brazil (pt-br)
 * author : Ramiro Varandas Jr : https://github.com/ramirovjr
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mil',
            million: 'milhões',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: 'R$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],348:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : swedish
 * author :
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 't',
            million: 'mn',
            billion: 'md',
            trillion: 'bn'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'SEK'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],349:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : turkish (tr)
 * author : Ecmel Ercan : https://github.com/ecmel, Erhan Gundogan : https://github.com/erhangundogan, Burak Yiğit Kaya: https://github.com/BYK
 */
(function () {
    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',

        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',

        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',

        6: '\'ncı',

        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',

        60: '\'ıncı',
        90: '\'ıncı'
    },
        language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'bin',
            million: 'milyon',
            billion: 'milyar',
            trillion: 'trilyon'
        },
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return '\'ıncı';
            }

            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;

            return suffixes[a] || suffixes[b] || suffixes[c];
        },
        currency: {
            symbol: '₺'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],350:[function(require,module,exports){
'use strict';

/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var _numeral,
        VERSION = '1.5.3',

    // internal storage for language config files
    languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',

    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports;

    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral(n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(n, format);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral(n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = string.indexOf(suffixes[power]) > -1 ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency(n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage(n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime(n) {
        var hours = Math.floor(n._value / 60 / 60),
            minutes = Math.floor((n._value - hours * 60 * 60) / 60),
            seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }

    function unformatTime(string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + Number(timeArray[0]) * 60 * 60;
            // minutes
            seconds = seconds + Number(timeArray[1]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + Number(timeArray[0]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber(value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false,
            // force abbreviation to thousands
        abbrM = false,
            // force abbreviation to millions
        abbrB = false,
            // force abbreviation to billions
        abbrT = false,
            // force abbreviation to trillions
        abbrForce = false,
            // force abbreviation
        bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power + 1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return (negP && neg ? '(' : '') + (!negP && neg ? '-' : '') + (!neg && signed ? '+' : '') + w + d + (ord ? ord : '') + (abbr ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    _numeral = function numeral(input) {
        if (_numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = _numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    _numeral.version = VERSION;

    // compare numeral object
    _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    _numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return _numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    _numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    _numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    _numeral.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };

    _numeral.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
            return mp > mn ? mp : mn;
        }, -Infinity);
    }

    /************************************
        Numeral Prototype
    ************************************/

    _numeral.fn = Numeral.prototype = {

        clone: function clone() {
            return _numeral(this);
        },

        format: function format(inputString, roundingFunction) {
            return formatNumeral(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);
        },

        unformat: function unformat(inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value: function value() {
            return this._value;
        },

        valueOf: function valueOf() {
            return this._value;
        },

        set: function set(value) {
            this._value = Number(value);
            return this;
        },

        add: function add(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract: function subtract(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply: function multiply(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide: function divide(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference: function difference(value) {
            return Math.abs(_numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    module.exports = _numeral;
}).call(undefined);

},{}],351:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var extend = require('extend'),
    bridge = require('../spotify-bridge-request'),
    batch = require('spotify-batch');

/**
 * Bridge methods
 */

var PREF_ALL = 'preferences_all';
var PREF_GET = 'preferences_get';
var PREF_SET = 'preferences_set';
var PREF_SUB = 'preferences_event_wait';

/**
 * Converts a string with dot notation into
 * a nested object where the last key is
 * set to value
 *
 *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
 *
 * @api private
 * @param {String} string
 * @param {Mixed} value
 * @param {String} delimiter - optional
 */

function TransformStringIntoObjectAndSetValue(string, value, delimiter) {
  var object = {};
  string.split(delimiter || '.').reduce(function (o, c, i, a) {
    if (i < a.length - 1) {
      o[c] = {};
    } else {
      o[c] = value;
    }

    return o[c];
  }, object);

  return object;
}

/**
 * Converts an object with nest objects into a flat object
 *
 *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
 *
 * @api private
 * @param {String} string
 * @param {String} delimiter - optional
 */

function TransformObjectIntoFlatObject(object, delimiter) {
  var flattened = {};
  delimiter = delimiter || '.';
  function traverse(o, key) {
    var tmp = null;
    for (var p in o) {
      if ('object' == _typeof(o[p])) {
        key = key ? [key, p].join(delimiter) : p;
        traverse(o[p], key);
      } else {
        tmp = key ? [key, p].join(delimiter) : p;
        flattened[tmp] = o[p];
      }
    }
  }

  traverse(object);
  return flattened;
}

/**
 * Normalizes data from bridge responses
 *
 * @api private
 * @param {String} key
 * @param {Object} data
 * @param {Boolean} preserve - optional (Default: false)
 */

function NormalizeData(key, data, preserve) {
  var out = {};
  var regex = '*' == key ? null : RegExp('^' + key);
  var targets = null;

  if ('object' != (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
    return data;
  }

  targets = Object.keys(data).map(function (key) {
    if (null == regex || regex.test(key)) {
      return [key, data[key]];
    }
  }).filter(Boolean).reduce(function (t, c) {
    t[c[0]] = c[1];
    return t;
  }, {});

  Object.keys(targets).forEach(function (key) {
    // extend output object with transformed properties
    extend(true, out, TransformStringIntoObjectAndSetValue(key, targets[key]));
  });

  if ('*' == key || true === preserve) {
    return out;
  } else {
    return key.split('.').reduce(function (o, k) {
      return o[k];
    }, out);
  }
}

/**
 * Subscribes to a key.
 *
 * @api private
 * @param {Function} rpc The RPC to use.
 * @param {String} key The key (including path).
 * @param {*} lastValue The last value of the key (used for comparing).
 * @param {Function} fn Subscribe handler.
 * @param {Object=} sub Subscription object, optional.
 */

function SubscribeToKey(rpc, key, lastValue, fn, sub) {
  sub = sub || {
    isCancelled: false,
    cancel: function cancel() {
      this.isCancelled = true;
    }
  };

  rpc(PREF_SUB, [], function (err, res) {
    if (sub.isCancelled) return;

    var didValueChange = false;

    if (res) {
      var value = NormalizeData(key, res);
      if (value !== lastValue) {
        lastValue = value;
        didValueChange = true;
      }
    }

    // Resubscribe since one subscription is only for one response
    SubscribeToKey(rpc, key, lastValue, fn, sub);

    if (didValueChange) {
      fn(null, lastValue);
    }
  });

  return sub;
}

/**
 * `Preferences' constructor
 *
 * @api public
 * @param {String} path - optional (Default: '*')
 * @param {Function} rpc - optional
 */

module.exports = Preferences;
function Preferences(path, rpc) {
  if (!(this instanceof Preferences)) {
    return new Preferences(path, rpc);
  }

  this.path = path || '*';
  this.rpc = rpc || bridge.request.bind(bridge);
}

/**
 * Retrieves all preferences at path.
 * If path is '*' then all preferences
 * are retrieved.
 *
 * @api public
 * @param {Function} fn
 */

Preferences.prototype.all = function (fn) {
  var self = this;
  var path = this.path;

  this.rpc(PREF_ALL, [], function (err, res) {
    if (err) {
      return fn(err);
    } else if ('*' == path) {
      fn(null, res);
    } else {
      fn(null, NormalizeData(path, res, true));
    }
  });

  return this;
};

/**
 * Sets a preference at key at path
 * with value
 *
 * @api public
 * @param {String} key
 * @param {Mixed} value
 * @param {Function} fn
 */

Preferences.prototype.set = function (key, value, fn) {
  var self = this;
  var path = this.path;
  var tmp = null;
  var map = null;
  var jobs = null;

  // handle batch jobs to extend bridge preferences
  if ('object' == (typeof key === 'undefined' ? 'undefined' : _typeof(key))) {
    fn = value;

    map = TransformObjectIntoFlatObject(key);
    jobs = batch().concurrency(1);
    Object.keys(map).forEach(function (k) {
      jobs.push(function (next) {
        self.set(k, map[k], next);
      });
    });

    jobs.run(fn);
  } else {
    key = '*' == path ? key : [path, key].join('.');
    this.rpc(PREF_SET, [key, value], fn);
  }
  return this;
};

/**
 * Sets a preference bitflag at path, based on the inputs.
 *
 * @api public
 * @param {String} key
 * @param {Array} flagBoolPairs
 * @param {Function} fn
 */

Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
  var self = this;

  self.get(key, function (err, value) {
    if (err) return fn(err);

    flagBoolPairs.forEach(function (pair) {
      var flag = pair[0];
      var bool = pair[1];
      if (bool === undefined || bool === null) return;
      if (bool) value |= flag;else value &= ~flag;
    });

    self.set(key, value, fn);
  });
};

/**
 * Gets a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.get = function (key, fn) {
  var self = this;
  key = '*' == this.path ? key : [this.path, key].join('.');

  // try to get property first
  this.rpc(PREF_GET, [key], function (err, res) {
    var value = res ? NormalizeData(key, res) : null;
    if (null == value) {
      self.rpc(PREF_ALL, [], function (err, res) {
        if (err) {
          return fn(err);
        } else {
          fn(null, NormalizeData(key, res));
        }
      });
    } else {
      fn(null, NormalizeData(key, res));
    }
  });
  return this;
};

/**
 * Subscribes to a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.subscribe = function (key, fn) {
  var self = this;
  var sub = null;
  var cancelled = false;

  // Get initial value and then subscribe for changes
  this.get(key, function (err, res) {
    if (cancelled) return;
    var keyWithPath = '*' == self.path ? key : [self.path, key].join('.');
    sub = SubscribeToKey(self.rpc, keyWithPath, res, fn);

    // Respond to the GET (initial value for SUB)
    fn(err, res);
  });

  return {
    cancel: function cancel() {
      cancelled = true;
      if (sub) {
        sub.cancel();
      }
    }
  };
};

},{"../spotify-bridge-request":134,"extend":372,"spotify-batch":548}],352:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
        ranges.splice(k, 1, next.copy());
      }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
          ranges.splice(k, 1, newRange);
        }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            ranges.splice(k + 1, 0, between);
          }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":473,"prime":515}],353:[function(require,module,exports){
'use strict';

function Translations() {
  this._data = {};

  // ensure that the context of the get method is always this object
  this.get = this.get.bind(this);
}

/**
 * Default implementation if the
 * locale is not loaded
 */
Translations.prototype.injectData = function (data) {
  this._data = data;
};

/**
 * Get a translation
 */
Translations.prototype.get = function (key, var_args) {
  var format = this._data.hasOwnProperty(key) ? this._data[key] : key;
  var args = arguments;

  return format.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = args[+num + 1];

    // Do not change by a ||. A value of an empty string would make it fail.
    return typeof value !== 'undefined' ? value : str;
  });
};

/**
 * Gets the raw translations data
 * @return {Object} Locale object
 */
Translations.prototype.getData = function () {
  return this._data;
};

/**
 * Creates a translations instance with the specified data
 *
 * @param {Object} data Translations object
 * @return {Translations}
 */
Translations.createWithData = function (data) {
  var translations = new Translations();
  translations.injectData(data);
  return translations;
};

module.exports = Translations;

},{}],354:[function(require,module,exports){
'use strict';

module.exports = require('./src/SPVideoManager');

},{"./src/SPVideoManager":357}],355:[function(require,module,exports){
/**
 * Copyright 2014 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @fileoverview Implements a manager for adaptive bitrate streaming.
 */
'use strict';

var shaka = require('./shaka');
/**
 * Creates a SPAbrManager, which selects video tracks using a basic set of
 * heuristics.
 *
 * @struct
 * @constructor
 * @implements {shaka.media.IAbrManager}
 * @export
 */
var SPAbrManager = function SPAbrManager(player) {
  /** @private {shaka.util.IBandwidthEstimator} */
  this.estimator_ = null;

  /** @private {shaka.player.IVideoSource} */
  this.videoSource_ = null;

  /** @private {!shaka.util.EventManager} */

  this.player_ = player;
  /**
   * The timestamp after which we are allowed to adapt, in milliseconds.
   * @private {number}
   */
  this.nextAdaptationTime_ = Number.POSITIVE_INFINITY;

  /** @private {boolean} */
  this.enabled_ = true;
};

/**
 * The minimum amount of time that must pass before the first switch, in
 * milliseconds.  This gives the bandwidth estimator time to get some real
 * data before changing anything.
 *
 * @private
 * @const {number}
 */
SPAbrManager.FIRST_SWITCH_INTERVAL_ = 4000;

/**
 * The minimum amount of time that must pass between switches, in milliseconds.
 * This keeps us from changing too often and annoying the user.
 *
 * @private
 * @const {number}
 */
SPAbrManager.MIN_SWITCH_INTERVAL_ = 30000;

/**
 * The minimum amount of time that must pass between bandwidth evaluations, in
 * milliseconds.  This keeps us from checking for adaptation opportunities too
 * often.
 *
 * @private
 * @const {number}
 */
SPAbrManager.MIN_EVAL_INTERVAL_ = 3000;

/**
 * The fraction of the estimated bandwidth which we should try to use when
 * upgrading.
 *
 * @private
 * @const {number}
 */
SPAbrManager.BANDWIDTH_UPGRADE_TARGET_ = 0.85;

/**
 * The fraction of the estimated bandwidth we should downgrade to avoid
 * exceeding.
 *
 * @private
 * @const {number}
 */
SPAbrManager.BANDWIDTH_DOWNGRADE_TARGET_ = 0.95;

/**
 * @override
 * @suppress {checkTypes} to set otherwise non-nullable types to null.
 */
SPAbrManager.prototype.destroy = function () {
  this.estimator_ = null;
  this.videoSource_ = null;
};

/** @override */
SPAbrManager.prototype.initialize = function (estimator, videoSource) {
  if (this.estimator_ || this.videoSource_) {
    return;
  }
  this.estimator_ = estimator;
  this.videoSource_ = videoSource;
};

/** @override */
SPAbrManager.prototype.start = function () {
  if (!this.estimator_ || !this.videoSource_ || this.started_) {
    return;
  }

  this.nextAdaptationTime_ = Date.now() + SPAbrManager.FIRST_SWITCH_INTERVAL_;
  this.player_.addEventListener('adaptation', this.onAdaptation_.bind(this));
  this.estimator_.addEventListener('bandwidth', this.onBandwidth_.bind(this));
  this.player_.addEventListener('trackschanged', this.chooseNewTrack_.bind(this));

  this.started_ = true;
};

/** @override */
SPAbrManager.prototype.enable = function (enabled) {
  this.enabled_ = enabled;
};

/** @override */
SPAbrManager.prototype.getInitialVideoTrackId = function () {
  if (!this.estimator_ || !this.videoSource_) {
    return null;
  }

  var chosen = this.chooseVideoTrack_();
  return chosen ? chosen.id : null;
};

/**
 * Select the specified video track.
 *
 * Does nothing if the AbrManager has not been started.
 *
 * @param {shaka.player.VideoTrack} track the track to the switch to
 * @param {boolean} clearBuffer If true, removes the previous stream's content
 *     before switching to the new stream.
 * @param {number=} opt_clearBufferOffset if |clearBuffer| and
 *     |opt_clearBufferOffset| are truthy, clear the stream buffer from the
 *     given offset (relative to the video's current time) to the end of the
 *     stream.
 *
 * @protected
 * @expose
 */
SPAbrManager.prototype.selectVideoTrack = function (track, clearBuffer, optClearBufferOffset) {
  if (!this.started_) {
    return;
  }
  this.videoSource_.selectVideoTrack(track.id, clearBuffer, optClearBufferOffset);
};

/**
 * Find the active track in the list.
 *
 * @param {!Array.<T>} trackList
 * @return {T}
 *
 * @template T
 * @private
 */
SPAbrManager.findActiveTrack_ = function (trackList) {
  for (var i = 0; i < trackList.length; ++i) {
    if (trackList[i].active) {
      return trackList[i];
    }
  }

  return null;
};

/**
 * Handles bandwidth update events.
 *
 * @param {!Event} event
 * @private
 */
SPAbrManager.prototype.onBandwidth_ = function (event) {
  if (Date.now() < this.nextAdaptationTime_) {
    return;
  }

  this.chooseNewTrack_(event);
};

/**
 * Makes adaptation decisions.
 *
 * @param {!Event} event
 * @private
 */
SPAbrManager.prototype.chooseNewTrack_ = function (event) {
  if (event.type !== 'bandwidth') {
    return;
  }
  if (!this.enabled_) {
    return;
  }

  // Alias.
  var SimpleAbrManager = SPAbrManager;

  var chosen = this.chooseVideoTrack_();

  if (chosen) {
    if (chosen.active) {
      // We are already using the correct video track.
      this.nextAdaptationTime_ = Date.now() + SimpleAbrManager.MIN_EVAL_INTERVAL_;
      return;
    }

    this.selectVideoTrack(chosen, true, 2.0);
  }

  // Can't adapt again until we get confirmation of this one.
  this.nextAdaptationTime_ = Number.POSITIVE_INFINITY;
};

/**
 * Handles adaptation events.
 *
 * @param {!Event} event
 * @private
 */
SPAbrManager.prototype.onAdaptation_ = function () {
  // This check allows us to ignore the initial adaptation events, which would
  // otherwise cause us not to honor FIRST_SWITCH_INTERVAL_.
  if (this.nextAdaptationTime_ === Number.POSITIVE_INFINITY) {
    // Adaptation is complete, so schedule the next adaptation.
    this.nextAdaptationTime_ = Date.now() + SPAbrManager.MIN_SWITCH_INTERVAL_;
  }
};

/**
 * Choose a video track based on current bandwidth conditions.
 *
 * @return {shaka.player.VideoTrack} The chosen video track or null if there
 *     are no video tracks to choose.
 * @private
 */
SPAbrManager.prototype.chooseVideoTrack_ = function () {
  // Alias.
  var SimpleAbrManager = SPAbrManager;

  var videoTracks = this.videoSource_.getVideoTracks();
  if (videoTracks.length === 0) {
    return null;
  }

  videoTracks.sort(shaka.player.VideoTrack.compare);

  var activeAudioTrack = SimpleAbrManager.findActiveTrack_(this.videoSource_.getAudioTracks());
  var audioBandwidth = activeAudioTrack ? activeAudioTrack.bandwidth : 0;

  var bandwidth = this.estimator_.getBandwidth();

  // Start by assuming that we will use the first track.
  var chosen = videoTracks[0];

  for (var i = 0; i < videoTracks.length; ++i) {
    var track = videoTracks[i];
    var nextTrack = i + 1 < videoTracks.length ? videoTracks[i + 1] : { bandwidth: Number.POSITIVE_INFINITY };

    // Ignore any track which is missing bandwidth info.
    if (!track.bandwidth) continue;

    var minBandwidth = (track.bandwidth + audioBandwidth) / SimpleAbrManager.BANDWIDTH_DOWNGRADE_TARGET_;
    var maxBandwidth = (nextTrack.bandwidth + audioBandwidth) / SimpleAbrManager.BANDWIDTH_UPGRADE_TARGET_;
    /*
     * console.log('Bandwidth ranges:',
     *             ((track.bandwidth + audioBandwidth) / 1e6).toFixed(3),
     *           (minBandwidth / 1e6).toFixed(3),
     *             (maxBandwidth / 1e6).toFixed(3));
     */

    if (bandwidth >= minBandwidth && bandwidth <= maxBandwidth) {
      chosen = track;
      if (chosen.active) break;
    }
  }

  return chosen;
};

module.exports = SPAbrManager;

},{"./shaka":361}],356:[function(require,module,exports){
/**
 * @license
 * Copyright 2015 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var shaka = require('./shaka');
var EWMA = require('./ewma');
var util = require('util');

/**
 * Tracks bandwidth samples and estimates available bandwidth.
 * Based on the minimum of two exponentially-weighted moving averages with
 * different half-lives.
 *
 * @struct
 * @constructor
 * @extends {shaka.util.FakeEventTarget}
 * @implements {shaka.util.IBandwidthEstimator}
 * @export
 */
var SPBandwidthEstimator = function SPBandwidthEstimator() {
  shaka.util.FakeEventTarget.call(this, null);
  /**
   * A fast-moving average.
   * Half of the estimate is based on the last 3 seconds of sample history.
   * @private {!shaka.util.EWMA}
   */
  this.fast_ = new EWMA(3);

  /**
   * A slow-moving average.
   * Half of the estimate is based on the last 10 seconds of sample history.
   * @private {!shaka.util.EWMA}
   */
  this.slow_ = new EWMA(10);

  /**
   * Prevents ultra-fast internal connections from causing crazy results.
   * Modified by Betamax@Spotify Aparently this gets even crazier on Really
   * fast networks and the bandwidth calculation kicks in way to late
   * @private {number}
   * @const
   */
  this.minDelayMs_ = 80;

  /**
   * Initial estimate used when there is not enough data.
   * Modified by Betamax@Spotify to supply a start bitrate of 1Mbps
   * @private {number}
   * @const
   */
  this.defaultEstimate_ = 1e6; // 1Mbps

  /**
   * Minimum weight required to trust the estimate.
   * Modified by Betamax@Spotify let the calculation be used even earlier
   * @private {number}
   * @const
   */
  this.minWeight_ = 0.3;

  /**
   * Minimum number of bytes, under which samples are discarded.
   * Modified by Betamax@Spotify to let the minium packet size used
   * be less than our smallest
   * @private {number}
   * @const
   */

  this.minBytes_ = 50000;

  /**
   * The last time a sample was recorded, in milliseconds.
   * @private {number}
   */
  this.lastSampleTime_ = 0;
};

util.inherits(SPBandwidthEstimator, shaka.util.FakeEventTarget);

/** @override */
SPBandwidthEstimator.prototype.sample = function (delayMs, bytes) {
  if (bytes < this.minBytes_) {
    return;
  }

  delayMs = Math.max(delayMs, this.minDelayMs_);

  var bandwidth = 8000 * bytes / delayMs;
  var weight = delayMs / 1000;

  this.fast_.sample(weight, bandwidth);
  this.slow_.sample(weight, bandwidth);

  this.dispatchEvent(new Event('bandwidth'));

  this.lastSampleTime_ = Date.now();
};

/** @override */
SPBandwidthEstimator.prototype.getBandwidth = function () {
  if (this.fast_.getTotalWeight() < this.minWeight_) {
    return this.defaultEstimate_;
  }

  // Take the minimum of these two estimates.  This should have the effect of
  // adapting down quickly, but up more slowly.
  return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
};

/** @override */
SPBandwidthEstimator.prototype.getDataAge = function () {
  return (Date.now() - this.lastSampleTime_) / 1000;
};

/** @override */
SPBandwidthEstimator.prototype.supportsCaching = function () {
  return false;
};

module.exports = SPBandwidthEstimator;

},{"./ewma":360,"./shaka":361,"util":586}],357:[function(require,module,exports){
'use strict';

var UUID = require('uuid-js');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var _ = require('./utils');
var SPVideoPlayer = require('./SPVideoPlayer');
var SPBandwidthEstimator = require('./SPBandwidthEstimator');
var SPVideoPlayerTracker = require('./SPVideoPlayerTracker');

var bandwidthEstimator;
var SPVideoManager, activeId;
var videos = {};

// CONSTANTS
var CHANGE_EVENT = 'change';

function getVideo(id) {
  var vid = null;
  if (typeof id === 'undefined') {
    vid = videos[activeId];
  } else {
    vid = videos[id];
  }

  console.assert(vid, 'Video unavailable ', vid);
  return vid;
}

function generateId() {
  var uuid = UUID.create();
  return uuid.toString();
}

var _state = {
  'isPlaying': false,
  'activeVideo': null,
  'activeVideoState': {},
  'volume': 1
};

var _onChange = function _onChange(err, p, c) {
  SPVideoManager.set({
    'activeVideoState': c
  });
};

/**
 * @module SPVideoManager
 */
SPVideoManager = {

  /**
   * @param {String} [key]
   * @return {*} - value at key or shallow clone of state
   */
  get: function get(key) {
    return arguments.length ? _state[key] : _.clone(_state);
  },

  /**
   * @param {String|Object} key - key or hash of key:value pairs to be updated
   * @param {*} [val]
   * @param {Boolean} [silent] - if true then no change event is fired
   * @return {SPVideoPlayer} this
   */
  set: function set(key, val, silent) {
    var oldState = this.get();

    if (arguments.length < 3 && util.isObject(key)) {
      silent = val;
      _.extend(_state, key);
    } else {
      _state[key] = val;
    }

    if (!silent) {
      this.emitter.emit(CHANGE_EVENT, null, oldState, this.get());
    }

    return this;
  },

  /**
   * @param {HTMLVideoElement} node
   * @param {Object} config
   * @return {String} videoId
   */
  createVideo: function createVideo(node, config) {
    var videoId = generateId();
    if (!bandwidthEstimator || bandwidthEstimator.getDataAge() >= 3600) {
      bandwidthEstimator = new SPBandwidthEstimator();
    }
    config.bandwidthEstimator = bandwidthEstimator;
    videos[videoId] = new SPVideoPlayer(node, config);
    return videoId;
  },

  getActiveVideo: function getActiveVideo() {
    return videos[activeId];
  },

  getVideo: function getVideo(videoId) {
    return videos[videoId];
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  play: function play(videoId) {
    getVideo(videoId).play();
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  pause: function pause(videoId) {
    getVideo(videoId).pause();
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Number} [timeInSeconds]
   * @return {SPVideoManager}
   */
  seekTo: function seekTo(videoId, timeInSeconds) {
    getVideo(videoId).seekTo(timeInSeconds);
    return SPVideoManager;
  },

  /**
   * @param {Number} n
   * @return {SPVideoManager}
   */
  setPlayerVolume: function setPlayerVolume(videoId, volume) {
    if (videoId === activeId) {
      SPVideoManager.setVolume(volume);
    } else {
      getVideo(videoId).setVolume(volume);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} n
   * @return {SPVideoManager}
   */
  setVolume: function setVolume(n) {
    this.set('volume', n);

    // Apply to active video
    if (getVideo()) {
      getVideo().setVolume(n);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  destroy: function destroy(videoId, destroyNode, reason) {
    if (videoId) {
      var video = getVideo(videoId);
      if (video) {
        if (!!destroyNode) {
          video.getNode().remove();
        }
        video.unload(reason);
        delete videos[videoId];
      }
    }

    return SPVideoManager;
  },

  /**
   * @param {String} videoId
   * @return {SPVideoManager}
   */
  setActiveVideo: function setActiveVideo(videoId) {
    activeId = videoId;

    for (var v in videos) {
      if (!videos.hasOwnProperty(v)) continue;

      videos[v].set({
        'isActive': false,
        'endReason': getVideo(videoId).get('startReason')
      });
    }

    getVideo(videoId).setVolume(this.get('volume')).unmute().set({
      'isActive': true
    }).subscribe(_onChange);

    // Notify listeners that video is playing
    this.set({
      'isPlaying': true,
      'activeVideo': activeId,
      'activeVideoState': getVideo(videoId).get()
    });

    return SPVideoManager;
  },

  /**
   * @return {SPVideoManager}
   */
  clearActiveVideo: function clearActiveVideo() {
    getVideo().unsubscribe(_onChange).mute().set({
      'isActive': false
    });

    // Notify listeners that video is not playing
    this.set({
      'isPlaying': false,
      'activeVideo': null,
      'activeVideoState': {}
    });

    activeId = null;

    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Function} cb
   * @return {SPVideoManager}
   */
  subscribe: function subscribe(videoId, cb) {
    if (videoId) {
      getVideo(videoId).addListener(CHANGE_EVENT, cb);
    } else {
      // Sub to the active video
      this.emitter.addListener('change', cb);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Function} [cb]
   * @return {SPVideoManager}
   */
  unsubscribe: function unsubscribe(videoId, cb) {
    if (videoId) {
      getVideo(videoId).removeListener(CHANGE_EVENT, cb);
    } else {
      // Unsub from active video
      this.emitter.removeListener('change', cb);
    }
    return SPVideoManager;
  },

  createEndVideoTracker: function createEndVideoTracker(player, options) {
    return new SPVideoPlayerTracker(player, options);
  },

  emitter: new EventEmitter()
};

module.exports = SPVideoManager;

},{"./SPBandwidthEstimator":356,"./SPVideoPlayer":358,"./SPVideoPlayerTracker":359,"./utils":362,"events":371,"util":586,"uuid-js":587}],358:[function(require,module,exports){
(function (global){
'use strict';
/**
 * @external EventEmitter
 * @see {@link https://nodejs.org/api/events.html|EventEmitter}
 */

var EventEmitter = require('events').EventEmitter;
var util = require('util');
var shaka = require('./shaka');
var _ = require('./utils');
var SPAbrManager = require('./SPAbrManager');

// CONSTANTS
var CHANGE_EVENT = 'change';
var BUFFERING_INTERVAL = 500;
var UPDATE_INTERVAL = 15000;
var PRODUCT_STATE_WIDEVINE_LICENSE_URL = 'widevine-license-url';

function isDashyURL(url) {
  return (/(\.mpd$)|(\/dash\/)/.test(url)
  );
}

function optionsFromConfig(config) {
  return !config ? {} : {
    'url': config.url || null,
    'type': config.type || null,
    'isDash': config.type === 'dash' || isDashyURL(config.url),
    'volume': config.volume || 1,
    'startPaused': config.startPaused || false,
    'isAd': config.isAd || false,
    'nativeControls': config.nativeControls || false,
    'preseekPosition': config.position || 0,
    'networkCallback': config.networkCallback,
    'bandwidthEstimator': config.bandwidthEstimator,
    'playbackID': config.playbackID,
    'fileId': config.fileId || null,
    'playOrigin': config.playOrigin || {},
    'track_uri': config.track_uri || '',
    'provider': config.provider || '',
    'startReason': config.startReason || 'unknown',
    'play_context': config.play_context || ''
  };
}

/**
 * @class SPVideoPlayer
 * @extends external:EventEmitter
 * @param {HTMLVideoElement} node
 * @param {Object} config
 */
var SPVideoPlayer = function SPVideoPlayer(node, config) {
  EventEmitter.call(this);
  this._options = optionsFromConfig(config);

  // set up video node
  _.bindAll(this);
  this._node = node;
  this._node.controls = this._options.nativeControls;
  this._node.setAttribute('preload', 'auto');
  this._player = new shaka.player.Player(node);

  // defaults
  this._firstTimeUpdate = false;
  this._playerBufferInterval = null;
  this._playerTimeUpdateInterval = null;
  this._state = this._getDefaultState();

  this._startListening();

  this.setVolume(this._options.volume);

  var playerSource = null;
  /* eslint-disable no-unused-vars */
  var protectionCallback = function protectionCallback(schemeUri, contentProtection) {
    return [{
      'keySystem': 'com.widevine.alpha',
      'licenseServerUrl': global.__spotify.product_state[PRODUCT_STATE_WIDEVINE_LICENSE_URL]
    }];
  };
  /* eslint-enable no-unused-vars */

  if (this._options.isDash) {
    // If config.estimator is null, the dash player will default to the
    // builtin estimator
    playerSource = new shaka.player.DashVideoSource(this._options.url, protectionCallback, this._options.bandwidthEstimator, new SPAbrManager(this._player));

    if (this._options.networkCallback) {
      playerSource.setNetworkCallback(this._options.networkCallback);
    }
  } else {
    playerSource = new shaka.player.HttpVideoSource(this._options.url);
  }

  this._playerLoadPromise = this._player.load(playerSource).then(function () {
    this.set({ 'isLoaded': true });
  }.bind(this));

  // add a tracker
  if (config.videoTrackerFactory) {
    config.videoTrackerFactory(this, this._options);
  }
  this.setPaused(this._options.startPaused);
};

util.inherits(SPVideoPlayer, EventEmitter);

SPVideoPlayer.prototype._getDefaultState = function () {
  return {
    'isAd': this._options.isAd,
    'isEnded': false,
    'isPlaying': false,
    'isPaused': this._options.startPaused,
    'isError': false,
    'isBuffering': false,
    'isLoaded': false,
    'canPlay': false,
    'isSeeking': false,
    'timeBuffering': 0,
    'readyTimeBuffering': 0,
    'isMuted': this._node.muted || this._node.volume === 0,
    'duration': this._node.duration || -1,
    'currentTime': this._node.currentTime || -1,
    'progress': this._node.currentTime / this._node.duration || 0,
    'volume': this._node.muted ? 0 : this._node.volume,
    'bitrate': 0,
    'stalls': 0,
    'stats': {},
    'endReason': 'unknown'
  };
};

SPVideoPlayer.prototype._handleEnded = function () {
  this._disablePlayTimers();

  this.set({
    isEnded: true,
    endReason: 'trackdone',
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handleDurationchange = function (e) {
  this.set({
    duration: e.target.duration,
    progress: e.target.currentTime / e.target.duration,
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handleTimeUpdate = function (e) {
  // if seeking, pretend we're at the last seek time
  var time = this._lastSeekTime || e.target.currentTime || 0;
  this.set({
    currentTime: time,
    progress: time / e.target.duration,
    stats: this._player.getStats()
  }, true);

  if (this._state.isSeeking) {
    this.set({ isSeeking: false });
    this._lastSeekTime = null;
  }
};

SPVideoPlayer.prototype._handlePlaying = function () {
  this.set({
    isPlaying: true,
    isEnded: false,
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handlePause = function () {
  this.set({
    isPlaying: false,
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handleVolumechange = function (e) {
  this.set({
    isMuted: e.target.muted || e.target.volume === 0,
    volume: e.target.muted ? 0 : e.target.volume
  });
};

SPVideoPlayer.prototype._handleLoadedmetadata = function () {
  if (this._options.preseekPosition > 0) {
    this.seekTo(this._options.preseekPosition);
    this._options.preseekPosition = 0;
  }
};

SPVideoPlayer.prototype._handleError = function (e) {
  var oldState = this.get();
  var stats = this._player.getStats();
  var errorData = {
    'type': '' + e.type,
    'detail_type': '' + e.detail.type,
    'detail_message': '' + e.detail.message,
    'play_time': '' + stats.playTime,
    'buffering_time': '' + stats.bufferingTime,
    'dropped_frames': '' + stats.droppedFrames,
    'playback_latency': '' + stats.playbackLatency
  };

  var xhr = e.detail.xhr;
  if (xhr) {
    errorData.httpStatus = xhr.status;
    errorData.responseText = xhr.responseText;
  }

  this.set({
    isEnded: true,
    isError: true,
    stats: stats,
    endReason: 'trackerror'
  }, true);

  this.emit(CHANGE_EVENT, errorData, oldState, this.get());
};

SPVideoPlayer.prototype._handleAdaptation = function (e) {
  if (e.contentType !== 'video') {
    return;
  }
  this.set({
    bitrate: e.bandwidth,
    currentTime: this._node.currentTime
  });
};

SPVideoPlayer.prototype._handleSeeked = function () {
  if (!this._state.isSeeking) {
    return;
  }
  this.set({
    isSeeking: false
  });
};

SPVideoPlayer.prototype._handleCanplay = function () {
  this.set({
    canPlay: true
  });
};

SPVideoPlayer.prototype._videoEvents = {
  'ended': '_handleEnded',
  'durationchange': '_handleDurationchange',
  'timeupdate': '_handleTimeUpdate',
  'volumechange': '_handleVolumechange',
  'playing': '_handlePlaying',
  'pause': '_handlePause',
  'seeked': '_handleSeeked',
  'canplay': '_handleCanplay',
  'loadedmetadata': '_handleLoadedmetadata'
};

SPVideoPlayer.prototype._startListening = function () {
  // video node events
  for (var x in this._videoEvents) {
    if (this._videoEvents.hasOwnProperty(x)) {
      this._node.addEventListener(x, this[this._videoEvents[x]]);
    }
  }

  // shaka player events
  this._player.addEventListener('error', this._handleError);
  this._player.addEventListener('adaptation', this._handleAdaptation);
};

SPVideoPlayer.prototype._stopListening = function () {
  // video node events
  for (var x in this._videoEvents) {
    if (this._videoEvents.hasOwnProperty(x)) {
      this._node.removeEventListener(x, this[this._videoEvents[x]]);
    }
  }

  // shaka player events
  this._player.removeEventListener('error', this._handleError);
  this._player.removeEventListener('adaptation', this._handleAdaptation);
};

SPVideoPlayer.prototype._enablePlayTimers = function () {
  if (this._playerBufferInterval) {
    return;
  }

  var lastProgress = 0;
  var lastCheckDate = new Date().getTime();
  var timerUpdate = function () {
    this.set({ timeUpdate: true });
    this.set({ timeUpdate: false }, true);
  }.bind(this);
  var bufferPoll = function () {
    var currentProgress = this.get('progress');
    var currentTime = new Date().getTime();
    var oldBuffering = this.get('isBuffering');

    if (this.get('isPlaying') === true) {
      if (!this._firstTimeUpdate) {
        timerUpdate();
        this._firstTimeUpdate = true;
      }
      if (currentProgress > lastProgress) {
        if (this.get('isBuffering') === true) {
          this.set({
            isBuffering: false,
            timeBuffering: 0
          });
        }
      } else {
        var stalls = this._state.stalls;
        if (!oldBuffering) {
          stalls++;
        }
        this.set({
          isBuffering: true,
          stalls: stalls,
          timeBuffering: this.get('timeBuffering') + currentTime - lastCheckDate
        }, oldBuffering); // only send update on first update
      }
    }

    lastProgress = currentProgress;
    lastCheckDate = currentTime;
  }.bind(this);
  this._playerTimeUpdateInterval = setInterval(timerUpdate, UPDATE_INTERVAL);
  this._playerBufferInterval = setInterval(bufferPoll, BUFFERING_INTERVAL);
};

SPVideoPlayer.prototype._disablePlayTimers = function () {
  clearInterval(this._playerBufferInterval);
  clearInterval(this._playerTimeUpdateInterval);
  this._playerBufferInterval = null;
  this._playerTimeUpdateInterval = null;
  this.set('isBuffering', false);
  this.set('timeBuffering', 0);
};

/**
 * @param {String} [key]
 * @return {*} - value at key or shallow clone of state
 */
SPVideoPlayer.prototype.get = function (key) {
  return arguments.length ? this._state[key] : _.clone(this._state);
};

/**
 * @param {String|Object} key - key or hash of key:value pairs to be updated
 * @param {*} [val]
 * @param {Boolean} [silent] - if true then no change event is fired
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.set = function (key, val, silent) {
  var oldState = this.get();

  if (arguments.length < 3 && util.isObject(key)) {
    silent = val;
    _.extend(this._state, key);
  } else {
    this._state[key] = val;
  }

  if (!silent) {
    this.emit(CHANGE_EVENT, undefined, oldState, this.get());
  }

  return this;
};

/**
 * @param {Number} n
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.setPaused = function (p) {
  p = !!p;
  if (p) {
    this._node.pause();
    this._node.playbackRate = 0;
    this._disablePlayTimers();
  } else {
    this._node.play();
    this._node.playbackRate = 1;
    this._enablePlayTimers();
  }
  this._node.autoplay = !p;
  this.set({ 'isPaused': p });
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.pause = function () {
  return this.setPaused(true);
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.play = function () {
  return this.setPaused(false);
};

/**
 * @param {Number} n
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.setVolume = function (n) {
  this._node.volume = n;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.seekTo = function (timeInSeconds) {
  if (timeInSeconds < 0) {
    timeInSeconds = 0;
  }
  var duration = this._node.duration || 0;
  if (timeInSeconds > duration) {
    timeInSeconds = duration;
  }
  // Some content doesn't actually start on 0, if we
  // seek to before the start time, shaka player just
  // freezes there.
  if (timeInSeconds < 0.1) {
    timeInSeconds = 0.1;
  }

  this._lastSeekTime = timeInSeconds;
  // Update the current time, and then emit the event, so the
  // states will hold the seek diff, and let the first update be silent
  this.set({ currentTime: this._node.currentTime }, true);
  this.set({ isSeeking: true, currentTime: timeInSeconds });
  this._node.currentTime = timeInSeconds;

  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.mute = function () {
  this._node.muted = true;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unmute = function () {
  this._node.muted = false;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unload = function (reason) {
  this._disablePlayTimers();
  this.set({
    isEnded: true,
    endReason: reason,
    stats: this._player.getStats()
  });
  this._stopListening();
  this._playerLoadPromise.then(function () {
    this._player.unload();
  }.bind(this));
};

/**
 * @param {String} [prop]
 * @param {Function} fn
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.subscribe = function (prop, fn) {
  if (typeof prop === 'string') {
    this.addListener(CHANGE_EVENT + ':' + prop, fn);
  } else {
    this.addListener(CHANGE_EVENT, prop);
  }

  return this;
};

/**
 * @param {String} [prop]
 * @param {Function} fn
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unsubscribe = function (prop, fn) {
  if (typeof prop === 'string') {
    this.removeListener(CHANGE_EVENT + ':' + prop, fn);
  } else {
    this.removeListener(CHANGE_EVENT, prop);
  }

  return this;
};

/**
 * @return {node} node
 */
SPVideoPlayer.prototype.getNode = function () {
  return this._node;
};

module.exports = SPVideoPlayer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./SPAbrManager":355,"./shaka":361,"./utils":362,"events":371,"util":586}],359:[function(require,module,exports){
'use strict';

var _ = require('./utils');
var EndVideo9 = require('../../spotify-logger/pending-messages/EndVideo9');

var SPVideoPlayerTracker = function SPVideoPlayerTracker(player, options) {
  this._nSeekfwd = 0;
  this._msSeekfwd = 0;
  this._nSeekback = 0;
  this._msSeekback = 0;
  this._nStalls = 0;
  this._startBitrate = 0;
  this._oldBitrate = 0;
  this._initTime = new Date().getTime();
  this._latency = 0;
  this._bitrates = [];
  this._options = options;
  this._logged = false;
  this._endVideoSent = false;
  this._shouldSendEndVideo = false;
  this._endReason = 'unknown';
  this._duration = 0;
  _.bindAll(this);

  player.subscribe(this._onChange);
};

SPVideoPlayerTracker.prototype._onChange = function (errorData, oldState, newState) {

  if (this._latency === 0 && newState.currentTime >= 0) {
    this._latency = new Date().getTime() - this._initTime;
  }

  if (!oldState.isSeeking && newState.isSeeking) {
    this._seekTo(oldState, newState);
  }
  if (this._duration === 0 && newState.duration >= 0) {
    this._duration = newState.duration;
  }

  if (this._endReason !== newState.endReason) {
    this._endReason = newState.endReason;
  }
  if (newState.bitrate !== this._oldBitrate) {
    this._updatePlayedSegment(newState.currentTime, oldState.bitrate, newState.currentTime, false);
  }

  this._oldBitrate = newState.bitrate;
  if (this._startBitrate === 0) {
    this._startBitrate = newState.bitrate;
  }

  if (newState.timeUpdate) {
    this._updateEndVideo('unexpected-exit', newState.stats);
  }

  if (!oldState.isPaused && newState.isPaused) {
    this._updateEndVideo('unexpected-exit-while-paused', newState.stats);
  }

  if (newState.isEnded && !this._logged) {
    this._updatePlayedSegment(newState.currentTime, oldState.bitrate, newState.currentTime, true);
    this._logEndVideo(this._endReason, newState.stats);
    this._logged = true;
  }
};

SPVideoPlayerTracker.prototype._seekTo = function (oldState, newState) {
  this._updatePlayedSegment(oldState.currentTime, oldState.bitrate, newState.currentTime, true);

  var relativeSeek = newState.currentTime - oldState.currentTime;
  if (relativeSeek > 0) {
    this._nSeekfwd++;
    this._msSeekfwd += relativeSeek;
  } else {
    this._nSeekback++;
    this._msSeekback -= relativeSeek;
  }
};

SPVideoPlayerTracker.prototype._updatePlayedSegment = function (currentTime, bitrate, newTime, endSegment) {

  if (this._segmentStartTime !== undefined) {
    var diff = currentTime - this._segmentStartTime;
    if (diff > 0.01) {
      this._bitrates.push({
        timeDiff: diff,
        endSegment: endSegment,
        bitrate: bitrate
      });
    }
  }

  if (currentTime >= 0.0) {
    this._segmentStartTime = newTime;
  }
};

SPVideoPlayerTracker.prototype._calculatePlayTimesAndBitrates = function () {
  var played = 0;
  var maxContinuous = 0;
  var curContinuous = 0;
  var bitrateLength = {};
  var startContinous = true;
  for (var i in this._bitrates) {
    if (!this._bitrates.hasOwnProperty(i)) {
      continue;
    }
    var ent = this._bitrates[i];
    played += ent.timeDiff;
    if (startContinous) {
      curContinuous = ent.timeDiff;
    } else {
      curContinuous += ent.timeDiff;
    }
    maxContinuous = Math.max(maxContinuous, curContinuous);

    if (bitrateLength.hasOwnProperty(ent.bitrate)) {
      bitrateLength[ent.bitrate] += ent.timeDiff;
    } else {
      bitrateLength[ent.bitrate] = ent.timeDiff;
    }
    startContinous = ent.endSegment;
  }

  var timeWeightedBitrate = 0;
  for (var bitrate in bitrateLength) {
    if (bitrateLength.hasOwnProperty(bitrate)) {
      timeWeightedBitrate += bitrate * bitrateLength[bitrate] / played;
    }
  }
  return {
    msPlayed: Math.round(played * 1000),
    unionPlayed: -1,
    maxContinuous: Math.round(maxContinuous * 1000),
    timeWeightedBitrate: Math.round(timeWeightedBitrate)
  };
};

SPVideoPlayerTracker.prototype._createMessage = function (reason, stats) {

  var calc = this._calculatePlayTimesAndBitrates();
  return {
    'sequence_number': this._messageId,
    'file_id': this._options.fileId,
    'playback_id': this._options.playbackID,
    'feature_identifier': this._options.playOrigin.feature_identifier,
    'feature_version': this._options.playOrigin.feature_version,
    'view_uri': this._options.playOrigin.view_uri,
    'reason_start': this._options.startReason,
    'reason_end': reason,
    'ms_played': calc.msPlayed,
    'ms_total_est': Math.round(this._duration * 1000),
    'live': false,
    'ms_manifest_latency': -1,
    'n_seekback': this._nSeekback,
    'ms_seekback': Math.round(this._msSeekback * 1000),
    'n_seekfwd': this._nSeekfwd,
    'ms_seekfwd': Math.round(this._msSeekfwd * 1000),
    'ms_latency': Math.round(this._latency),
    'ui_latency': -1,
    'start_offset_ms': Math.round(this._options.preseekPosition * 1000),
    'ms_initial_buffering': Math.round(stats.bufferingTime * 1000),
    'ms_seek_rebuffering': -1,
    'ms_stalled': -1,
    'max_ms_seek_rebuffering': -1,
    'max_ms_stalled': -1,
    'n_stalls': this._nStalls,
    'shuffle': false,
    'max_continous': calc.maxContinuous,
    'union_played': calc.unionPlayed,
    'play_context': this._options.play_context,
    'audiocodec': 'mp4a.40.5',
    'videocodec': 'vp9',
    'play_track': this._options.track_uri,
    'incognito_mode': false,
    'provider': this._options.provider,
    'referrer': this._options.playOrigin.external_referrer,
    'referrer_version': this._options.playOrigin.feature_version,
    'referrer_vendor': 'com.spotify',
    'streaming_rule': '',
    'gaia_dev_id': this._options.playOrigin.device_identifier,
    'start_bitrate': this._startBitrate,
    'full_screen': 0,
    'time_weighted_bitrate': calc.timeWeightedBitrate,
    'prefetched_bytes': 0,
    'prefetched_bytes_loaded': -1,
    'key_system': '',
    'ms_key_latency': -1,
    'total_bytes': Math.round(calc.timeWeightedBitrate * calc.msPlayed / 1000 / 8),
    'local_time_ms': Math.round(this._initTime * 1000),
    'connection_type_start': 'unknown',
    'connection_type_end': 'unknown',
    'ms_played_background': 0
  };
};

SPVideoPlayerTracker.prototype._updateEndVideoInternal = function (reason, stats) {
  var logMessage = this._createMessage(reason, stats);
  EndVideo9.update(this._messageId, logMessage, function (error) {
    if (error) {
      console.error('logEndVideo, failed update:', error);
      return;
    }
    if (this._shouldSendEndVideo) {
      EndVideo9.send(this._messageId);
    }
  }.bind(this));
};

SPVideoPlayerTracker.prototype._updateEndVideo = function (reason, stats) {
  if (this._endVideoSent) {
    return;
  }

  if (this._messageId === undefined) {
    this._messageId = -1;

    EndVideo9.create(function (error, messageId) {
      if (error) {
        this._messageId = undefined;
        return;
      }
      this._messageId = messageId;
      this._updateEndVideoInternal(reason, stats);
    }.bind(this));
    return;
  } else if (this._messageId === -1) {
    // if we are waiting for an 'add' just bail, this is a rare case
    // but just bail here since it's probably good enough
    return;
  }
  // Do a final update and sene the EndVideo
  this._updateEndVideoInternal(reason, stats);
};

SPVideoPlayerTracker.prototype._logEndVideo = function (reason, stats) {
  if (this._endVideoSent) {
    return;
  }
  this._shouldSendEndVideo = true;
  this._updateEndVideo(reason, stats);
  this._endVideoSent = true;
};

module.exports = SPVideoPlayerTracker;

},{"../../spotify-logger/pending-messages/EndVideo9":326,"./utils":362}],360:[function(require,module,exports){
/**
 * @license
 * Copyright 2015 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Computes an exponentionally-weighted moving average.
 *
 * @param {number} halfLife About half of the estimated value will be from the
 *     last |halfLife| samples by weight.
 * @struct
 * @constructor
 */
'use strict';

var EWMA = function EWMA(halfLife) {

  /**
   * Larger values of alpha expire historical data more slowly.
   * @private {number}
   */
  this.alpha_ = Math.exp(Math.log(0.5) / halfLife);

  /** @private {number} */
  this.estimate_ = 0;

  /** @private {number} */
  this.totalWeight_ = 0;
};

/**
 * Takes a sample.
 *
 * @param {number} weight
 * @param {number} value
 */
EWMA.prototype.sample = function (weight, value) {
  var adjAlpha = Math.pow(this.alpha_, weight);
  this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
  this.totalWeight_ += weight;
};

/**
 * @return {number}
 */
EWMA.prototype.getTotalWeight = function () {
  return this.totalWeight_;
};

/**
 * @return {number}
 */
EWMA.prototype.getEstimate = function () {
  var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
  return this.estimate_ / zeroFactor;
};

module.exports = EWMA;

},{}],361:[function(require,module,exports){
'use strict';

var shaka = require('shaka-player');

if (typeof document !== 'undefined' && typeof Document !== 'undefined') {
  shaka.polyfill.installAll();
}

module.exports = shaka;

},{"shaka-player":544}],362:[function(require,module,exports){
'use strict';

module.exports = {
  extend: function extend() {
    return Object.assign.apply(Object, arguments);
  },

  clone: function clone(obj) {
    return Object.assign({}, obj);
  },

  bindAll: function bindAll(obj, keys) {
    var key;

    if (arguments.length === 1) {
      for (key in obj) {
        if (typeof obj[key] === 'function') {
          obj[key] = obj[key].bind(obj);
        }
      }
    } else {
      for (key in keys) {
        if (typeof obj[keys[key]] === 'function') {
          obj[keys[key]] = obj[keys[key]].bind(obj);
        }
      }
    }

    return obj;
  }
};

},{}],363:[function(require,module,exports){
/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
 * spline.get(x) => returns the easing value | x must be in [0, 1] range
 *
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === "function";

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) {
  return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
}

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0.0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}

/**
 * points is an array of [ mX1, mY1, mX2, mY2 ]
 */
function BezierEasing (points, b, c, d) {
  if (arguments.length === 4) {
    return new BezierEasing([ points, b, c, d ]);
  }
  if (!(this instanceof BezierEasing)) return new BezierEasing(points);

  if (!points || points.length !== 4) {
    throw new Error("BezierEasing: points must contains 4 values");
  }
  for (var i=0; i<4; ++i) {
    if (typeof points[i] !== "number" || isNaN(points[i]) || !isFinite(points[i])) {
      throw new Error("BezierEasing: points should be integers.");
    }
  }
  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {
    throw new Error("BezierEasing x values must be in [0, 1] range.");
  }

  this._str = "BezierEasing("+points+")";
  this._css = "cubic-bezier("+points+")";
  this._p = points;
  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  this._precomputed = false;

  this.get = this.get.bind(this);
}

BezierEasing.prototype = {

  get: function (x) {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    if (!this._precomputed) this._precompute();
    if (mX1 === mY1 && mX2 === mY2) return x; // linear
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) return 0;
    if (x === 1) return 1;
    return calcBezier(this._getTForX(x), mY1, mY2);
  },

  getPoints: function() {
    return this._p;
  },

  toString: function () {
    return this._str;
  },

  toCSS: function () {
    return this._css;
  },

  // Private part

  _precompute: function () {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    this._precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2)
      this._calcSampleValues();
  },

  _calcSampleValues: function () {
    var mX1 = this._p[0],
      mX2 = this._p[2];
    for (var i = 0; i < kSplineTableSize; ++i) {
      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  },

  /**
   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
   */
  _getTForX: function (aX) {
    var mX1 = this._p[0],
      mX2 = this._p[2],
      mSampleValues = this._mSampleValues;

    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
};

// CSS mapping
BezierEasing.css = {
  "ease":        BezierEasing.ease      = BezierEasing(0.25, 0.1, 0.25, 1.0),
  "linear":      BezierEasing.linear    = BezierEasing(0.00, 0.0, 1.00, 1.0),
  "ease-in":     BezierEasing.easeIn    = BezierEasing(0.42, 0.0, 1.00, 1.0),
  "ease-out":    BezierEasing.easeOut   = BezierEasing(0.00, 0.0, 0.58, 1.0),
  "ease-in-out": BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)
};

module.exports = BezierEasing;

},{}],364:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":365,"./src/player_state":366,"./src/request":367,"./src/response":368}],365:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],366:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":561}],367:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":365,"spotify-inheritance":561}],368:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":365,"spotify-inheritance":561}],369:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":370}],370:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":512}],371:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],372:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var undefined;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],373:[function(require,module,exports){
/*
Finally
*/'use strict';

var prime = require('prime');

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var slice = require('mout/array/slice');
var forEach = require('mout/array/forEach');
var reduce = require('mout/array/reduce');

var each = require('mout/collection/forEach');
var cmap = require('mout/collection/map');

var push_ = Array.prototype.push;

/* create the flow */
var Flow = prime({

  /* options */
  constructor: function Flow() {
    this._seq = [];
  },

  /* add steps to the flow */
  then: function() {
    this._push(this._callbacks(arguments));
    return this;
  },

  _parallel: function(parallel, args) {
    var self = this;
    return function() {
      var control = new Controller(self, self._index++);
      self._controls.push(control);
      parallel.apply(control, args ? args.concat(slice(arguments)) : arguments);
    };
  },

  _push: function(parallels, args) {
    if (!parallels.length) return;
    this._seq.push(map(parallels, function(parallel) {
      return this._parallel(parallel, args);
    }, this));
  },

  _callbacks: function(callbacks) {
    return reduce(callbacks, function(a, b) {
      if (kindOf(b) === 'Array') push_.apply(a, b);
      else a.push(b);
      return a;
    }, []);
  },

  /* will make a sequential entry for each entry in the object */
  sequential: function(object) {
    var callbacks = this._callbacks(slice(arguments, 1));
    each(object, function(value, key) {
      this._push(callbacks, [value, key]);
    }, this);
    return this;
  },

  /* will make a single sequential entry with one parallel for each entry in the object */
  parallel: function(object, parallel) {
    var parallels = cmap(object, function(value, key) {
      return this._parallel(parallel, [value, key]);
    }, this);
    if (parallels.length) this._seq.push(parallels);
    return this;
  },

  /* assign last step and execute the flow */
  finally: function() {
    this.then.apply(this, arguments);
    this._continue.call(this);
    return this;
  },

  /* execute the flow with arguments to the first step */
  run: function() {
    this._continue.apply(this, arguments);
    return this;
  },

  // private

  _break: function() {
    this._seq.splice(0, this._seq.length - 1);
    this._continue.apply(this, arguments);
  },

  _spread: function(error, args) {
    var seq = this._next();
    if (!seq || !(seq = seq[0])) return;
    if (!args || !args.length) args = [undefined];
    this._length = args.length;
    forEach(args, function(arg) {
      seq(error, arg);
    });
  },

  _continue: function() {
    var seq = this._next();
    if (!seq) return;
    this._length = seq.length;
    var args = arguments;
    forEach(seq, function(parallel) {
      parallel.apply(null, args);
    });
  },

  _next: function() {
    var seq = this._seq.shift();
    if (!seq) return;

    if (this._controls) forEach(this._controls, function(control) { // kill old controls
      control._kill();
    });

    // reset variables

    this._arguments = [];
    this._errors = [];
    this._controls = [];
    this._index = 0;

    return seq;
  },

  _done: function(index, error, data) {
    this._arguments[index] = data;
    if (error) this._errors.push(error);
    if (!--this._length) {
      var errors = null;
      if (this._errors.length === 1) errors = this._errors[0];
      else if (this._errors.length) errors = new Error(map(this._errors, function(e) {
        return e.message;
      }).join('\n'));
      this._continue.apply(this, [errors].concat(this._arguments));
    }
    else this._controls[index]._kill();
  }

});

/* control the flow */
var Controller = function Controller(flow, index) {

  var dead;

  this._kill = function() {
    dead = true;
  };

  /* break the flow */
  this.break = function() {
    if (!dead) flow._break.apply(flow, arguments);
  };

  /* step in the next sequential */
  this.continue = function() {
    if (!dead) flow._continue.apply(flow, arguments);
  };

  /* spread results to the next sequential */
  this.spread = function(error, args) {
    if (!dead) flow._spread(error, args);
  };

  /* set the the current parallel in the sequential as complete */
  var done = this.done = function(error, data) {
    if (!dead) flow._done.call(flow, index, error, data);
  };

};

/* public interface */
module.exports = function() {
  var flow = new Flow();
  flow.then.apply(flow, arguments);
  return flow;
};

},{"mout/array/forEach":374,"mout/array/map":375,"mout/array/reduce":376,"mout/array/slice":377,"mout/collection/forEach":378,"mout/collection/map":380,"mout/lang/kindOf":388,"prime":395}],374:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],375:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":382}],376:[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],377:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],378:[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":374,"../object/forOwn":391,"./make_":379}],379:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":377}],380:[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":375,"../function/makeIterator_":382,"../lang/isObject":387,"../object/values":394}],381:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],382:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":389,"./identity":381,"./prop":383}],383:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],384:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":393}],385:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":386}],386:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":388}],387:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":386}],388:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],389:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":385,"./forOwn":391}],390:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":392}],391:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":390,"./hasOwn":392}],392:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],393:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":391}],394:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":391}],395:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/"use strict"

var hasOwn = require("mout/object/hasOwn"),
    mixIn  = require("mout/object/mixIn"),
    create = require("mout/lang/createObject"),
    kindOf = require("mout/lang/kindOf")

var hasDescriptors = true

try {
    Object.defineProperty({}, "~", {})
    Object.getOwnPropertyDescriptor({}, "~")
} catch (e){
    hasDescriptors = false
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !({valueOf: 0}).propertyIsEnumerable("valueOf"),
    buggy      = ["toString", "valueOf"]

var verbs = /^constructor|inherits|mixin$/

var implement = function(proto){
    var prototype = this.prototype

    for (var key in proto){
        if (key.match(verbs)) continue
        if (hasDescriptors){
            var descriptor = Object.getOwnPropertyDescriptor(proto, key)
            if (descriptor){
                Object.defineProperty(prototype, key, descriptor)
                continue
            }
        }
        prototype[key] = proto[key]
    }

    if (hasEnumBug) for (var i = 0; (key = buggy[i]); i++){
        var value = proto[key]
        if (value !== Object.prototype[key]) prototype[key] = value
    }

    return this
}

var prime = function(proto){

    if (kindOf(proto) === "Function") proto = {constructor: proto}

    var superprime = proto.inherits

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = (hasOwn(proto, "constructor")) ? proto.constructor : (superprime) ? function(){
        return superprime.apply(this, arguments)
    } : function(){}

    if (superprime){

        mixIn(constructor, superprime)

        var superproto = superprime.prototype
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto)

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto
        cproto.constructor = constructor
    }

    if (!constructor.implement) constructor.implement = implement

    var mixins = proto.mixin
    if (mixins){
        if (kindOf(mixins) !== "Array") mixins = [mixins]
        for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype))
    }

    // implement proto and return constructor
    return constructor.implement(proto)

}

module.exports = prime

},{"mout/lang/createObject":384,"mout/lang/kindOf":388,"mout/object/hasOwn":392,"mout/object/mixIn":393}],396:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":397,"./handlebars/exception":398,"./handlebars/runtime":399,"./handlebars/safe-string":400,"./handlebars/utils":401}],397:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":398,"./utils":401}],398:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],399:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":397,"./exception":398,"./utils":401}],400:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],401:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":400}],402:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":396}],403:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":402}],404:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],405:[function(require,module,exports){

/**
 port of http://www.bbc.co.uk/glow/docs/1.7/api/glow.lang.shtml #interpolate
  Modified to be stand-alone and offer support for delimters of random length
  @description Replaces placeholders in a string with data from an object

  @param {String} template The string containing {placeholders}
  @param {Object} data Object containing the data to be merged in to the template
    The object can contain nested data objects and arrays, with nested object properties and array elements are accessed using dot notation. eg foo.bar or foo.0.
    The data labels in the object cannot contain characters used in the template delimiters, so if the data must be allowed to contain the default { and } delimiters, the delimters must be changed using the option below.
  @param {Object} opts Options object
    @param {String} [opts.delimiter="{}"] Alternative label delimiter(s) for the template. Needs to be symmetric, i.e. '{{}}', '<%%>'

  @returns {String}
 */

function interpolate (template, data, opts) {
  var regex,
      lDel,
      rDel,
      delLen,
      lDelLen,
      delimiter,
      // For escaping strings to go in regex
      regexEscape = /([$\^\\\/()|?+*\[\]{}.\-])/g;

  opts = opts || {};

  delimiter = opts.delimiter || '{}';
  delLen = delimiter.length;
  lDelLen = Math.ceil(delLen / 2);
  // escape delimiters for regex
  lDel = delimiter.substr(0, lDelLen).replace(regexEscape, "\\$1");
  rDel = delimiter.substr(lDelLen, delLen).replace(regexEscape, "\\$1") || lDel;

  // construct the new regex
  regex = new RegExp(lDel + "[^" + lDel + rDel + "]+" + rDel, "g");

  return template.replace(regex, function (placeholder) {
    var key = placeholder.slice(lDelLen, -lDelLen),
        keyParts = key.split("."),
        val,
        i = 0,
        len = keyParts.length;

    if (key in data) {
      // need to be backwards compatible with "flattened" data.
      val = data[key];
    }
    else {
      // look up the chain
      val = data;
      for (; i < len; i++) {
        if (keyParts[i] in val) {
          val = val[ keyParts[i] ];
        } else {
          return placeholder;
        }
      }
    }
    return val;
  });
}

module.exports = interpolate;

},{}],406:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    baseLodash = require('./_baseLodash');

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

module.exports = LazyWrapper;

},{"./_baseCreate":410,"./_baseLodash":412}],407:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    baseLodash = require('./_baseLodash');

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

module.exports = LodashWrapper;

},{"./_baseCreate":410,"./_baseLodash":412}],408:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":430,"./_root":441}],409:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],410:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

module.exports = baseCreate;

},{"./isObject":451}],411:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isHostObject = require('./_isHostObject'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isHostObject":432,"./_isMasked":435,"./_toSource":443,"./isFunction":450,"./isObject":451}],412:[function(require,module,exports){
/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

module.exports = baseLodash;

},{}],413:[function(require,module,exports){
var identity = require('./identity'),
    metaMap = require('./_metaMap');

/**
 * The base implementation of `setData` without support for hot loop detection.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;

},{"./_metaMap":437,"./identity":448}],414:[function(require,module,exports){
/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = checkGlobal;

},{}],415:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgs;

},{}],416:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

module.exports = composeArgsRight;

},{}],417:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],418:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":441}],419:[function(require,module,exports){
/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      result++;
    }
  }
  return result;
}

module.exports = countHolders;

},{}],420:[function(require,module,exports){
var createCtorWrapper = require('./_createCtorWrapper'),
    root = require('./_root');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBaseWrapper(func, bitmask, thisArg) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

module.exports = createBaseWrapper;

},{"./_createCtorWrapper":421,"./_root":441}],421:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    isObject = require('./isObject');

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtorWrapper(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtorWrapper;

},{"./_baseCreate":410,"./isObject":451}],422:[function(require,module,exports){
var apply = require('./_apply'),
    createCtorWrapper = require('./_createCtorWrapper'),
    createHybridWrapper = require('./_createHybridWrapper'),
    createRecurryWrapper = require('./_createRecurryWrapper'),
    getHolder = require('./_getHolder'),
    replaceHolders = require('./_replaceHolders'),
    root = require('./_root');

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurryWrapper(func, bitmask, arity) {
  var Ctor = createCtorWrapper(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurryWrapper(
        func, bitmask, createHybridWrapper, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

module.exports = createCurryWrapper;

},{"./_apply":409,"./_createCtorWrapper":421,"./_createHybridWrapper":423,"./_createRecurryWrapper":425,"./_getHolder":429,"./_replaceHolders":440,"./_root":441}],423:[function(require,module,exports){
var composeArgs = require('./_composeArgs'),
    composeArgsRight = require('./_composeArgsRight'),
    countHolders = require('./_countHolders'),
    createCtorWrapper = require('./_createCtorWrapper'),
    createRecurryWrapper = require('./_createRecurryWrapper'),
    getHolder = require('./_getHolder'),
    reorder = require('./_reorder'),
    replaceHolders = require('./_replaceHolders'),
    root = require('./_root');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    ARY_FLAG = 128,
    FLIP_FLAG = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG,
      isBind = bitmask & BIND_FLAG,
      isBindKey = bitmask & BIND_KEY_FLAG,
      isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
      isFlip = bitmask & FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtorWrapper(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurryWrapper(
        func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtorWrapper(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

module.exports = createHybridWrapper;

},{"./_composeArgs":415,"./_composeArgsRight":416,"./_countHolders":419,"./_createCtorWrapper":421,"./_createRecurryWrapper":425,"./_getHolder":429,"./_reorder":439,"./_replaceHolders":440,"./_root":441}],424:[function(require,module,exports){
var apply = require('./_apply'),
    createCtorWrapper = require('./_createCtorWrapper'),
    root = require('./_root');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartialWrapper(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartialWrapper;

},{"./_apply":409,"./_createCtorWrapper":421,"./_root":441}],425:[function(require,module,exports){
var isLaziable = require('./_isLaziable'),
    setData = require('./_setData');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & CURRY_FLAG,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

  if (!(bitmask & CURRY_BOUND_FLAG)) {
    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (isLaziable(func)) {
    setData(result, newData);
  }
  result.placeholder = placeholder;
  return result;
}

module.exports = createRecurryWrapper;

},{"./_isLaziable":434,"./_setData":442}],426:[function(require,module,exports){
var baseSetData = require('./_baseSetData'),
    createBaseWrapper = require('./_createBaseWrapper'),
    createCurryWrapper = require('./_createCurryWrapper'),
    createHybridWrapper = require('./_createHybridWrapper'),
    createPartialWrapper = require('./_createPartialWrapper'),
    getData = require('./_getData'),
    mergeData = require('./_mergeData'),
    setData = require('./_setData'),
    toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags.
 *  The bitmask may be composed of the following flags:
 *     1 - `_.bind`
 *     2 - `_.bindKey`
 *     4 - `_.curry` or `_.curryRight` of a bound function
 *     8 - `_.curry`
 *    16 - `_.curryRight`
 *    32 - `_.partial`
 *    64 - `_.partialRight`
 *   128 - `_.rearg`
 *   256 - `_.ary`
 *   512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] == null
    ? (isBindKey ? 0 : func.length)
    : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == BIND_FLAG) {
    var result = createBaseWrapper(func, bitmask, thisArg);
  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
    result = createCurryWrapper(func, bitmask, arity);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
    result = createPartialWrapper(func, bitmask, thisArg, partials);
  } else {
    result = createHybridWrapper.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setter(result, newData);
}

module.exports = createWrapper;

},{"./_baseSetData":413,"./_createBaseWrapper":420,"./_createCurryWrapper":422,"./_createHybridWrapper":423,"./_createPartialWrapper":424,"./_getData":427,"./_mergeData":436,"./_setData":442,"./toInteger":459}],427:[function(require,module,exports){
var metaMap = require('./_metaMap'),
    noop = require('./noop');

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};

module.exports = getData;

},{"./_metaMap":437,"./noop":454}],428:[function(require,module,exports){
var realNames = require('./_realNames');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = hasOwnProperty.call(realNames, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

module.exports = getFuncName;

},{"./_realNames":438}],429:[function(require,module,exports){
/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

module.exports = getHolder;

},{}],430:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":411,"./_getValue":431}],431:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],432:[function(require,module,exports){
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

module.exports = isHostObject;

},{}],433:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],434:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    getData = require('./_getData'),
    getFuncName = require('./_getFuncName'),
    lodash = require('./wrapperLodash');

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

module.exports = isLaziable;

},{"./_LazyWrapper":406,"./_getData":427,"./_getFuncName":428,"./wrapperLodash":461}],435:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":418}],436:[function(require,module,exports){
var composeArgs = require('./_composeArgs'),
    composeArgsRight = require('./_composeArgsRight'),
    replaceHolders = require('./_replaceHolders');

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    ARY_FLAG = 128,
    REARG_FLAG = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);

  var isCombo =
    ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
    ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
    ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & BIND_FLAG) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

module.exports = mergeData;

},{"./_composeArgs":415,"./_composeArgsRight":416,"./_replaceHolders":440}],437:[function(require,module,exports){
var WeakMap = require('./_WeakMap');

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

},{"./_WeakMap":408}],438:[function(require,module,exports){
/** Used to lookup unminified function names. */
var realNames = {};

module.exports = realNames;

},{}],439:[function(require,module,exports){
var copyArray = require('./_copyArray'),
    isIndex = require('./_isIndex');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

module.exports = reorder;

},{"./_copyArray":417,"./_isIndex":433}],440:[function(require,module,exports){
/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result[resIndex++] = index;
    }
  }
  return result;
}

module.exports = replaceHolders;

},{}],441:[function(require,module,exports){
(function (global){
var checkGlobal = require('./_checkGlobal');

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(typeof self == 'object' && self);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(typeof this == 'object' && this);

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();

module.exports = root;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_checkGlobal":414}],442:[function(require,module,exports){
var baseSetData = require('./_baseSetData'),
    now = require('./now');

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 150,
    HOT_SPAN = 16;

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = (function() {
  var count = 0,
      lastCalled = 0;

  return function(key, value) {
    var stamp = now(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return key;
      }
    } else {
      count = 0;
    }
    return baseSetData(key, value);
  };
}());

module.exports = setData;

},{"./_baseSetData":413,"./now":455}],443:[function(require,module,exports){
/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],444:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    LodashWrapper = require('./_LodashWrapper'),
    copyArray = require('./_copyArray');

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

module.exports = wrapperClone;

},{"./_LazyWrapper":406,"./_LodashWrapper":407,"./_copyArray":417}],445:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => allows adding up to 4 contacts to the list
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;

},{"./toInteger":459}],446:[function(require,module,exports){
var createWrapper = require('./_createWrapper');

/** Used to compose bitmasks for wrapper metadata. */
var CURRY_FLAG = 8;

/**
 * Creates a function that accepts arguments of `func` and either invokes
 * `func` returning its result, if at least `arity` number of arguments have
 * been provided, or returns a function that accepts the remaining `func`
 * arguments, and so on. The arity of `func` may be specified if `func.length`
 * is not sufficient.
 *
 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curry(abc);
 *
 * curried(1)(2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(1)(_, 3)(2);
 * // => [1, 2, 3]
 */
function curry(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curry.placeholder;
  return result;
}

// Assign default placeholders.
curry.placeholder = {};

module.exports = curry;

},{"./_createWrapper":426}],447:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide an options object to indicate whether `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent calls
 * to the debounced function return the result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":451,"./now":455,"./toNumber":460}],448:[function(require,module,exports){
/**
 * This method returns the first argument given to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],449:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],450:[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;

},{"./isObject":451}],451:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],452:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],453:[function(require,module,exports){
var isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;

},{"./isObjectLike":452}],454:[function(require,module,exports){
/**
 * A method that returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],455:[function(require,module,exports){
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
function now() {
  return Date.now();
}

module.exports = now;

},{}],456:[function(require,module,exports){
var before = require('./before');

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // `initialize` invokes `createApplication` once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;

},{"./before":445}],457:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide an options object to indicate whether
 * `func` should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":447,"./isObject":451}],458:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":460}],459:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":458}],460:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isFunction":450,"./isObject":451,"./isSymbol":453}],461:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    LodashWrapper = require('./_LodashWrapper'),
    baseLodash = require('./_baseLodash'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike'),
    wrapperClone = require('./_wrapperClone');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array of at least `200` elements
 * and any iteratees accept only one argument. The heuristic for whether a
 * section qualifies for shortcut fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
 * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
 * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
 * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
 * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
 * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
 * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,
 * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,
 * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,
 * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;

module.exports = lodash;

},{"./_LazyWrapper":406,"./_LodashWrapper":407,"./_baseLodash":412,"./_wrapperClone":444,"./isArray":449,"./isObjectLike":452}],462:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":471}],463:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":471}],464:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":463,"./filter":467,"./slice":475,"./some":476,"./unique":477}],465:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":485,"../lang/isArray":486,"./every":466}],466:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":479}],467:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":479}],468:[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":469}],469:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":479}],470:[function(require,module,exports){
arguments[4][374][0].apply(exports,arguments)
},{"dup":374}],471:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],472:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":463,"./every":466,"./filter":467,"./slice":475,"./unique":477}],473:[function(require,module,exports){
arguments[4][375][0].apply(exports,arguments)
},{"../function/makeIterator_":479,"dup":375}],474:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":471}],475:[function(require,module,exports){
arguments[4][377][0].apply(exports,arguments)
},{"dup":377}],476:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":479}],477:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":467}],478:[function(require,module,exports){
arguments[4][381][0].apply(exports,arguments)
},{"dup":381}],479:[function(require,module,exports){
arguments[4][382][0].apply(exports,arguments)
},{"../object/deepMatches":495,"./identity":478,"./prop":480,"dup":382}],480:[function(require,module,exports){
arguments[4][383][0].apply(exports,arguments)
},{"dup":383}],481:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":504,"./isPlainObject":490,"./kindOf":492}],482:[function(require,module,exports){
arguments[4][384][0].apply(exports,arguments)
},{"../object/mixIn":504,"dup":384}],483:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":500,"./clone":481,"./isPlainObject":490,"./kindOf":492}],484:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":465,"../object/equals":497,"./is":485,"./isArray":486,"./isObject":489}],485:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],486:[function(require,module,exports){
arguments[4][385][0].apply(exports,arguments)
},{"./isKind":487,"dup":385}],487:[function(require,module,exports){
arguments[4][386][0].apply(exports,arguments)
},{"./kindOf":492,"dup":386}],488:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":487}],489:[function(require,module,exports){
arguments[4][387][0].apply(exports,arguments)
},{"./isKind":487,"dup":387}],490:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],491:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":487}],492:[function(require,module,exports){
arguments[4][388][0].apply(exports,arguments)
},{"dup":388}],493:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],494:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":490,"./forOwn":500}],495:[function(require,module,exports){
arguments[4][389][0].apply(exports,arguments)
},{"../lang/isArray":486,"./forOwn":500,"dup":389}],496:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":490,"./forOwn":500}],497:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":485,"../lang/isObject":489,"./every":498,"./hasOwn":501}],498:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":479,"./forOwn":500}],499:[function(require,module,exports){
arguments[4][390][0].apply(exports,arguments)
},{"./hasOwn":501,"dup":390}],500:[function(require,module,exports){
arguments[4][391][0].apply(exports,arguments)
},{"./forIn":499,"./hasOwn":501,"dup":391}],501:[function(require,module,exports){
arguments[4][392][0].apply(exports,arguments)
},{"dup":392}],502:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":500}],503:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":483,"../lang/isObject":489,"./hasOwn":501}],504:[function(require,module,exports){
arguments[4][393][0].apply(exports,arguments)
},{"./forOwn":500,"dup":393}],505:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":475}],506:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],507:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":493}],508:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":493,"./WHITE_SPACES":506}],509:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":493,"./WHITE_SPACES":506}],510:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":493,"./WHITE_SPACES":506,"./ltrim":508,"./rtrim":509}],511:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],512:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],513:[function(require,module,exports){
(function (process,global){
/*
defer
*/"use strict"

var kindOf  = require("mout/lang/kindOf"),
    now     = require("mout/time/now"),
    forEach = require("mout/array/forEach"),
    indexOf = require("mout/array/indexOf")

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
}

var push = function(collection, callback, context, defer){

    var iterator = function(){
        iterate(collection)
    }

    if (!collection.length) defer(iterator)

    var entry = {
        callback: callback,
        context: context
    }

    collection.push(entry)

    return function(){
        var io = indexOf(collection, entry)
        if (io > -1) collection.splice(io, 1)
    }
}

var iterate = function(collection){
    var time = now()

    forEach(collection.splice(0), function(entry) {
        entry.callback.call(entry.context, time)
    })
}

var defer = function(callback, argument, context){
    return (kindOf(argument) === "Number") ? defer.timeout(callback, argument, context) : defer.immediate(callback, argument)
}

if (global.process && process.nextTick){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, process.nextTick)
    }

} else if (global.setImmediate){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, setImmediate)
    }

} else if (global.postMessage && global.addEventListener){

    addEventListener("message", function(event){
        if (event.source === global && event.data === "@deferred"){
            event.stopPropagation()
            iterate(callbacks.immediate)
        }
    }, true)

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(){
            postMessage("@deferred", "*")
        })
    }

} else {

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(iterator){
            setTimeout(iterator, 0)
        })
    }

}

var requestAnimationFrame = global.requestAnimationFrame ||
    global.webkitRequestAnimationFrame ||
    global.mozRequestAnimationFrame ||
    global.oRequestAnimationFrame ||
    global.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 1e3 / 60)
    }

defer.frame = function(callback, context){
    return push(callbacks.frame, callback, context, requestAnimationFrame)
}

var clear

defer.timeout = function(callback, ms, context){
    var ct = callbacks.timeout

    if (!clear) clear = defer.immediate(function(){
        clear = null
        callbacks.timeout = {}
    })

    return push(ct[ms] || (ct[ms] = []), callback, context, function(iterator){
        setTimeout(iterator, ms)
    })
}

module.exports = defer

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":517,"mout/array/forEach":470,"mout/array/indexOf":471,"mout/lang/kindOf":492,"mout/time/now":511}],514:[function(require,module,exports){
/*
Emitter
*/"use strict"

var indexOf = require("mout/array/indexOf"),
    forEach = require("mout/array/forEach")

var prime = require("./index"),
    defer = require("./defer")

var slice = Array.prototype.slice;

var Emitter = prime({

    constructor: function(stoppable){
        this._stoppable = stoppable
    },

    on: function(event, fn){
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = [])

        if (indexOf(events, fn) === -1) events.push(fn)

        return this
    },

    off: function(event, fn){
        var listeners = this._listeners, events
        if (listeners && (events = listeners[event])){

            var io = indexOf(events, fn)
            if (io > -1) events.splice(io, 1)
            if (!events.length) delete listeners[event];
            for (var l in listeners) return this
            delete this._listeners
        }
        return this
    },

    emit: function(event){
        var self = this,
            args = slice.call(arguments, 1)

        var emit = function(){
            var listeners = self._listeners, events
            if (listeners && (events = listeners[event])){
                forEach(events.slice(0), function(event){
                    var result = event.apply(self, args)
                    if (self._stoppable) return result
                })
            }
        }

        if (args[args.length - 1] === Emitter.EMIT_SYNC){
            args.pop()
            emit()
        } else {
            defer(emit)
        }

        return this
    }

})

Emitter.EMIT_SYNC = {}

module.exports = Emitter

},{"./defer":513,"./index":515,"mout/array/forEach":470,"mout/array/indexOf":471}],515:[function(require,module,exports){
arguments[4][395][0].apply(exports,arguments)
},{"dup":395,"mout/lang/createObject":482,"mout/lang/kindOf":492,"mout/object/hasOwn":501,"mout/object/mixIn":504}],516:[function(require,module,exports){
/*
Map
*/"use strict"

var indexOf = require("mout/array/indexOf")

var prime = require("./index")

var Map = prime({

    constructor: function Map(){
        this.length = 0
        this._values = []
        this._keys = []
    },

    set: function(key, value){
        var index = indexOf(this._keys, key)

        if (index === -1){
            this._keys.push(key)
            this._values.push(value)
            this.length++
        } else {
            this._values[index] = value
        }

        return this
    },

    get: function(key){
        var index = indexOf(this._keys, key)
        return (index === -1) ? null : this._values[index]
    },

    count: function(){
        return this.length
    },

    forEach: function(method, context){
        for (var i = 0, l = this.length; i < l; i++){
            if (method.call(context, this._values[i], this._keys[i], this) === false) break
        }
        return this
    },

    map: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            results.set(key, method.call(context, value, key, this))
        }, this)
        return results
    },

    filter: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) results.set(key, value)
        }, this)
        return results
    },

    every: function(method, context){
        var every = true
        this.forEach(function(value, key){
            if (!method.call(context, value, key, this)) return (every = false)
        }, this)
        return every
    },

    some: function(method, context){
        var some = false
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) return !(some = true)
        }, this)
        return some
    },

    indexOf: function(value){
        var index = indexOf(this._values, value)
        return (index > -1) ? this._keys[index] : null
    },

    remove: function(value){
        var index = indexOf(this._values, value)

        if (index !== -1){
            this._values.splice(index, 1)
            this.length--
            return this._keys.splice(index, 1)[0]
        }

        return null
    },

    unset: function(key){
        var index = indexOf(this._keys, key)

        if (index !== -1){
            this._keys.splice(index, 1)
            this.length--
            return this._values.splice(index, 1)[0]
        }

        return null
    },

    keys: function(){
        return this._keys.slice()
    },

    values: function(){
        return this._values.slice()
    }

})

var map = function(){
    return new Map
}

map.prototype = Map.prototype

module.exports = map

},{"./index":515,"mout/array/indexOf":471}],517:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],518:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _dispatchable = require('./internal/_dispatchable');
var _xall = require('./internal/_xall');


/**
 * Returns `true` if all elements of the list match the predicate, `false` if there are any
 * that don't.
 *
 * Acts as a transducer if a transformer is given in list position.
 * @see R.transduce
 *
 * @func
 * @memberOf R
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none
 * @example
 *
 *      var lessThan2 = R.flip(R.lt)(2);
 *      var lessThan3 = R.flip(R.lt)(3);
 *      R.all(lessThan2)([1, 2]); //=> false
 *      R.all(lessThan3)([1, 2]); //=> true
 */
module.exports = _curry2(_dispatchable('all', _xall, function all(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));

},{"./internal/_curry2":525,"./internal/_dispatchable":526,"./internal/_xall":536}],519:[function(require,module,exports){
var _contains = require('./internal/_contains');
var _curry2 = require('./internal/_curry2');


/**
 * Returns `true` if the specified value is equal, in `R.equals` terms,
 * to at least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the item is in the list, `false` otherwise.
 *
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains([42], [[42]]); //=> true
 */
module.exports = _curry2(_contains);

},{"./internal/_contains":523,"./internal/_curry2":525}],520:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _equals = require('./internal/_equals');
var _hasMethod = require('./internal/_hasMethod');


/**
 * Returns `true` if its arguments are equivalent, `false` otherwise.
 * Dispatches to an `equals` method if present. Handles cyclical data
 * structures.
 *
 * @func
 * @memberOf R
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
module.exports = _curry2(function equals(a, b) {
  return _hasMethod('equals', a) ? a.equals(b) :
         _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
});

},{"./internal/_curry2":525,"./internal/_equals":527,"./internal/_hasMethod":529}],521:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _has = require('./internal/_has');


/**
 * Returns whether or not an object has an own property with
 * the specified name
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      var hasName = R.has('name');
 *      hasName({name: 'alice'});   //=> true
 *      hasName({name: 'bob'});     //=> true
 *      hasName({});                //=> false
 *
 *      var point = {x: 0, y: 0};
 *      var pointHas = R.has(R.__, point);
 *      pointHas('x');  //=> true
 *      pointHas('y');  //=> true
 *      pointHas('z');  //=> false
 */
module.exports = _curry2(_has);

},{"./internal/_curry2":525,"./internal/_has":528}],522:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
module.exports = _curry2(function identical(a, b) {
  // SameValue algorithm
  if (a === b) { // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});

},{"./internal/_curry2":525}],523:[function(require,module,exports){
var _indexOf = require('./_indexOf');


module.exports = function _contains(a, list) {
  return _indexOf(list, a, 0) >= 0;
};

},{"./_indexOf":530}],524:[function(require,module,exports){
/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0) {
      return f1;
    } else if (a != null && a['@@functional/placeholder'] === true) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

},{}],525:[function(require,module,exports){
var _curry1 = require('./_curry1');


/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry2(fn) {
  return function f2(a, b) {
    var n = arguments.length;
    if (n === 0) {
      return f2;
    } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
      return f2;
    } else if (n === 1) {
      return _curry1(function(b) { return fn(a, b); });
    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true &&
                          b != null && b['@@functional/placeholder'] === true) {
      return f2;
    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
      return _curry1(function(a) { return fn(a, b); });
    } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
      return _curry1(function(b) { return fn(a, b); });
    } else {
      return fn(a, b);
    }
  };
};

},{"./_curry1":524}],526:[function(require,module,exports){
var _isArray = require('./_isArray');
var _isTransformer = require('./_isTransformer');
var _slice = require('./_slice');


/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a  function with [methodname], it will execute that
 * function (functor case). Otherwise, if it is a transformer, uses transducer
 * [xf] to return a new transformer (transducer case). Otherwise, it will
 * default to executing [fn].
 *
 * @private
 * @param {String} methodname property to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
module.exports = function _dispatchable(methodname, xf, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    if (!_isArray(obj)) {
      var args = _slice(arguments, 0, length - 1);
      if (typeof obj[methodname] === 'function') {
        return obj[methodname].apply(obj, args);
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
};

},{"./_isArray":531,"./_isTransformer":532,"./_slice":535}],527:[function(require,module,exports){
var _has = require('./_has');
var identical = require('../identical');
var keys = require('../keys');
var type = require('../type');

// The algorithm used to handle cyclic structures is
// inspired by underscore's isEqual
module.exports = function _equals(a, b, stackA, stackB) {
  var typeA = type(a);
  if (typeA !== type(b)) {
    return false;
  }

  if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
    return typeof a === 'object' ?
      typeof b === 'object' && identical(a.valueOf(), b.valueOf()) :
      identical(a, b);
  }

  if (identical(a, b)) {
    return true;
  }

  if (typeA === 'RegExp') {
    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
    return (a.source === b.source) &&
           (a.global === b.global) &&
           (a.ignoreCase === b.ignoreCase) &&
           (a.multiline === b.multiline) &&
           (a.sticky === b.sticky) &&
           (a.unicode === b.unicode);
  }

  if (Object(a) === a) {
    if (typeA === 'Date' && a.getTime() !== b.getTime()) {
      return false;
    }

    var keysA = keys(a);
    if (keysA.length !== keys(b).length) {
      return false;
    }

    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }

    stackA[stackA.length] = a;
    stackB[stackB.length] = b;
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
        return false;
      }
      idx -= 1;
    }
    stackA.pop();
    stackB.pop();
    return true;
  }
  return false;
};

},{"../identical":522,"../keys":539,"../type":543,"./_has":528}],528:[function(require,module,exports){
module.exports = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

},{}],529:[function(require,module,exports){
var _isArray = require('./_isArray');


/**
 * Private function that determines whether or not a provided object has a given method.
 * Does not ignore methods stored on the object's prototype chain. Used for dynamically
 * dispatching Ramda methods to non-Array objects.
 *
 * @private
 * @param {String} methodName The name of the method to check for.
 * @param {Object} obj The object to test.
 * @return {Boolean} `true` has a given method, `false` otherwise.
 * @example
 *
 *      var person = { name: 'John' };
 *      person.shout = function() { alert(this.name); };
 *
 *      _hasMethod('shout', person); //=> true
 *      _hasMethod('foo', person); //=> false
 */
module.exports = function _hasMethod(methodName, obj) {
  return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
};

},{"./_isArray":531}],530:[function(require,module,exports){
var equals = require('../equals');


module.exports = function _indexOf(list, item, from) {
  var idx = from;
  while (idx < list.length) {
    if (equals(list[idx], item)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
};

},{"../equals":520}],531:[function(require,module,exports){
/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]');
};

},{}],532:[function(require,module,exports){
module.exports = function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

},{}],533:[function(require,module,exports){
module.exports = function _map(fn, list) {
  var idx = 0, len = list.length, result = Array(len);
  while (idx < len) {
    result[idx] = fn(list[idx]);
    idx += 1;
  }
  return result;
};

},{}],534:[function(require,module,exports){
module.exports = function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x :
    {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
};

},{}],535:[function(require,module,exports){
/**
 * An optimized, private array `slice` implementation.
 *
 * @private
 * @param {Arguments|Array} args The array or arguments object to consider.
 * @param {Number} [from=0] The array index to slice from, inclusive.
 * @param {Number} [to=args.length] The array index to slice to, exclusive.
 * @return {Array} A new, sliced array.
 * @example
 *
 *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
 *
 *      var firstThreeArgs = function(a, b, c, d) {
 *        return _slice(arguments, 0, 3);
 *      };
 *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
 */
module.exports = function _slice(args, from, to) {
  switch (arguments.length) {
    case 1: return _slice(args, 0, args.length);
    case 2: return _slice(args, from, args.length);
    default:
      var list = [];
      var idx = 0;
      var len = Math.max(0, Math.min(args.length, to) - from);
      while (idx < len) {
        list[idx] = args[from + idx];
        idx += 1;
      }
      return list;
  }
};

},{}],536:[function(require,module,exports){
var _curry2 = require('./_curry2');
var _reduced = require('./_reduced');
var _xfBase = require('./_xfBase');


module.exports = (function() {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }
  XAll.prototype['@@transducer/init'] = _xfBase.init;
  XAll.prototype['@@transducer/result'] = function(result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAll.prototype['@@transducer/step'] = function(result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf['@@transducer/step'](result, false));
    }
    return result;
  };

  return _curry2(function _xall(f, xf) { return new XAll(f, xf); });
})();

},{"./_curry2":525,"./_reduced":534,"./_xfBase":537}],537:[function(require,module,exports){
module.exports = {
  init: function() {
    return this.xf['@@transducer/init']();
  },
  result: function(result) {
    return this.xf['@@transducer/result'](result);
  }
};

},{}],538:[function(require,module,exports){
var _curry2 = require('./_curry2');
var _xfBase = require('./_xfBase');


module.exports = (function() {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;
  XMap.prototype['@@transducer/step'] = function(result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return _curry2(function _xmap(f, xf) { return new XMap(f, xf); });
})();

},{"./_curry2":525,"./_xfBase":537}],539:[function(require,module,exports){
var _curry1 = require('./internal/_curry1');
var _has = require('./internal/_has');


/**
 * Returns a list containing the names of all the enumerable own
 * properties of the supplied object.
 * Note that the order of the output array is not guaranteed to be
 * consistent across different JS platforms.
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
module.exports = (function() {
  // cover IE < 9 keys issues
  var hasEnumBug = !({toString: null}).propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString',
                            'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  return typeof Object.keys === 'function' ?
    _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, ks = [], nIdx;
      for (prop in obj) {
        if (_has(prop, obj)) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
}());

},{"./internal/_curry1":524,"./internal/_has":528}],540:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _dispatchable = require('./internal/_dispatchable');
var _map = require('./internal/_map');
var _xmap = require('./internal/_xmap');


/**
 * Returns a new list, constructed by applying the supplied function to every element of the
 * supplied list.
 *
 * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
 * native `Array.prototype.map` method. For more details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
 *
 * Acts as a transducer if a transformer is given in list position.
 * @see R.transduce
 *
 * @func
 * @memberOf R
 * @category List
 * @sig (a -> b) -> [a] -> [b]
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @example
 *
 *      var double = function(x) {
 *        return x * 2;
 *      };
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 */
module.exports = _curry2(_dispatchable('map', _xmap, _map));

},{"./internal/_curry2":525,"./internal/_dispatchable":526,"./internal/_map":533,"./internal/_xmap":538}],541:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var map = require('./map');
var prop = require('./prop');


/**
 * Returns a new list by plucking the same named property off all objects in the list supplied.
 *
 * @func
 * @memberOf R
 * @category List
 * @sig k -> [{k: v}] -> [v]
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} list The array to consider.
 * @return {Array} The list of values for the given key.
 * @example
 *
 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
 */
module.exports = _curry2(function pluck(p, list) {
  return map(prop(p), list);
});

},{"./internal/_curry2":525,"./map":540,"./prop":542}],542:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');


/**
 * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */
module.exports = _curry2(function prop(p, obj) { return obj[p]; });

},{"./internal/_curry2":525}],543:[function(require,module,exports){
var _curry1 = require('./internal/_curry1');


/**
 * Gives a single-word string description of the (native) type of a value, returning such
 * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
 * Object types any further, reporting them all as 'Object'.
 *
 * @func
 * @memberOf R
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 */
module.exports = _curry1(function type(val) {
  return val === null      ? 'Null'      :
         val === undefined ? 'Undefined' :
         Object.prototype.toString.call(val).slice(8, -1);
});

},{"./internal/_curry1":524}],544:[function(require,module,exports){
(function(){var g={};
(function(window){var k,aa=this;function p(a,b){var c=a.split("."),d=aa;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d[e]?d=d[e]:d=d[e]={}:d[e]=b}function q(a,b){function c(){}c.prototype=b.prototype;a.Yb=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Xb=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};/*

 Copyright 2015 Google Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
function ba(){};function ca(a){var b=console[a];b?b.bind||(console[a]=function(){b.apply(console,arguments)}):console[a]=function(){}}ca("error");ca("warn");ca("info");ca("log");ca("debug");function da(a){ea[a]={na:fa(),end:NaN}}function ga(a){if(a=ea[a])a.end=fa()}function ha(a){return(a=ea[a])&&a.end?a.end-a.na:NaN}var fa=window.performance&&window.performance.now?window.performance.now.bind(window.performance):Date.now,ea={};function ia(a,b,c){this.id=a;this.bandwidth=b||0;this.lang=c||"unknown";this.active=!1}p("shaka.player.AudioTrack.compare",function(a,b){return a.lang<b.lang?-1:a.lang>b.lang?1:a.bandwidth<b.bandwidth?-1:a.bandwidth>b.bandwidth?1:0});function ja(){this.minBandwidth=this.maxBandwidth=this.maxWidth=this.minHeight=this.maxHeight=null}ja.prototype.clone=function(){var a=new ja;a.maxHeight=this.maxHeight;a.minHeight=this.minHeight;a.maxWidth=this.maxWidth;a.maxBandwidth=this.maxBandwidth;a.minBandwidth=this.minBandwidth;return a};function r(){this.fontSize="100%";this.fontColor=ka;this.fontOpacity=la;this.backgroundColor=ma;this.backgroundOpacity=la;this.fontEdge=na}p("shaka.player.TextStyle",r);r.prototype.a=function(){var a=window.localStorage.getItem("ShakaPlayerTextStyle");if(a){var b;try{b=JSON.parse(a)}catch(c){return}if(b&&"object"==typeof b){var a=b,d;for(d in a)d in this&&(this[d]=a[d])}}};r.prototype.load=r.prototype.a;r.prototype.b=function(){window.localStorage.setItem("ShakaPlayerTextStyle",JSON.stringify(this))};
r.prototype.store=r.prototype.b;function oa(a){var b=[];b.push("font-size: "+a.fontSize);b.push("color: "+pa(a.fontColor,a.fontOpacity));b.push("background-color: "+pa(a.backgroundColor,a.backgroundOpacity));for(var c=[],d=0;d<a.fontEdge.length;++d){var e=a.fontEdge[d].slice(3,6);c.push(pa(a.fontEdge[d].slice(0,3),a.fontOpacity)+" "+e.join("px ")+"px")}b.push("text-shadow: "+c.join(","));return b.join("; ")}function pa(a,b){return"rgba("+a.concat(b).join(",")+")"}var ka=[255,255,255],ma=[0,0,0];
r.StandardColors={WHITE:ka,BLACK:ma,RED:[255,0,0],GREEN:[0,255,0],BLUE:[0,0,255],YELLOW:[255,255,0],MAGENTA:[255,0,255],CYAN:[0,255,255]};var la=1;r.StandardOpacities={OPAQUE:la,SEMI_HIGH:.75,SEMI_LOW:.25,TRANSPARENT:0};var na=[];
r.EdgeStyles={NONE:na,RAISED:[[34,34,34,1,1,0],[34,34,34,2,2,0],[34,34,34,3,3,0]],DEPRESSED:[[204,204,204,1,1,0],[204,204,204,0,1,0],[34,34,34,-1,-1,0],[34,34,34,0,-1,0]],UNIFORM:[[34,34,34,0,0,4],[34,34,34,0,0,4],[34,34,34,0,0,4],[34,34,34,0,0,4]],DROP:[[34,34,34,2,2,3],[34,34,34,2,2,4],[34,34,34,2,2,5]]};function qa(a,b){this.id=a;this.lang=b||"unknown";this.enabled=this.active=!1}p("shaka.player.TextTrack.compare",function(a,b){return a.lang<b.lang?-1:a.lang>b.lang?1:0});function ra(a,b,c,d){this.id=a;this.bandwidth=b||0;this.width=c||0;this.height=d||0;this.active=!1}function sa(a,b){var c=a.width*a.height,d=b.width*b.height;return c<d?-1:c>d?1:a.bandwidth<b.bandwidth?-1:a.bandwidth>b.bandwidth?1:0}p("shaka.player.VideoTrack.compare",sa);function ta(){var a="CustomEvent"in window;if(a)try{new CustomEvent("")}catch(b){a=!1}a||(window.CustomEvent=ua)}p("shaka.polyfill.CustomEvent.install",ta);function ua(a,b){var c=document.createEvent("CustomEvent"),d=b||{bubbles:!1,cancelable:!1,detail:null};c.initCustomEvent(a,!!d.bubbles,!!d.cancelable,d.detail);return c};function va(){var a=Element.prototype;a.requestFullscreen=a.requestFullscreen||a.mozRequestFullScreen||a.msRequestFullscreen||a.webkitRequestFullscreen;a=Document.prototype;a.exitFullscreen=a.exitFullscreen||a.mozCancelFullScreen||a.msExitFullscreen||a.webkitExitFullscreen;"fullscreenElement"in document||Object.defineProperty(document,"fullscreenElement",{get:function(){return document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement}});document.addEventListener("webkitfullscreenchange",
xa);document.addEventListener("webkitfullscreenerror",xa);document.addEventListener("mozfullscreenchange",xa);document.addEventListener("mozfullscreenerror",xa);document.addEventListener("MSFullscreenChange",xa);document.addEventListener("MSFullscreenError",xa)}p("shaka.polyfill.Fullscreen.install",va);function xa(a){var b=a.type.replace(/^(webkit|moz|MS)/,"").toLowerCase(),b=new Event(b,a);a.target.dispatchEvent(b)};function ya(){return Promise.reject(Error("The key system specified is not supported."))}function za(a){return null==a?Promise.resolve():Promise.reject(Error("MediaKeys not supported."))}function Aa(){throw new TypeError("Illegal constructor.");}Aa.prototype.createSession=function(){};Aa.prototype.setServerCertificate=function(){};function Ba(){throw new TypeError("Illegal constructor.");}Ba.prototype.getConfiguration=function(){};Ba.prototype.createMediaKeys=function(){};function u(a){this.c=[];this.b=[];this.ba=Ca;if(a)try{a(this.W.bind(this),this.a.bind(this))}catch(b){this.a(b)}}var Ca=0;function Da(){window.Promise||(window.Promise=u,window.Promise.resolve=Ea,window.Promise.reject=Fa,window.Promise.all=Ga,window.Promise.race=Ha,window.setImmediate?(Ja=function(a){return window.setImmediate(a)},Ka=function(a){return window.clearImmediate(a)}):(Ja=function(a){return window.setTimeout(a,0)},Ka=function(a){return window.clearTimeout(a)}))}
p("shaka.polyfill.Promise.install",Da);function Ea(a){var b=new u;b.W(a);return b}function Fa(a){var b=new u;b.a(a);return b}function Ga(a){function b(a,b,c){a.ba==Ca&&(e[b]=c,d++,d==e.length&&a.W(e))}var c=new u;if(!a.length)return c.W([]),c;for(var d=0,e=Array(a.length),f=c.a.bind(c),g=0;g<a.length;++g)a[g]&&a[g].then?a[g].then(b.bind(null,c,g),f):b(c,g,a[g]);return c}function Ha(a){for(var b=new u,c=b.W.bind(b),d=b.a.bind(b),e=0;e<a.length;++e)a[e]&&a[e].then?a[e].then(c,d):c(a[e]);return b}
u.prototype.then=function(a,b){var c=new u;switch(this.ba){case 1:La(this,c,a);break;case 2:La(this,c,b);break;case Ca:this.c.push({Ia:c,Ba:a}),this.b.push({Ia:c,Ba:b})}return c};u.prototype.then=u.prototype.then;u.prototype.catch=function(a){return this.then(void 0,a)};u.prototype["catch"]=u.prototype.catch;u.prototype.W=function(a){if(this.ba==Ca){this.wa=a;this.ba=1;for(a=0;a<this.c.length;++a)La(this,this.c[a].Ia,this.c[a].Ba);this.c=[];this.b=[]}};
u.prototype.a=function(a){if(this.ba==Ca){this.wa=a;this.ba=2;for(a=0;a<this.b.length;++a)La(this,this.b[a].Ia,this.b[a].Ba);this.c=[];this.b=[]}};function La(a,b,c){Ma.push(function(){if(c&&"function"==typeof c){try{var a=c(this.wa)}catch(e){b.a(e);return}a instanceof u?a==b?b.a(new TypeError("Chaining cycle detected")):a.then(b.W.bind(b),b.a.bind(b)):b.W(a)}else 1==this.ba?b.W(this.wa):b.a(this.wa)}.bind(a));null==Na&&(Na=Ja(Oa))}
function Oa(){for(;Ma.length;){null!=Na&&(Ka(Na),Na=null);var a=Ma;Ma=[];for(var b=0;b<a.length;++b)a[b]()}}function Ja(){return 0}function Ka(){}var Na=null,Ma=[];function Pa(){var a=HTMLVideoElement.prototype;!a.getVideoPlaybackQuality&&"webkitDroppedFrameCount"in a&&(a.getVideoPlaybackQuality=Qa)}p("shaka.polyfill.VideoPlaybackQuality.install",Pa);function Qa(){return{droppedVideoFrames:this.webkitDroppedFrameCount,totalVideoFrames:this.webkitDecodedFrameCount,corruptedVideoFrames:0,creationTime:NaN,totalFrameDelay:0}};function Ra(a,b){for(var c=[],d=0;d<a.length;++d){for(var e=!1,f=0;f<c.length&&!(e=b?b(a[d],c[f]):a[d]===c[f]);++f);e||c.push(a[d])}return c};function v(){return Date.now()+Sa}var Sa=0;function Ta(a){this.b=a;this.c=0==Ua;this.a=0}var Ua=1;function Va(a){return a.a<a.b.byteLength}function Wa(a){var b=a.b.getUint8(a.a);a.a+=1;return b}function w(a){var b=a.b.getUint32(a.a,a.c);a.a+=4;return b}function Xa(a){var b,c;a.c?(b=a.b.getUint32(a.a,!0),c=a.b.getUint32(a.a+4,!0)):(c=a.b.getUint32(a.a,!1),b=a.b.getUint32(a.a+4,!1));if(2097151<c)throw new RangeError("DataViewReader: Overflow reading 64-bit value.");a.a+=8;return c*Math.pow(2,32)+b}
function Ya(a){if(a.a+16>a.b.byteLength)throw new RangeError("DataViewReader: Read past end of DataView.");var b=new Uint8Array(a.b.buffer,a.a,16);a.a+=16;return b}function Za(a,b){if(a.a+b>a.b.byteLength)throw new RangeError("DataViewReader: Skip past end of DataView.");a.a+=b};function $a(a){this.b=a;this.a=new Ta(a);ab||(ab=[new Uint8Array([255]),new Uint8Array([127,255]),new Uint8Array([63,255,255]),new Uint8Array([31,255,255,255]),new Uint8Array([15,255,255,255,255]),new Uint8Array([7,255,255,255,255,255]),new Uint8Array([3,255,255,255,255,255,255]),new Uint8Array([1,255,255,255,255,255,255,255])])}var ab;
function bb(a){var b;b=cb(a);if(7<b.length)throw new RangeError("EbmlParser: EBML ID must be at most 7 bytes.");for(var c=0,d=0;d<b.length;d++)c=256*c+b[d];b=c;c=cb(a);a:{for(d=0;d<ab.length;d++)if(db(c,ab[d])){d=!0;break a}d=!1}if(d)c=a.b.byteLength-a.a.a;else{if(8==c.length&&c[1]&224)throw new RangeError("EbmlParser: Variable sized integer value must be at most 53 bits.");for(var d=c[0]&(1<<8-c.length)-1,e=1;e<c.length;e++)d=256*d+c[e];c=d}c=a.a.a+c<=a.b.byteLength?c:a.b.byteLength-a.a.a;d=new DataView(a.b.buffer,
a.b.byteOffset+a.a.a,c);Za(a.a,c);return new eb(b,d)}function cb(a){var b=Wa(a.a),c;for(c=1;8>=c&&!(b&1<<8-c);c++);if(8<c)throw new RangeError("EbmlParser: Variable sized integer must fit within 8 bytes.");var d=new Uint8Array(c);d[0]=b;for(b=1;b<c;b++)d[b]=Wa(a.a);return d}function eb(a,b){this.id=a;this.a=b}
function fb(a){if(8<a.a.byteLength)throw new RangeError("EbmlElement: Unsigned integer has too many bytes.");if(8==a.a.byteLength&&a.a.getUint8(0)&224)throw new RangeError("EbmlParser: Unsigned integer must be at most 53 bits.");for(var b=0,c=0;c<a.a.byteLength;c++)var d=a.a.getUint8(c),b=256*b+d;return b};var gb={"output-restricted":"The required output protection is not available.","output-not-allowed":"The required output protection is not available.",expired:"The decryption key has expired.","internal-error":"The key system has encountered an unspecified error."};function hb(a){this.c=Math.exp(Math.log(.5)/a);this.a=this.b=0}hb.prototype.sample=function(a,b){var c=Math.pow(this.c,a);this.b=b*(1-c)+c*this.b;this.a+=a};function ib(a){return a.b/(1-Math.pow(a.c,a.a))};function x(a){var b=new CustomEvent(a.type,{detail:a.detail,bubbles:!!a.bubbles}),c;for(c in a)c in b||(b[c]=a[c]);return b}function y(a){return new CustomEvent("error",{detail:a,bubbles:!0})};function jb(a,b,c){kb(b);kb(c);return c==b||a>=lb&&c==b.split("-")[0]||a>=mb&&c.split("-")[0]==b.split("-")[0]?!0:!1}var lb=1,mb=2;function kb(a){a=a.toLowerCase().split("-");var b=nb[a[0]];b&&(a[0]=b);return a.join("-")}
var nb={aar:"aa",abk:"ab",afr:"af",aka:"ak",alb:"sq",amh:"am",ara:"ar",arg:"an",arm:"hy",asm:"as",ava:"av",ave:"ae",aym:"ay",aze:"az",bak:"ba",bam:"bm",baq:"eu",bel:"be",ben:"bn",bih:"bh",bis:"bi",bod:"bo",bos:"bs",bre:"br",bul:"bg",bur:"my",cat:"ca",ces:"cs",cha:"ch",che:"ce",chi:"zh",chu:"cu",chv:"cv",cor:"kw",cos:"co",cre:"cr",cym:"cy",cze:"cs",dan:"da",deu:"de",div:"dv",dut:"nl",dzo:"dz",ell:"el",eng:"en",epo:"eo",est:"et",eus:"eu",ewe:"ee",fao:"fo",fas:"fa",fij:"fj",fin:"fi",fra:"fr",fre:"fr",
fry:"fy",ful:"ff",geo:"ka",ger:"de",gla:"gd",gle:"ga",glg:"gl",glv:"gv",gre:"el",grn:"gn",guj:"gu",hat:"ht",hau:"ha",heb:"he",her:"hz",hin:"hi",hmo:"ho",hrv:"hr",hun:"hu",hye:"hy",ibo:"ig",ice:"is",ido:"io",iii:"ii",iku:"iu",ile:"ie",ina:"ia",ind:"id",ipk:"ik",isl:"is",ita:"it",jav:"jv",jpn:"ja",kal:"kl",kan:"kn",kas:"ks",kat:"ka",kau:"kr",kaz:"kk",khm:"km",kik:"ki",kin:"rw",kir:"ky",kom:"kv",kon:"kg",kor:"ko",kua:"kj",kur:"ku",lao:"lo",lat:"la",lav:"lv",lim:"li",lin:"ln",lit:"lt",ltz:"lb",lub:"lu",
lug:"lg",mac:"mk",mah:"mh",mal:"ml",mao:"mi",mar:"mr",may:"ms",mkd:"mk",mlg:"mg",mlt:"mt",mon:"mn",mri:"mi",msa:"ms",mya:"my",nau:"na",nav:"nv",nbl:"nr",nde:"nd",ndo:"ng",nep:"ne",nld:"nl",nno:"nn",nob:"nb",nor:"no",nya:"ny",oci:"oc",oji:"oj",ori:"or",orm:"om",oss:"os",pan:"pa",per:"fa",pli:"pi",pol:"pl",por:"pt",pus:"ps",que:"qu",roh:"rm",ron:"ro",rum:"ro",run:"rn",rus:"ru",sag:"sg",san:"sa",sin:"si",slk:"sk",slo:"sk",slv:"sl",sme:"se",smo:"sm",sna:"sn",snd:"sd",som:"so",sot:"st",spa:"es",sqi:"sq",
srd:"sc",srp:"sr",ssw:"ss",sun:"su",swa:"sw",swe:"sv",tah:"ty",tam:"ta",tat:"tt",tel:"te",tgk:"tg",tgl:"tl",tha:"th",tib:"bo",tir:"ti",ton:"to",tsn:"tn",tso:"ts",tuk:"tk",tur:"tr",twi:"tw",uig:"ug",ukr:"uk",urd:"ur",uzb:"uz",ven:"ve",vie:"vi",vol:"vo",wel:"cy",wln:"wa",wol:"wo",xho:"xh",yid:"yi",yor:"yo",zha:"za",zho:"zh",zul:"zu"};function ob(a){return Object.keys(a).map(function(b){return a[b]})}function pb(a,b){return qb(a,b,"boolean")}function rb(a,b){var c=qb(a,b,"number");if(null==c)return null;if(isNaN(c)||c==Number.NEGATIVE_INFINITY||c==Number.POSITIVE_INFINITY)throw new RangeError("'"+b+"' must be finite.");if(0>c)throw new RangeError("'"+b+"' must be >= 0");return c}function sb(a,b){return qb(a,b,"string")}
function qb(a,b,c){a=a[b];if(null==a)return null;if(typeof a!=c)throw new TypeError("'"+b+"' must be a "+c+".");return a}function tb(a,b,c){a=a[b];if(null==a)return null;if(!(a instanceof c))throw new TypeError("'"+b+"' must be an instance of "+c.name+".");return a};function z(){this.a={}}z.prototype.push=function(a,b){this.a.hasOwnProperty(a)?this.a[a].push(b):this.a[a]=[b]};z.prototype.set=function(a,b){this.a[a]=b};z.prototype.get=function(a){return(a=this.a[a])?a.slice():null};function ub(a){var b=[],c;for(c in a.a)b.push.apply(b,a.a[c]);return b}function vb(a,b,c){if(a=a.a[b])for(b=0;b<a.length;++b)a[b]==c&&(a.splice(b,1),--b)}function wb(a){var b=[],c;for(c in a.a)b.push(c);return b};function B(){this.a=new z}B.prototype.destroy=function(){xb(this);this.a=null};function C(a,b,c,d){b=new yb(b,c,d);a.a.push(c,b)}B.prototype.sa=function(a,b){for(var c=this.a.get(b)||[],d=0;d<c.length;++d){var e=c[d];e.target==a&&(e.sa(),vb(this.a,b,e))}};function xb(a){for(var b=ub(a.a),c=0;c<b.length;++c)b[c].sa();a.a.a={}}function yb(a,b,c){this.target=a;this.type=b;this.a=c;this.target.addEventListener(b,c,!1)}
yb.prototype.sa=function(){this.target&&(this.target.removeEventListener(this.type,this.a,!1),this.a=this.target=null)};function D(a){this.ya=new z;this.v=a}p("shaka.util.FakeEventTarget",D);D.prototype.addEventListener=function(a,b,c){c||this.ya.push(a,b)};D.prototype.removeEventListener=function(a,b,c){c||vb(this.ya,a,b)};
D.prototype.dispatchEvent=function(a){a.hasOwnProperty("srcElement")||(delete a.srcElement,Object.defineProperty(a,"srcElement",{get:function(){return null}}));if(a.hasOwnProperty("target"))a.target=this;else{delete a.target;var b=this;Object.defineProperty(a,"target",{get:function(){return b},set:function(a){b=a}})}if(a.hasOwnProperty("currentTarget"))a.currentTarget=null;else{delete a.currentTarget;var c=null;Object.defineProperty(a,"currentTarget",{get:function(){return c},set:function(a){c=a}})}return zb(this,
a)};function zb(a,b){b.currentTarget=a;for(var c=a.ya.get(b.type)||[],d=0;d<c.length;++d){var e=c[d];try{e.handleEvent?e.handleEvent(b):e.call(a,b)}catch(f){}}a.v&&b.bubbles&&zb(a.v,b);return b.defaultPrevented};function Ab(){D.call(this,null);this.a=new hb(3);this.c=new hb(10);this.b=0}q(Ab,D);p("shaka.util.EWMABandwidthEstimator",Ab);Ab.prototype.sample=function(a,b){if(!(65536>b)){a=Math.max(a,50);var c=8E3*b/a,d=a/1E3;this.a.sample(d,c);this.c.sample(d,c);this.dispatchEvent(x({type:"bandwidth"}));this.b=Date.now()}};Ab.prototype.getBandwidth=function(){return.5>this.a.a?5E5:Math.min(ib(this.a),ib(this.c))};Ab.prototype.getDataAge=function(){return(Date.now()-this.b)/1E3};
Ab.prototype.supportsCaching=function(){return!1};function E(){var a,b,c=new Promise(function(c,e){a=c;b=e});c.resolve=a;c.reject=b;c.destroy=E.prototype.destroy;return c}E.prototype.destroy=function(){this.catch(function(){});var a=Error("Destroyed!");a.type="destroy";this.reject(a)};function Bb(a){return a.split("").reduce(function(a,c,d){return a+(d&&0==d%4?" "+c:c)})};function Cb(){this.g=new E;this.f=!1;this.a=null;this.b=[];this.c=null}function Db(a,b){if(a.f)throw Error("Cannot append to a running task!");a.b.push(b)}Cb.prototype.start=function(){if(this.f)throw Error("Task already started!");this.f=!0;this.b.unshift(function(){});Eb(this,void 0)};Cb.prototype.end=function(){this.b.splice(1)};
function Eb(a,b){var c=a.b[0](b),d;c?(d=c[0],a.c=c[1]):(d=Promise.resolve(),a.c=null);d.then(F(a,function(a){this.a?(this.b=[],this.c=null,Fb(this)):(this.b.shift(),this.b.length?Eb(this,a):(this.g.resolve(a),this.c=null))})).catch(F(a,function(a){this.b=[];this.c=null;this.a?Fb(this):this.g.reject(a)}))}function Fb(a){var b=Error("Task aborted.");b.type="aborted";a.g.reject(b);window.setTimeout(function(){this.a.resolve();this.a=null}.bind(a),5)};function F(a,b){return b.bind(a)};function Gb(a,b){D.call(this,b);this.a=null;this.h=a}q(Gb,D);
function Hb(a){if(!window.indexedDB)return a=Error("Persistant storage requires IndexedDB support."),a.type="storage",Promise.reject(a);if(a.a)return a=Error("A database connection is already open."),a.type="storage",Promise.reject(a);var b=new E,c=window.indexedDB.open("content_database",1);c.onupgradeneeded=F(a,function(a){this.a=a.target.result;Ib(this,"group_store",{keyPath:"group_id"});Ib(this,"stream_index_store",{keyPath:"stream_id"});a=Ib(this,"content_store",{autoIncrement:"true"});a.createIndex("segment",
["stream_id","segment_id"],{unique:!0});a.createIndex("stream","stream_id",{unique:!1})});c.onsuccess=F(a,function(a){this.a=a.target.result;b.resolve()});c.onerror=function(){b.reject(c.error)};return b}function Jb(a){a.a&&(a.a.close(),a.a=null)}function Ib(a,b,c){a.a.objectStoreNames.contains(b)&&a.a.deleteObjectStore(b);return a.a.createObjectStore(b,c)}function Kb(a){return Lb(a,"content_store")}function Mb(a){return Lb(a,"stream_index_store")}function Ob(a){return Lb(a,"group_store")}
function Lb(a,b){return a.a.transaction([b],a.h).objectStore(b)}function Pb(a,b){var c=new E,d=a.get(b);d.onerror=function(){c.reject(d.error)};d.onsuccess=function(){if(d.result)c.resolve(d.result);else{var a=Error("Item not found.");a.type="storage";c.reject(a)}};return c};function Qb(){Gb.call(this,"readonly",null)}q(Qb,Gb);function Rb(a){var b=new E,c=[],d=Ob(a).openCursor();d.onerror=function(){b.reject(d.error)};d.onsuccess=function(a){(a=a.target.result)?(c.push(a.key),a.continue()):b.resolve(c)};return b}
function Sb(a,b){return Pb(Ob(a),b).then(F(a,function(a){a.session_ids=Ra(a.session_ids);return a.hasOwnProperty("duration")||a.hasOwnProperty("key_system")?Promise.resolve(a):Tb(this,a.stream_ids[0]).then(function(b){a.duration=b.duration;a.key_system=b.key_system;a.license_server=b.license_server;a.with_credentials=b.with_credentials;a.distinctive_identifier=b.distinctive_identifier;a.audio_robustness=b.audio_robustness;a.video_robustness=b.video_robustness;return Promise.resolve(a)})}))}
function Tb(a,b){return Pb(Mb(a),b)}function Ub(a,b,c){return Pb(Kb(a).index("segment"),[b,c]).then(function(a){return Promise.resolve(a.content)})};function Vb(a,b,c){MediaSource.isTypeSupported(b);b=a.addSourceBuffer(b);this.i=a;this.c=b;this.l=c;this.j=new B;this.g=null;this.b=[];this.w=0;this.f=this.a=null;this.s=0;C(this.j,this.c,"updateend",this.B.bind(this))}var Wb=1/60;Vb.prototype.destroy=function(){Xb(this).catch(function(){});this.f&&this.f.destroy();this.a=this.f=null;this.g&&(Jb(this.g),this.g=null);this.b=null;this.j.destroy();this.i=this.c=this.j=null};
function Yb(a,b){for(var c=a.c.buffered,d=0;d<c.length;++d){var e=c.start(d)-Wb,f=c.end(d)+Wb;if(b>=e&&b<=f)return c.end(d)-b}return 0}
function Zb(a,b,c,d){if(a.a)return a=Error("Cannot fetch ("+a.v+"): previous operation not complete."),a.type="stream",Promise.reject(a);a.a=new Cb;c!=a.c.timestampOffset&&(a.c.timestampOffset=c);"idb"!=b.url.b[0].P||a.g||(a.g=new Qb,Db(a.a,function(){return[Hb(this.g)]}.bind(a)));d&&Db(a.a,function(){return[$b(this,d),this.h.bind(this)]}.bind(a));Db(a.a,function(){var a=b.a?b.a-b.b:1,c=new ac;c.a=3;c.h=1E3*a;c.c=1E3*this.s;c.i=this.g;return[bc(b.url,c,this.l),G.prototype.g.bind(b.url)]}.bind(a));
Db(a.a,F(a,function(a){this.l.getBandwidth();return[$b(this,a),this.h.bind(this)]}));var e=0==a.c.buffered.length&&0==a.b.length,f=null;Db(a.a,function(){if(0==this.c.buffered.length){var a=Error("Failed to buffer segment ("+this.v+").");a.type="stream";return[Promise.reject(a)]}e&&(a=b.b,f=this.c.buffered.start(0)-a);a=cc(this.b,b.b);0<=a?this.b.splice(a+1,0,b):this.b.push(b)}.bind(a));return dc(a).then(function(){return Promise.resolve(f)}.bind(a))}
function ec(a){if(a.a)return a=Error("Cannot clear ("+a.v+"): previous operation not complete."),a.type="stream",Promise.reject(a);a.a=new Cb;Db(a.a,function(){var a;a:if(0==this.c.buffered.length)a=Promise.resolve();else{try{this.c.remove(0,this.i.duration)}catch(c){a=Promise.reject(c);break a}this.b=[];a=this.f=new E}return[a,this.h.bind(this)]}.bind(a));return dc(a)}
function fc(a,b){if(a.a){var c=Error("Cannot clearAfter ("+a.v+"): previous operation not complete.");c.type="stream";return Promise.reject(c)}a.a=new Cb;Db(a.a,function(){return[gc(this,b),this.h.bind(this)]}.bind(a));return dc(a)}function Xb(a){a.a?(a=a.a,a.a?a=a.a:a.f?(a.c&&a.c(),a.a=new E,a=a.a):(a.f=!0,a=Promise.resolve())):a=Promise.resolve();return a}function dc(a){a.a.start();return a.a.g.then(F(a,function(){this.a=null})).catch(F(a,function(a){this.a=null;return Promise.reject(a)}))}
function $b(a,b){try{a.c.appendBuffer(b)}catch(c){return Promise.reject(c)}a.f=new E;return a.f}function gc(a,b){if(0==a.c.buffered.length)return Promise.resolve();var c=cc(a.b,b);if(-1==c||c==a.b.length-1)return Promise.resolve();try{a.c.remove(a.b[c+1].b,a.i.duration)}catch(d){return Promise.reject(d)}a.b=a.b.slice(0,c+1);a.f=new E;return a.f}Vb.prototype.h=function(){this.f&&"open"==this.i.readyState&&this.c.abort()};Vb.prototype.B=function(){this.f&&(this.f.resolve(),this.f=null)};function hc(a){return String.fromCharCode.apply(null,a)}p("shaka.util.Uint8ArrayUtils.toString",hc);function ic(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b}p("shaka.util.Uint8ArrayUtils.fromString",ic);p("shaka.util.Uint8ArrayUtils.toBase64",function(a,b){var c=void 0==b?!0:b,d=window.btoa(hc(a)).replace(/\+/g,"-").replace(/\//g,"_");return c?d:d.replace(/=*$/,"")});function jc(a){return ic(window.atob(a.replace(/-/g,"+").replace(/_/g,"/")))}
p("shaka.util.Uint8ArrayUtils.fromBase64",jc);p("shaka.util.Uint8ArrayUtils.fromHex",function(a){for(var b=new Uint8Array(a.length/2),c=0;c<a.length;c+=2)b[c/2]=window.parseInt(a.substr(c,2),16);return b});function kc(a){for(var b="",c=0;c<a.length;++c){var d=a[c].toString(16);1==d.length&&(d="0"+d);b+=d}return b}p("shaka.util.Uint8ArrayUtils.toHex",kc);function db(a,b){if(!a&&!b)return!0;if(!a||!b||a.length!=b.length)return!1;for(var c=0;c<a.length;++c)if(a[c]!=b[c])return!1;return!0};function lc(){this.h=this.a="";this.i=!1;this.s=this.l=null;this.v=this.g=!1;this.j=this.f="";this.c=null;this.b=[]}
function mc(a){var b=new lc;if(!a)return b;var c=sb(a,"keySystem");if(null!=c)b.a=c;else throw Error("'keySystem' cannot be null.");var d=sb(a,"licenseServerUrl");if(null!=d)b.h=d;else if(c)throw Error("For encrypted streaming content, 'licenseServerUrl' cannot be null or empty.");c=pb(a,"withCredentials");null!=c&&(b.i=c);c=tb(a,"licensePostProcessor",Function);null!=c&&(b.l=c);c=tb(a,"licensePreProcessor",Function);null!=c&&(b.s=c);c=pb(a,"distinctiveIdentifierRequired");null!=c&&(b.g=c);c=pb(a,
"persistentStateRequired");null!=c&&(b.v=c);c=sb(a,"audioRobustness");null!=c&&(b.f=c);c=sb(a,"videoRobustness");null!=c&&(b.j=c);c=tb(a,"serverCertificate",Uint8Array);null!=c&&(b.c=c);if(c=tb(a,"initData",Object)){a=tb(c,"initData",Uint8Array);if(null==a)throw Error("'initData.initData' cannot be null.");c=sb(c,"initDataType");if(null==c)throw Error("'initData.initDataType' cannot be null.");b.b.push({initData:new Uint8Array(a.buffer),initDataType:c})}return b}
function nc(a,b){var c=new lc;c.a=a.a;c.h=a.h;c.i=a.i;c.l=a.l;c.s=a.s;c.g=a.g;c.v=a.v;c.f=a.f;c.j=a.j;c.c=a.c?new Uint8Array(a.c.buffer):null;oc(c,a.b);oc(c,b.b);return c}function oc(a,b){var c=a.b.concat(b.map(function(a){return{initData:new Uint8Array(a.initData.buffer),initDataType:a.initDataType}}));a.b=Ra(c,pc)}function pc(a,b){return a.initDataType==b.initDataType&&db(a.initData,b.initData)};function qc(a,b){try{var c=new rc(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}function sc(a){var b=this.mediaKeys;b&&b!=a&&tc(b,null);delete this.mediaKeys;(this.mediaKeys=a)&&tc(a,this);return Promise.resolve()}
function rc(a,b){this.a=this.keySystem=a;var c=!0;"org.w3.clearkey"==a&&(this.a="webkit-org.w3.clearkey",c=!1);var d=!1,e;e=document.getElementsByTagName("video");e=e.length?e[0]:document.createElement("video");for(var f=0;f<b.length;++f){var g=b[f],h={audioCapabilities:[],videoCapabilities:[],persistentState:"optional",distinctiveIdentifier:"optional",initDataTypes:g.initDataTypes,sessionTypes:["temporary"]},l=!1;if(g.audioCapabilities)for(var m=0;m<g.audioCapabilities.length;++m){var n=g.audioCapabilities[m];
n.contentType&&(l=!0,e.canPlayType(n.contentType.split(";")[0],this.a)&&(h.audioCapabilities.push(n),d=!0))}if(g.videoCapabilities)for(m=0;m<g.videoCapabilities.length;++m)n=g.videoCapabilities[m],n.contentType&&(l=!0,e.canPlayType(n.contentType,this.a)&&(h.videoCapabilities.push(n),d=!0));l||(d=e.canPlayType("video/mp4",this.a)||e.canPlayType("video/webm",this.a));"required"==g.persistentState&&(c?(h.persistentState="required",h.sessionTypes=["persistent-license"]):d=!1);if(d){this.b=h;return}}c=
"Unsupported keySystem";if("org.w3.clearkey"==a||"com.widevine.alpha"==a)c="None of the requested configurations were supported.";c=Error(c);c.name="NotSupportedError";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}rc.prototype.createMediaKeys=function(){var a=new uc(this.a);return Promise.resolve(a)};rc.prototype.getConfiguration=function(){return this.b};function uc(a){this.g=a;this.b=null;this.a=new B;this.c=[];this.f={}}
function tc(a,b){a.b=b;xb(a.a);b&&(C(a.a,b,"webkitneedkey",a.Ob.bind(a)),C(a.a,b,"webkitkeymessage",a.Nb.bind(a)),C(a.a,b,"webkitkeyadded",a.Lb.bind(a)),C(a.a,b,"webkitkeyerror",a.Mb.bind(a)))}k=uc.prototype;k.createSession=function(a){var b=a||"temporary";if("temporary"!=b&&"persistent-license"!=b)throw new TypeError("Session type "+a+" is unsupported on this platform.");a=this.b||document.createElement("video");a.src||(a.src="about:blank");b=new vc(a,this.g,b);this.c.push(b);return b};
k.setServerCertificate=function(){return Promise.reject(Error("setServerCertificate not supported on this platform."))};k.Ob=function(a){a=x({type:"encrypted",initDataType:"webm",initData:a.initData});this.b.dispatchEvent(a)};k.Nb=function(a){var b=wc(this,a.sessionId);b&&(a=x({type:"message",messageType:void 0==b.keyStatuses.Fa()?"licenserequest":"licenserenewal",message:a.message}),b.b&&(b.b.resolve(),b.b=null),b.dispatchEvent(a))};
k.Lb=function(a){if(a=wc(this,a.sessionId))xc(a,"usable"),a.a&&a.a.resolve(),a.a=null};
k.Mb=function(a){var b=wc(this,a.sessionId);if(b){var c=Error("EME v0.1b key error");c.errorCode=a.errorCode;c.errorCode.systemCode=a.systemCode;!a.sessionId&&b.b?(c.method="generateRequest",45==a.systemCode&&(c.message="Unsupported session type."),b.b.reject(c),b.b=null):a.sessionId&&b.a?(c.method="update",b.a.reject(c),b.a=null):(c=a.systemCode,a.errorCode.code==MediaKeyError.MEDIA_KEYERR_OUTPUT?xc(b,"output-restricted"):1==c?xc(b,"expired"):xc(b,"internal-error"))}};
function wc(a,b){var c=a.f[b];return c?c:(c=a.c.shift())?(c.sessionId=b,a.f[b]=c):null}function vc(a,b,c){D.call(this,null);this.f=a;this.h=!1;this.a=this.b=null;this.c=b;this.g=c;this.sessionId="";this.expiration=NaN;this.closed=new E;this.keyStatuses=new yc}q(vc,D);
function zc(a,b,c){if(a.h)return Promise.reject(Error("The session is already initialized."));a.h=!0;var d;try{if("persistent-license"==a.g)if(c)d=ic("LOAD_SESSION|"+c);else{var e=new Uint8Array(b);d=ic("PERSISTENT|"+hc(e))}else d=new Uint8Array(b)}catch(f){return Promise.reject(f)}a.b=new E;try{a.f.webkitGenerateKeyRequest(a.c,d)}catch(g){if("InvalidStateError"!=g.name)return a.b=null,Promise.reject(g);setTimeout(function(){try{this.f.webkitGenerateKeyRequest(this.c,d)}catch(a){this.b.reject(a),
this.b=null}}.bind(a),10)}return a.b}k=vc.prototype;k.Qa=function(a,b){if(this.a)this.a.then(this.Qa.bind(this,a,b)).catch(this.Qa.bind(this,a,b));else{this.a=a;var c,d;"webkit-org.w3.clearkey"==this.c?(c=hc(new Uint8Array(b)),d=JSON.parse(c),"oct"!=d.keys[0].kty&&(this.a.reject(Error("Response is not a valid JSON Web Key Set.")),this.a=null),c=jc(d.keys[0].k),d=jc(d.keys[0].kid)):(c=new Uint8Array(b),d=null);try{this.f.webkitAddKey(this.c,c,d,this.sessionId)}catch(e){this.a.reject(e),this.a=null}}};
function xc(a,b){a.keyStatuses.Ma(b);var c=x({type:"keystatuseschange"});a.dispatchEvent(c)}k.generateRequest=function(a,b){return zc(this,b,null)};k.load=function(a){return"persistent-license"==this.g?zc(this,null,a):Promise.reject(Error("Not a persistent session."))};k.update=function(a){var b=new E;this.Qa(b,a);return b};
k.close=function(){if("persistent-license"!=this.g){if(!this.sessionId)return this.closed.reject(Error("The session is not callable.")),this.closed;this.f.webkitCancelKeyRequest(this.c,this.sessionId)}this.closed.resolve();return this.closed};k.remove=function(){return"persistent-license"!=this.g?Promise.reject(Error("Not a persistent session.")):this.close()};function yc(){this.size=0;this.a=void 0}var Ac;k=yc.prototype;k.Ma=function(a){this.size=void 0==a?0:1;this.a=a};k.Fa=function(){return this.a};
k.forEach=function(a){this.a&&a(Ac,this.a)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=Ac;return this.a&&db(new Uint8Array(a),new Uint8Array(b))?!0:!1};function Bc(a){this.systemIds=[];this.cencKeyIds=[];this.a=[];a=new Ta(new DataView(a.buffer));try{for(;Va(a);){var b=a.a,c=w(a),d=w(a);1==c?c=Xa(a):0==c&&(c=a.b.byteLength-b);if(1886614376!=d)Za(a,c-(a.a-b));else{var e=Wa(a);if(1<e)Za(a,c-(a.a-b));else{Za(a,3);var f=kc(Ya(a)),g=[];if(0<e)for(var h=w(a),l=0;l<h;++l){var m=kc(Ya(a));g.push(m)}var n=w(a);Za(a,n);this.cencKeyIds.push.apply(this.cencKeyIds,g);this.systemIds.push(f);this.a.push({start:b,end:a.a-1});a.a!=b+c&&Za(a,c-(a.a-b))}}}}catch(t){}}
;function Cc(a,b){try{var c=new Dc(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}
function Dc(a,b){this.keySystem=a;for(var c=!1,d=0;d<b.length;++d){var e=b[d],f={audioCapabilities:[],videoCapabilities:[],persistentState:"optional",distinctiveIdentifier:"optional",initDataTypes:e.initDataTypes,sessionTypes:["temporary"]},g=!1;if(e.audioCapabilities)for(var h=0;h<e.audioCapabilities.length;++h){var l=e.audioCapabilities[h];if(l.contentType){var g=!0,m=l.contentType.split(";")[0];MSMediaKeys.isTypeSupported(this.keySystem,m)&&(f.audioCapabilities.push(l),c=!0)}}if(e.videoCapabilities)for(h=
0;h<e.videoCapabilities.length;++h)l=e.videoCapabilities[h],l.contentType&&(g=!0,m=l.contentType.split(";")[0],MSMediaKeys.isTypeSupported(this.keySystem,m)&&(f.videoCapabilities.push(l),c=!0));g||(c=MSMediaKeys.isTypeSupported(this.keySystem,"video/mp4"));"required"==e.persistentState&&(f.persistentState="required",f.sessionTypes=["persistent-license"]);if(c){this.a=f;return}}c=Error("Unsupported keySystem");c.name="NotSupportedError";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}
Dc.prototype.createMediaKeys=function(){var a=new Ec(this.keySystem);return Promise.resolve(a)};Dc.prototype.getConfiguration=function(){return this.a};function Fc(a){var b=this.mediaKeys;b&&b!=a&&Gc(b,null);delete this.mediaKeys;return(this.mediaKeys=a)?Gc(a,this):Promise.resolve()}function Ec(a){this.a=new MSMediaKeys(a);this.b=new B}Ec.prototype.createSession=function(a){if("temporary"!=(a||"temporary"))throw new TypeError("Session type "+a+" is unsupported on this platform.");return new Hc(this.a)};
Ec.prototype.setServerCertificate=function(){return Promise.reject(Error("setServerCertificate not supported on this platform."))};function Gc(a,b){function c(){b.msSetMediaKeys(d.a);b.removeEventListener("loadedmetadata",c)}xb(a.b);if(!b)return Promise.resolve();C(a.b,b,"msneedkey",Ic);var d=a;try{return 1<=b.readyState?b.msSetMediaKeys(a.a):b.addEventListener("loadedmetadata",c),Promise.resolve()}catch(e){return Promise.reject(e)}}
function Hc(a){D.call(this,null);this.c=null;this.g=a;this.b=this.a=null;this.f=new B;this.sessionId="";this.expiration=NaN;this.closed=new E;this.keyStatuses=new Jc}q(Hc,D);k=Hc.prototype;k.generateRequest=function(a,b){this.a=new E;try{this.c=this.g.createSession("video/mp4",new Uint8Array(b),null),C(this.f,this.c,"mskeymessage",this.Bb.bind(this)),C(this.f,this.c,"mskeyadded",this.zb.bind(this)),C(this.f,this.c,"mskeyerror",this.Ab.bind(this)),Kc(this,"status-pending")}catch(c){this.a.reject(c)}return this.a};
k.load=function(){return Promise.reject(Error("MediaKeySession.load not yet supported"))};k.update=function(a){this.b=new E;try{this.c.update(new Uint8Array(a))}catch(b){this.b.reject(b)}return this.b};k.close=function(){try{this.c.close(),this.closed.resolve(),xb(this.f)}catch(a){this.closed.reject(a)}return this.closed};k.remove=function(){return Promise.reject(Error("MediaKeySession.remove is only applicable for persistent licenses, which are not supported on this platform"))};
function Ic(a){var b=a.initData;if(b){var c=new Bc(b);if(1>=c.a.length)a=b;else{var d=[];for(a=0;a<c.a.length;a++)d.push(b.subarray(c.a[a].start,c.a[a].end+1));b=Ra(d,Lc);for(a=c=0;a<b.length;a++)c+=b[a].length;c=new Uint8Array(c);for(a=d=0;a<b.length;a++)c.set(b[a],d),d+=b[a].length;a=c}}else a=b;a=x({type:"encrypted",initDataType:"cenc",initData:a});this.dispatchEvent(a)}function Lc(a,b){return db(a,b)}
k.Bb=function(a){this.a&&(this.a.resolve(),this.a=null);a=x({type:"message",messageType:void 0==this.keyStatuses.Fa()?"licenserequest":"licenserenewal",message:a.message.buffer});this.dispatchEvent(a)};k.zb=function(){this.a?(this.a.resolve(),this.a=null):this.b&&(Kc(this,"usable"),this.b.resolve(),this.b=null)};
k.Ab=function(){var a=Error("EME v20140218 key error");a.errorCode=this.c.error;if(null!=this.a)this.a.reject(a),this.a=null;else if(null!=this.b)this.b.reject(a),this.b=null;else switch(this.c.error.code){case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:Kc(this,"output-not-allowed");default:Kc(this,"internal-error")}};function Kc(a,b){a.keyStatuses.Ma(b);var c=x({type:"keystatuseschange"});a.dispatchEvent(c)}function Jc(){this.size=0;this.a=void 0}var Mc;
k=Jc.prototype;k.Ma=function(a){this.size=void 0==a?0:1;this.a=a};k.Fa=function(){return this.a};k.forEach=function(a){this.a&&a(Mc,this.a)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=Mc;return this.a&&db(new Uint8Array(a),new Uint8Array(b))?!0:!1};function Nc(){Navigator.prototype.requestMediaKeySystemAccess&&MediaKeySystemAccess.prototype.getConfiguration||(HTMLMediaElement.prototype.webkitGenerateKeyRequest?(Ac=(new Uint8Array([0])).buffer,Navigator.prototype.requestMediaKeySystemAccess=qc,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=sc,window.MediaKeys=uc,window.MediaKeySystemAccess=rc):window.MSMediaKeys?(Mc=(new Uint8Array([0])).buffer,delete HTMLMediaElement.prototype.mediaKeys,
HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=Fc,window.MediaKeys=Ec,window.MediaKeySystemAccess=Dc,Navigator.prototype.requestMediaKeySystemAccess=Cc):(Navigator.prototype.requestMediaKeySystemAccess=ya,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=za,window.MediaKeys=Aa,window.MediaKeySystemAccess=Ba))}p("shaka.polyfill.MediaKeys.install",Nc);p("shaka.polyfill.installAll",function(){ta();va();Pa();Da();Nc()});var Oc=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;function H(a){var b;a instanceof H?(Pc(this,a.P),this.ca=a.ca,this.S=a.S,Qc(this,a.ia),this.O=a.O,Rc(this,a.a.clone()),this.aa=a.aa):a&&(b=String(a).match(Oc))?(Pc(this,b[1]||"",!0),this.ca=Sc(b[2]||""),this.S=Sc(b[3]||"",!0),Qc(this,b[4]),this.O=Sc(b[5]||"",!0),Rc(this,b[6]||"",!0),this.aa=Sc(b[7]||"")):this.a=new Tc(null)}k=H.prototype;k.P="";k.ca="";k.S="";k.ia=null;k.O="";k.aa="";
k.toString=function(){var a=[],b=this.P;b&&a.push(Vc(b,Wc,!0),":");if(b=this.S){a.push("//");var c=this.ca;c&&a.push(Vc(c,Wc,!0),"@");a.push(encodeURIComponent(b).replace(/%25([0-9a-fA-F]{2})/g,"%$1"));b=this.ia;null!=b&&a.push(":",String(b))}if(b=this.O)this.S&&"/"!=b.charAt(0)&&a.push("/"),a.push(Vc(b,"/"==b.charAt(0)?Xc:Yc,!0));(b=this.a.toString())&&a.push("?",b);(b=this.aa)&&a.push("#",Vc(b,Zc));return a.join("")};
k.resolve=function(a){var b=this.clone();"data"===b.P&&(b=new H);var c=!!a.P;c?Pc(b,a.P):c=!!a.ca;c?b.ca=a.ca:c=!!a.S;c?b.S=a.S:c=null!=a.ia;var d=a.O;if(c)Qc(b,a.ia);else if(c=!!a.O){if("/"!=d.charAt(0))if(this.S&&!this.O)d="/"+d;else{var e=b.O.lastIndexOf("/");-1!=e&&(d=b.O.substr(0,e+1)+d)}if(".."==d||"."==d)d="";else if(-1!=d.indexOf("./")||-1!=d.indexOf("/.")){for(var e=0==d.lastIndexOf("/",0),d=d.split("/"),f=[],g=0;g<d.length;){var h=d[g++];"."==h?e&&g==d.length&&f.push(""):".."==h?((1<f.length||
1==f.length&&""!=f[0])&&f.pop(),e&&g==d.length&&f.push("")):(f.push(h),e=!0)}d=f.join("/")}}c?b.O=d:c=""!==a.a.toString();c?Rc(b,a.a.clone()):c=!!a.aa;c&&(b.aa=a.aa);return b};k.clone=function(){return new H(this)};function Pc(a,b,c){a.P=c?Sc(b,!0):b;a.P&&(a.P=a.P.replace(/:$/,""))}function Qc(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.ia=b}else a.ia=null}function Rc(a,b,c){b instanceof Tc?a.a=b:(c||(b=Vc(b,$c)),a.a=new Tc(b))}
function Sc(a,b){return a?b?decodeURI(a):decodeURIComponent(a):""}function Vc(a,b,c){return"string"==typeof a?(a=encodeURI(a).replace(b,ad),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null}function ad(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)}var Wc=/[#\/\?@]/g,Yc=/[\#\?:]/g,Xc=/[\#\?]/g,$c=/[\#\?@]/g,Zc=/#/g;function Tc(a){this.b=a||null}Tc.prototype.a=null;Tc.prototype.c=null;
function bd(a,b,c){if(!a.a&&(a.a={},a.c=0,a.b))for(var d=a.b.split("&"),e=0;e<d.length;e++){var f=d[e].indexOf("="),g=null,h=null;0<=f?(g=d[e].substring(0,f),h=d[e].substring(f+1)):g=d[e];g=decodeURIComponent(g.replace(/\+/g," "));h=h||"";bd(a,g,decodeURIComponent(h.replace(/\+/g," ")))}a.b=null;(d=a.a.hasOwnProperty(b)&&a.a[b])||(a.a[b]=d=[]);d.push(c);a.c++}
Tc.prototype.toString=function(){if(this.b)return this.b;if(!this.a)return"";var a=[],b;for(b in this.a)for(var c=encodeURIComponent(b),d=this.a[b],e=0;e<d.length;e++){var f=c;""!==d[e]&&(f+="="+encodeURIComponent(d[e]));a.push(f)}return this.b=a.join("&")};Tc.prototype.clone=function(){var a=new Tc;a.b=this.b;if(this.a){var b={},c;for(c in this.a)b[c]=this.a[c].concat();a.a=b;a.c=this.c}return a};function cd(){this.id=this.url=null;this.type="static";this.b=this.j=this.u=this.hb=null;this.h=5;this.f=this.c=this.g=null;this.i=1;this.a=[]}function dd(){this.g=this.f=this.c=this.u=this.a=this.start=this.id=null;this.b=[]}function ed(){this.i=this.b=this.height=this.width=this.contentType=this.lang=this.group=this.id=null;this.c=!1;this.h=this.g=this.f=this.u=null;this.j=[];this.a=[]}function fd(){this.value=null}function gd(){this.contentType=this.lang=this.id=null}
function hd(){this.a=this.b=this.g=this.u=this.h=this.f=this.height=this.width=this.bandwidth=this.lang=this.id=null;this.c=[]}function id(){this.b=this.a=this.c=this.f=null}function jd(){this.parsedPssh=this.psshBox=null}function kd(){this.url=null}function ld(){this.url=null}function md(){this.u=null;this.g=1;this.c=this.b=this.a=this.f=null}md.prototype.clone=function(){var a=new md;a.u=nd(this.u);a.g=this.g;a.f=this.f;a.a=J(this.a);a.b=J(this.b);a.c=J(this.c);return a};
function od(){this.a=this.url=null}od.prototype.clone=function(){var a=new od;a.url=nd(this.url);a.a=J(this.a);return a};function pd(){this.a=this.url=null}pd.prototype.clone=function(){var a=new pd;a.url=nd(this.url);a.a=J(this.a);return a};function qd(){this.u=null;this.f=1;this.b=this.g=null;this.i=1;this.h=null;this.a=[];this.c=null}qd.prototype.clone=function(){var a=new qd;a.u=nd(this.u);a.f=this.f;a.g=this.g;a.b=this.b;a.i=this.i;a.h=J(this.h);a.a=nd(this.a)||[];a.c=J(this.c);return a};
function rd(){this.a=this.b=null}rd.prototype.clone=function(){var a=new rd;a.b=nd(this.b);a.a=J(this.a);return a};function sd(){this.a=1;this.b=this.i=null;this.j=1;this.c=this.g=this.f=this.h=null}sd.prototype.clone=function(){var a=new sd;a.a=this.a;a.i=this.i;a.b=this.b;a.j=this.j;a.h=this.h;a.f=this.f;a.g=this.g;a.c=J(this.c);return a};function td(){this.a=[]}td.prototype.clone=function(){var a=new td;a.a=nd(this.a)||[];return a};function ud(){this.c=this.a=this.b=null}
ud.prototype.clone=function(){var a=new ud;a.b=this.b;a.a=this.a;a.c=this.c;return a};function vd(a,b){this.na=a;this.end=b}vd.prototype.clone=function(){return new vd(this.na,this.end)};cd.TAG_NAME="MPD";dd.TAG_NAME="Period";ed.TAG_NAME="AdaptationSet";fd.TAG_NAME="Role";gd.TAG_NAME="ContentComponent";hd.TAG_NAME="Representation";id.TAG_NAME="ContentProtection";jd.TAG_NAME="cenc:pssh";kd.TAG_NAME="BaseURL";ld.TAG_NAME="Location";md.TAG_NAME="SegmentBase";od.TAG_NAME="RepresentationIndex";
pd.TAG_NAME="Initialization";qd.TAG_NAME="SegmentList";rd.TAG_NAME="SegmentURL";sd.TAG_NAME="SegmentTemplate";td.TAG_NAME="SegmentTimeline";ud.TAG_NAME="S";
cd.prototype.parse=function(a,b){this.url=a.hb;this.id=K(b,"id",L);this.type=K(b,"type",L)||"static";this.b=K(b,"mediaPresentationDuration",wd);this.h=K(b,"minBufferTime",wd,this.h);this.g=K(b,"minimumUpdatePeriod",wd,this.g);this.c=K(b,"availabilityStartTime",xd,this.c);this.f=K(b,"timeShiftBufferDepth",wd,this.f);this.i=K(b,"suggestedPresentationDelay",wd,this.i);var c=a.u,d=M(this,b,kd);this.u=yd(c,d);if(d=O(this,b,ld))this.j=zd(c,d.url);this.a=M(this,b,dd)};
dd.prototype.parse=function(a,b){this.id=K(b,"id",L);this.start=K(b,"start",wd);this.a=K(b,"duration",wd);var c=M(this,b,kd);this.u=yd(a.u,c);this.c=O(this,b,md);this.f=O(this,b,qd);this.g=O(this,b,sd);this.b=M(this,b,ed);Ad(this)};function Ad(a){for(var b=[],c=0;c<a.b.length;++c){var d=a.b[c];null!=d.group&&(b[d.group]=!0)}for(c=0;c<a.b.length;++c)if(d=a.b[c],null==d.group){for(var e=1;1==b[e];)++e;b[e]=!0;d.group=e}}
ed.prototype.parse=function(a,b){var c=O(this,b,gd)||{},d=O(this,b,fd);this.id=K(b,"id",L);this.group=K(b,"group",P);this.lang=K(b,"lang",L,c.lang);this.contentType=K(b,"contentType",L,c.contentType);this.width=K(b,"width",Q);this.height=K(b,"height",Q);this.b=K(b,"mimeType",L);this.i=K(b,"codecs",L);this.c=d&&"main"==d.value;this.lang&&(this.lang=kb(this.lang));c=M(this,b,kd);this.u=yd(a.u,c);this.j=M(this,b,id);!this.contentType&&this.b&&(this.contentType=this.b.split("/")[0]);this.f=a.c?Bd(this,
b,a.c):O(this,b,md);this.g=a.f?Bd(this,b,a.f):O(this,b,qd);this.h=a.g?Bd(this,b,a.g):O(this,b,sd);this.a=M(this,b,hd);!this.b&&this.a.length&&(this.b=this.a[0].f,!this.contentType&&this.b&&(this.contentType=this.b.split("/")[0]))};fd.prototype.parse=function(a,b){this.value=K(b,"value",L)};gd.prototype.parse=function(a,b){this.id=K(b,"id",L);this.lang=K(b,"lang",L);this.contentType=K(b,"contentType",L);this.lang&&(this.lang=kb(this.lang))};
hd.prototype.parse=function(a,b){this.id=K(b,"id",L);this.bandwidth=K(b,"bandwidth",Q);this.width=K(b,"width",Q,a.width);this.height=K(b,"height",Q,a.height);this.f=K(b,"mimeType",L,a.b);this.h=K(b,"codecs",L,a.i);this.lang=a.lang;var c=M(this,b,kd);this.u=yd(a.u,c);this.c=M(this,b,id);this.g=a.f?Bd(this,b,a.f):O(this,b,md);this.b=a.g?Bd(this,b,a.g):O(this,b,qd);this.a=a.h?Bd(this,b,a.h):O(this,b,sd);this.c=this.c.concat(a.j)};
id.prototype.parse=function(a,b){this.f=b;this.c=K(b,"schemeIdUri",L);var c=K(b,"cenc:default_KID",L);c&&(this.b=c.replace(/[-]/g,""));this.a=O(this,b,jd)};jd.prototype.parse=function(a,b){var c=Cd(b);if(c){this.psshBox=jc(c);try{this.parsedPssh=new Bc(this.psshBox)}catch(d){if(!(d instanceof RangeError))throw d;}}};kd.prototype.parse=function(a,b){this.url=Cd(b)};ld.prototype.parse=function(a,b){this.url=Cd(b)};
md.prototype.parse=function(a,b){this.u=a.u||this.u;this.g=K(b,"timescale",Q,this.g);this.f=K(b,"presentationTimeOffset",P,this.f);this.a=K(b,"indexRange",Dd,this.a);this.b=O(this,b,od)||this.b;this.c=O(this,b,pd)||this.c};od.prototype.parse=function(a,b){var c=K(b,"sourceURL",L);this.url=zd(a.u,c);this.a=K(b,"range",Dd,J(a.a))};pd.prototype.parse=function(a,b){var c=K(b,"sourceURL",L);this.url=zd(a.u,c);this.a=K(b,"range",Dd)};
qd.prototype.parse=function(a,b){this.u=a.u||this.u;this.f=K(b,"timescale",Q,this.f);this.g=K(b,"presentationTimeOffset",P,this.g);this.b=K(b,"duration",Q,this.b);var c=K(b,"startNumber",Q);null!=c&&(this.i=c);this.h=O(this,b,pd)||this.h;this.a=(c=M(this,b,rd))&&0<c.length?c:this.a;this.c=O(this,b,td)||this.c};rd.prototype.parse=function(a,b){var c=K(b,"media",L);this.b=zd(a.u,c);this.a=K(b,"mediaRange",Dd)};
sd.prototype.parse=function(a,b){this.a=K(b,"timescale",Q,this.a);this.i=K(b,"presentationTimeOffset",P,this.i);this.b=K(b,"duration",Q,this.b);var c=K(b,"startNumber",P);null!=c&&(this.j=c);this.h=K(b,"media",L,this.h);this.f=K(b,"index",L,this.f);this.g=K(b,"initialization",L,this.g);this.c=O(this,b,td)||this.c};td.prototype.parse=function(a,b){this.a=M(this,b,ud)};ud.prototype.parse=function(a,b){this.b=K(b,"t",P);this.a=K(b,"d",P);this.c=K(b,"r",Ed)};
function yd(a,b){if(!b||0===b.length)return a;for(var c=[],d=0;d<b.length;d++){var e=b[d].url;null==a||0===a.length?c.push(new H(e)):(e=zd(a.slice(0,1),e),c.push(e[0]))}return c}function zd(a,b){if(!b)return a;var c=new H(b);return a?a.map(function(a){return a.resolve(c)}):[c]}function Bd(a,b,c){var d=J(c);(b=Fd(b,c.constructor.TAG_NAME))&&d.parse(a,b);return d}function O(a,b,c){var d=null;if(b=Fd(b,c.TAG_NAME))d=new c,d.parse(a,b);return d}
function Fd(a,b){for(var c=null,d=0;d<a.childNodes.length;d++)if(a.childNodes[d].tagName==b){if(c)return null;c=a.childNodes[d]}return c}function M(a,b,c){for(var d=[],e=0;e<b.childNodes.length;e++)if(b.childNodes[e].tagName==c.TAG_NAME){var f=new c;f.parse.call(f,a,b.childNodes[e]);d.push(f)}return d}function Cd(a){a=a.firstChild;return a.nodeType!=Node.TEXT_NODE?null:a.nodeValue}function nd(a){return a?a.map(function(a){return a.clone()}):null}function J(a){return a?a.clone():null}
function K(a,b,c,d){a=c(a.getAttribute(b));return null!=a?a:void 0!==d?d:null}function xd(a){if(!a)return null;a=Date.parse(a);return isNaN(a)?null:Math.floor(a/1E3)}
function wd(a){if(!a)return null;var b=/^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$/.exec(a);if(!b)return null;a=0;var c=P(b[1]);c&&(a+=31536E3*c);(c=P(b[2]))&&(a+=2592E3*c);(c=P(b[3]))&&(a+=86400*c);(c=P(b[4]))&&(a+=3600*c);(c=P(b[5]))&&(a+=60*c);b=window.parseFloat(b[6]);(b=isNaN(b)?null:b)&&(a+=b);return a}
function Dd(a){var b=/([0-9]+)-([0-9]+)/.exec(a);if(!b)return null;a=P(b[1]);if(null==a)return null;b=P(b[2]);return null==b?null:new vd(a,b)}function Ed(a){a=window.parseInt(a,10);return isNaN(a)?null:a}function Q(a){a=window.parseInt(a,10);return 0<a?a:null}function P(a){a=window.parseInt(a,10);return 0<=a?a:null}function L(a){return a};function Gd(a,b){this.url=a;this.b=b||new ac;this.g=this.i=this.h=0;this.a=null;this.c=new E;this.f=null}function ac(){this.body=null;this.a=1;this.h=1E3;this.c=0;this.method="GET";this.f="arraybuffer";this.b={};this.g=this.j=!1;this.i=null}var Hd=!0;function Id(a){Jd(a);a.b.body=null;a.c.destroy();a.c=null;a.f=null}function Jd(a){a.a&&(a.a.onload=null,a.a.onreadystatechange=null,a.a.onerror=null,a.a.ontimeout=null);a.a=null}k=Gd.prototype;
k.rb=function(){if(this.a)return this.c;if(0==this.url.lastIndexOf("data:",0)){var a=this.url.split(":")[1].split(";").pop().split(","),b=a.pop(),b="base64"==a.pop()?window.atob(b.replace(/-/g,"+").replace(/_/g,"/")):window.decodeURIComponent(b);"arraybuffer"==this.b.f&&(b=ic(b).buffer);a=JSON.parse(JSON.stringify(new XMLHttpRequest));a.response=b;a.responseText=b.toString();b=this.c;b.resolve(a);Id(this);return b}if(0==this.url.lastIndexOf("idb:",0))return Kd(this);this.h++;this.i=Date.now();this.g||
(this.g=this.b.h);this.a=new XMLHttpRequest;a=this.url;Hd&&(this.f&&!this.f.supportsCaching()||this.b.g)&&(a=new H(a),bd(a.a,"_",Date.now()),a=a.toString());this.a.open(this.b.method,a,!0);this.a.responseType=this.b.f;this.a.timeout=this.b.c;this.a.withCredentials=this.b.j;this.a.onload=this.xb.bind(this);this.b.g&&(this.a.onreadystatechange=this.Eb.bind(this));this.a.onerror=this.Tb.bind(this);this.a.ontimeout=this.Ib.bind(this);for(b in this.b.b)this.a.setRequestHeader(b,this.b.b[b]);this.a.send(this.b.body);
return this.c};function Kd(a){var b=a.url.split("/");return Ub(a.b.i,parseInt(b[2],10),parseInt(b[3],10)).then(F(a,function(a){var b=JSON.parse(JSON.stringify(new XMLHttpRequest));b.response=a;a=this.c;a.resolve(b);Id(this);return a})).catch(F(a,function(a){Id(this);return Promise.reject(a)}))}function Ld(a,b,c){b=Error(b);b.type=c;b.status=a.a.status;b.url=a.url;b.method=a.b.method;b.body=a.b.body;b.xhr=a.a;return b}
k.xb=function(a){this.f&&this.f.sample(Date.now()-this.i,a.loaded);200<=this.a.status&&299>=this.a.status?(this.c.resolve(this.a),Id(this)):this.h<this.b.a?Md(this):(a=Ld(this,"HTTP error.","net"),this.c.reject(a),Id(this))};k.Eb=function(){if(this.a.readyState==XMLHttpRequest.HEADERS_RECEIVED){var a=Date.parse(this.a.getResponseHeader("Date"));a&&(Sa=a-Date.now())}};k.Tb=function(){var a=Ld(this,"Network failure.","net");this.c.reject(a);Id(this)};
k.Ib=function(){if(this.h<this.b.a)Md(this);else{var a=Ld(this,"Request timed out.","net");this.c.reject(a);Id(this)}};function Md(a){Jd(a);window.setTimeout(a.rb.bind(a),a.g*(1+.5*(2*Math.random()-1)));a.g*=2};function G(a,b,c,d){this.b=b;this.f=c||0;this.i=null!=d?d:null;this.c=this.a=null;this.j=a;this.h=null}function Nd(a,b){return a&&0!==a.length?a.map(function(a){return a.resolve(b)}):[b]}function bc(a,b,c){if(a.a)return a.a;b=b||new ac;if(a.f||a.i)b.b.Range="bytes="+(a.f+"-"+(null!=a.i?a.i:""));a.a=Od(a,0,b,c);return a.a}
G.prototype.g=function(){if(this.c){this.a=null;var a=this.c;if(a.a&&a.a.readyState!=XMLHttpRequest.DONE){a.a.abort();var b=Ld(a,"Request aborted.","aborted");a.c.reject(b);Id(a)}this.h=this.c=null}};
function Od(a,b,c,d){var e=a.b[b].toString();a.j&&(e=a.j(e,c.b)||e);a.c=new Gd(e,c);d&&(a.c.f=d);e=a.c.rb().then(F(a,function(a){this.h=this.c=this.a=null;this.h=a.a?new H(a.a):this.b[b];return Promise.resolve(a.response)}));return e=e.catch(F(a,function(a){if(this.a&&b+1<this.b.length)return this.a=Od(this,b+1,c,d);this.a=this.c=null;return Promise.reject(a)}))}G.prototype.clone=function(){return new G(this.j,this.b.map(function(a){return a.clone()}),this.f,this.i)};G.prototype.toString=function(){return this.b[0].toString()};function Pd(a,b){this.a=new ac;this.a.f="text";this.a.a=3;this.a.c=1E3*(null!=b?b:0);this.a.g=!0;this.b=a}function Qd(a){var b=a.b;return bc(b,a.a).then(function(a){var d;d=b.b;var e=[b.h];d=(a=(new DOMParser).parseFromString(a,"text/xml"))?O({hb:d,u:e},a,cd):null;if(d)return Promise.resolve(d);d=Error("MPD parse failure.");d.type="dash";return Promise.reject(d)})};function Rd(a,b,c,d){for(var e=b.a,f=[],g=0;g<d;++g){var h=g+c,l=(h-1)*e.b,m=l/e.a,n=(l+e.b)/e.a,h=Sd(a,b,e.j+h-1,l);if(!h)return null;f.push(new Td(m,n,h))}return f}function Sd(a,b,c,d){if(!b.a)return null;var e=b.a.h;if(!e)return b.u?new G(a,b.u,0,null):null;c=Ud(e,b.id,c,b.bandwidth,d);if(!c)return null;b=Nd(b.u,c);return new G(a,b,0,null)}
function Ud(a,b,c,d,e){var f={RepresentationID:b,Number:c,Bandwidth:d,Time:e};a=a.replace(/\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)d)?\$/g,function(a,b,c){if("$$"==a)return"$";var d=f[b];if(null==d)return a;"RepresentationID"==b&&c&&(c=void 0);a=d.toString();c=window.parseInt(c,10)||1;c=Math.max(0,c-a.length);return Array(c+1).join("0")+a});try{return new H(a)}catch(g){if(g instanceof URIError)return null;throw g;}}
function Vd(a,b,c){var d=0;b*=c;a=a.a;c=[];for(var e=0;e<a.length&&a[e].a;++e){var f=a[e].b,f=null!=f?f:d,g=a[e].c||0;0>g&&(g=a[e].a,g=e+1===a.length?Math.ceil((a[0].b+b-f)/g)-1:Math.ceil((a[e+1].b-f)/g)-1);0<c.length&&f!=d&&(c[c.length-1].end=f);for(var h=0;h<=g;++h)d=f+a[e].a,c.push({start:f,end:d}),f=d}return c};function Wd(a,b){this.a=a;this.b=b||null}Wd.prototype.destroy=function(){this.a&&(this.a.g(),this.a=null);this.b=null};Wd.prototype.create=function(){return this.a?bc(this.a):Promise.resolve(this.b)};function Td(a,b,c){this.b=a;this.a=b;this.url=c}function Xd(a,b,c){return new Td(b,c,a.url)}function cc(a,b){for(var c=a.length-1;0<=c;--c){var d=a[c];if(b>=d.b&&(null==d.a||b<d.a))return c}return-1}function Yd(a,b){return a.map(function(a){return Xd(a,a.b+b,null!=a.a?a.a+b:null)})};function Zd(){}
Zd.prototype.parse=function(a,b,c,d){var e=null;try{a:{var f=[],g=new Ta(a),h=w(g);if(1936286840!=w(g))e=null;else{1==h&&(h=Xa(g));var l=Wa(g);Za(g,3);Za(g,4);var m=w(g);if(0==m)e=null;else{var n,t;0==l?(n=w(g),t=w(g)):(n=Xa(g),t=Xa(g));Za(g,2);var A=g.b.getUint16(g.a,g.c);g.a+=2;a=n;b=b+h+t;for(h=0;h<A;h++){var N=w(g);t=(N&2147483648)>>>31;var l=N&2147483647,I=w(g);w(g);if(1==t){e=null;break a}var wa=new G(d,c,b,b+l-1);f.push(new Td(a/m,(a+I)/m,wa));a+=I;b+=l}e=f}}}}catch(Nb){if(!(Nb instanceof RangeError))throw Nb;
}return e};function R(a){this.o=a;this.i=0}R.prototype.destroy=function(){this.o=null};k=R.prototype;k.length=function(){return this.o.length};function S(a){if(0==a.o.length)throw new RangeError("SegmentIndex: There is no first SegmentReference.");return a.o[0]}k.A=function(){if(0==this.o.length)throw new RangeError("SegmentIndex: There is no last SegmentReference.");return this.o[this.o.length-1]};
k.get=function(a){if(0>a||a>=this.o.length)throw new RangeError("SegmentIndex: The specified index is out of range.");return this.o[a]};k.la=function(a){a=cc(this.o,a);return 0<=a?this.o[a]:null};k.Ha=function(a){$d(this,a);return!0};
function $d(a,b){a.i!=b.i&&(b=new R(Yd(b.o,a.i-b.i)));if(0==a.length())a.o=b.o.slice(0);else if(0!=b.length()&&null!=a.A().a&&!(null!=b.A().a&&b.A().a<a.A().a)){if(a.A().a<=S(b).b)var c=Xd(a.A(),a.A().b,S(b).b),c=a.o.slice(0,-1).concat([c]);else{var d;for(d=0;d<a.o.length&&!(a.o[d].a>=S(b).b);++d);a.o[d].b<S(b).b?(c=Xd(a.o[d],a.o[d].b,S(b).b),c=a.o.slice(0,d).concat([c])):(S(a).b>S(b).b||S(b),c=a.o.slice(0,d))}a.o=c.concat(b.o)}}
k.ka=function(a){var b=a-this.i;if(0==b)return 0;this.o=Yd(this.o,b);this.i=a;return b};k.Ea=function(){return 0<this.length()?{start:S(this).b,end:this.A().a}:{start:0,end:0}};function T(a,b,c,d){R.call(this,a);this.g=b;this.w=c;this.f=d;this.h=this.g.b||this.g.a.reduce(function(a,b){return null==b.a?NaN:a+b.a},0)||0;this.a=this.l=this.c=null;ae(this)}q(T,R);T.prototype.destroy=function(){this.w=this.g=null;R.prototype.destroy.call(this)};T.prototype.la=function(a){be(this,v()/1E3);return R.prototype.la.call(this,a)};T.prototype.Ha=function(a){if(!(a instanceof T))return!1;$d(this,a);this.h=Math.max(this.h,a.h);null==this.c?(this.f=a.f,ae(this)):ce(this);return!0};
function ae(a){ce(a);if(0!=a.length()){a.length();var b=null!=a.A().a?a.A().a:a.A().b;if(a.g.c>a.f)a.c=b;else{var c=a.f-(a.g.c+a.w.start);0>c?a.c=b:c<Math.max(a.A().b,a.A().a||0)?(a.A(),a.c=b):a.c=c}a.l=a.A().b;a.a=S(a).b}}T.prototype.ka=function(a){a=R.prototype.ka.call(this,a);Math.min.apply(null,this.o.filter(function(a){return null!=a.a}).map(function(a){return a.a-a.b}));null!=this.c&&(this.l+=a,this.a+=a,this.c+=a);return a};T.prototype.Ea=function(){return de(this,v()/1E3)};
function de(a,b){be(a,b);if(null==a.c||null==a.l||null==a.a)return{start:0,end:0};var c=Number.POSITIVE_INFINITY;a.h&&(c=a.h);var d=b-a.f,e=a.c+d;null!=a.g.f&&(e=e-a.a-a.g.f,0<e&&(a.a+=e));a.a=Math.min(a.a,c);d=a.l+d;if(d<a.a)return{start:a.a,end:a.a};d=0<a.length()?null!=a.A().a?Math.min(d,a.A().a):d:a.a;d=Math.max(d,a.a);d=Math.min(d,c);return{start:a.a,end:d}}
function be(a,b){ce(a);if(null!=a.g.f)if(null==a.c)a.length();else{for(var c=a.c+(b-a.f),d=0,e=0;e<a.o.length;++e){var f=null;e<a.o.length-1?f=a.o[e+1].a:(f=a.o[e],f=null!=f.a?f.a+(f.a-f.b):null);if(null!=f&&f<c-a.g.f)++d;else break}0<d&&a.o.splice(0,d)}}function ce(a){if(a.h){for(var b=0,c=a.o.length-1;0<=c;--c)if(a.o[c].b>a.h)++b;else break;0<b&&a.o.splice(-b)}};function oe(a,b,c,d,e){var f=1,g=0,h;if(a.c>d)h=null;else{var l=a.i||0,m=a.f||0;h=c.a;h=h.b/h.a;var n=d-(a.c+b.start);0>n?h=null:(m=n-2*h-m,0>m&&(m=0),m=Math.ceil(m/h)*h,n-=h,0>n?h=null:(l=Math.floor(n/h)*h-l,0>l&&(l=0),l=Math.floor(l/h)*h,h={Ya:m/h+1,current:(l>=m?l:m)/h+1}))}h&&(f=h.Ya,g=h.current-h.Ya+1);f=Rd(e,c,f,g);if(null==f)throw (a=Error("Failed to generate SegmentReferences."), a.type="stream", a);T.call(this,f,a,b,d);this.s=c;this.v=this.b=0<this.length()?a.c+b.start+this.A().a:null;this.j=
h?h.current+1:null;this.B=e}q(oe,T);oe.prototype.destroy=function(){this.B=this.s=null;T.prototype.destroy.call(this)};oe.prototype.la=function(a){var b=v()/1E3;pe(this,b);be(this,b);return R.prototype.la.call(this,a)};oe.prototype.Ha=function(a){if(null!=this.b||!(a instanceof oe)||null==a.b)return!1;this.b=a.b;this.v=a.v;this.j=a.j;this.f=a.f;this.h=a.h;$d(this,a);pe(this,v()/1E3);ae(this);return!0};oe.prototype.ka=function(a){a=T.prototype.ka.call(this,a);null!=this.b&&(this.b+=a,this.v+=a);return a};
oe.prototype.Ea=function(){var a=v()/1E3;pe(this,a);return de(this,a)};function pe(a,b){if(null!=a.b&&null!=a.v&&null!=a.j){var c=a.s.a,c=c.b/c.a,d=Math.floor((a.v+(b-a.f)-a.b)/c);if(0!=d){var e=Rd(a.B,a.s,a.j,d);Array.prototype.push.apply(a.o,Yd(e,a.i));a.b+=d*c;a.j+=d}}};function qe(a,b,c,d,e){this.f=a;this.b=b;this.c=c;this.h=d;this.a=null;this.g=e}qe.prototype.destroy=function(){this.g=this.c=this.b=this.f=null;this.a&&(this.a.destroy(),this.a=null)};
qe.prototype.create=function(){if(this.a)return Promise.resolve(this.a);if("dynamic"==this.f.type)try{this.a=new oe(this.f,this.b,this.c,this.h,this.g)}catch(a){return Promise.reject(a)}else{var b;b=this.c.a;if(b=Rd(this.g,this.c,1,Math.ceil(this.b.a/(b.b/b.a)))){if(0<b.length){var c=b[b.length-1];b[b.length-1]=Xd(c,c.b,this.b.a)}b=new R(b)}else b=null;this.a=b;if(!this.a)return b=Error("Failed to generate SegmentReferences"),b.type="stream",Promise.reject(b)}return Promise.resolve(this.a)};function re(a,b,c,d,e){this.c=a;this.b=b;this.g=c;this.a=null;this.h=d;this.f=e}re.prototype.destroy=function(){this.f=this.g=this.b=this.c=null;this.a&&(this.a.destroy(),this.a=null)};
re.prototype.create=function(){if(this.a)return Promise.resolve(this.a);var a=this.g.b,b=[];a.c&&(b=Vd(a.c,a.f||1,this.b.a||0));var c=0;a.b&&a.i?c=(a.i-1)*a.b:0<b.length&&(c=b[0].start-(a.g||0));var d=a.a.length;0<b.length&&b.length!=a.a.length&&(d=Math.min(b.length,a.a.length));for(var e=[],f=0;f<d;++f){var g=a.a[f],h=c/a.f,l=null,m=null;a.b?(l=c+a.b,m=l/a.f):0<b.length?(l=b[f].end-(a.g||0),m=l/a.f):(m=h+this.b.a,l=m*a.f);var c=l,l=0,n=null;g.a&&(l=g.a.na,n=g.a.end);e.push(new Td(h,m,new G(this.f,
g.b,l,n)))}"dynamic"==this.c.type?this.a=new T(e,this.c,this.b,this.h):this.a=new R(e);return Promise.resolve(this.a)};function se(a,b,c,d,e){this.b=a;this.c=b;this.f=c;this.h=d;this.a=null;this.g=e}se.prototype.destroy=function(){this.g=this.f=this.c=this.b=null;this.a&&(this.a.destroy(),this.a=null)};
se.prototype.create=function(){if(this.a)return Promise.resolve(this.a);for(var a=this.f.a,b=Vd(a.c,a.a||1,this.c.a||0),c=[],d=0;d<b.length;++d){var e=b[d].start,f=e/a.a,g=b[d].end/a.a,e=Sd(this.g,this.f,d+a.j,e);if(!e)return a=Error("Failed to generate media URL."),a.type="dash",Promise.reject(a);var h=(a.i||0)/a.a;c.push(new Td(f-h,g-h,e))}"dynamic"==this.b.type?this.a=new T(c,this.b,this.c,this.h):this.a=new R(c);return Promise.resolve(this.a)};function te(a){this.b=a;this.a=null}te.prototype.destroy=function(){this.b=null;this.a&&(this.a.destroy(),this.a=null)};te.prototype.create=function(){if(this.a)return Promise.resolve(this.a);for(var a=[],b=0;b<this.b.length;++b){var c=this.b[b];a.push(new Td(c.start_time,c.end_time,new G(null,[new H(c.url)],c.start_byte,null)))}this.b=null;this.a=new R(a);return Promise.resolve(this.a)};function ue(){this.C=ve++;this.id=this.H=this.I=null;this.c=0;this.height=this.width=this.bandwidth=null;this.b=this.a="";this.f=[];this.N=!1;this.J=!0}var ve=0;ue.prototype.destroy=function(){this.I&&(this.I.destroy(),this.I=null);this.H&&(this.H.destroy(),this.H=null)};function we(a){var b=a.a||"";a.b&&(b+='; codecs="'+a.b+'"');return b}function xe(){this.C=ye++;this.id=null;this.contentType=this.lang="";this.b=!1;this.m=[];this.a=[]}var ye=0;
xe.prototype.destroy=function(){for(var a=0;a<this.m.length;++a)this.m[a].destroy();this.a=this.m=null};function ze(a){for(var b=[],c=0;c<a.a.length;++c){var d=new Ae;d.id=a.C;d.a=a.a[c];d.contentType=a.contentType;d.b=a.m.length?we(a.m[0]):"";b.push(d)}return b}function Be(){this.id=null;this.start=0;this.b=null;this.a=[]}Be.prototype.destroy=function(){for(var a=0;a<this.a.length;++a)this.a[a].destroy();this.a=null};function Ce(){this.b=!1;this.h=this.g=this.f=null;this.c=0;this.a=[]}
Ce.prototype.destroy=function(){for(var a=0;a<this.a.length;++a)this.a[a].destroy();this.a=null};function Ae(){this.id=0;this.a=null;this.b=this.contentType=""};function De(a,b,c,d,e){D.call(this,a);this.c=b;this.a=new Vb(c,d,e);this.w=this.G=this.b=null;this.K=!1;this.g=null;this.l=!1;this.i=null;this.s=!1;this.h=new E;this.j=this.f=!1;this.B=0;this.L=15;this.D=!1}q(De,D);De.prototype.F=function(a){null!=a.initialStreamBufferSize&&(this.B=Number(a.initialStreamBufferSize));null!=a.streamBufferSize&&(this.L=Number(a.streamBufferSize));null!=a.segmentRequestTimeout&&(this.a.s=Number(a.segmentRequestTimeout))};
De.prototype.destroy=function(){Ee(this);this.h.destroy();this.b=this.h=null;this.a.destroy();this.v=this.c=this.a=null};k=De.prototype;k.oa=function(){return this.b};k.bb=function(){return this.G};k.sb=function(a){this.f||a.then(function(){this.f=!0;this.g||Fe(this,0)}.bind(this)).catch(function(){});return this.h};k.Ga=function(){return this.j};
k.ra=function(a,b,c){if(a!=this.b){var d=[a.I.create(),a.H.create()];Promise.all(d).then(F(this,function(d){if(this.c){var f=this.b;this.b=a;this.G=d[0];this.w=d[1];this.K=!0;this.l||(f?b&&Ge(this,!0,c):Fe(this,0))}})).catch(F(this,function(a){"aborted"!=a.type&&(this.f?(a=y(a),this.dispatchEvent(a)):this.h.reject(a))}))}};k.jb=function(){return Ge(this,!1)};
function Ge(a,b,c){a.b&&!a.l&&(a.l=!0,Ee(a),Xb(a.a).then(F(a,function(){var a=this.c.currentTime;if(!b&&0<Yb(this.a,a)&&0<=cc(this.a.b,a))return Promise.resolve();if(c)return fc(this.a,this.c.currentTime+c);this.D=!0;return ec(this.a)})).then(F(a,function(){this.l=!1;Fe(this,0)})).catch(F(a,function(a){this.l=!1;this.f?(a=y(a),this.dispatchEvent(a)):this.h.reject(a)})))}k.kb=function(a){return 0<Yb(this.a,a)&&0<=cc(this.a.b,a)};k.va=function(){};k.Da=function(){return!0};
k.Kb=function(){if(this.s&&!this.f)this.g=null;else{var a;if(a=this.f&&!this.j)a=1<this.a.c.buffered.length?!0:!1;if(a)Ge(this,!0);else{this.g=null;a=this.b;var b=this.G,c=this.c.currentTime;Yb(this.a,this.s?c:c+(this.i||0))>=(this.s?Math.max(this.B,this.L):this.B)?(He(this),Fe(this,1E3/(Math.abs(this.c.playbackRate)||1))):(b=Ie(this,c,b))?(b=Zb(this.a,b,a.c,this.w),this.w=null,this.K&&(this.K=!1,Je(this,a)),this.j=!1,b.then(F(this,function(a){null==this.i&&(this.i=a);this.D&&0<Yb(this.a,c)&&(this.D=
!1,this.c.currentTime+=.001);Fe(this,0)})).catch(F(this,function(a){if("aborted"!=a.type){var b=[0,404,410];"net"==a.type&&-1!=b.indexOf(a.xhr.status)&&this.b&&Fe(this,5E3);a=y(a);this.dispatchEvent(a)}}))):(He(this),this.f&&!this.j&&(this.j=!0,Ke(this)),Fe(this,1E3))}}};function Ie(a,b,c){a=a.a;var d=a.b.length;a=0<d?a.b[d-1]:null;return null!=a?null!=a.a?c.la(a.a):null:c.la(b)||(c.length()?c.A():null)}
function He(a){if(!a.s&&null!=a.i){a.s=!0;var b=a.a,c=a.i,d=c-b.w;0!=d&&(b.b=Yd(b.b,d),b.w=c);a.h.resolve(a.i)}}function Je(a,b){var c;c=b.a.split("/")[0];c=x({type:"adaptation",bubbles:!0,contentType:c,size:"video"!=c?null:{width:b.width,height:b.height},bandwidth:b.bandwidth});a.dispatchEvent(c)}function Ke(a){var b=x({type:"ended"});a.dispatchEvent(b)}function Fe(a,b){a.g=window.setTimeout(a.Kb.bind(a),b)}function Ee(a){null!=a.g&&(window.clearTimeout(a.g),a.g=null)};function Le(a){this.b=a;this.a=null}Le.prototype.destroy=function(){this.a&&(this.a.destroy(),this.a=null)};Le.prototype.create=function(){if(this.a)return Promise.resolve(this.a);var a=new Td(0,null,this.b);this.a=new R([a]);return Promise.resolve(this.a)};function Me(a,b){D.call(this,a);this.b=b;this.g=!0;this.h=this.f=null;this.c=new E;this.a=null}q(Me,D);Me.prototype.F=function(){};Me.prototype.destroy=function(){this.a&&this.b.removeChild(this.a);this.c.destroy();this.v=this.b=this.f=this.h=this.a=this.c=null};k=Me.prototype;k.oa=function(){return this.f};k.bb=function(){return this.h};k.sb=function(){return this.c};k.Ga=function(){return!0};
k.ra=function(a){a.I.create().then(F(this,function(b){if(this.b){if(0==b.length())return Promise.reject(Error("No subtitles URL available."));var c=this.f;this.f=a;this.h=b;b=S(b).url.b[0].toString();var d=this.Da();this.a&&(this.va(!1),this.b.removeChild(this.a));this.a=document.createElement("track");this.b.appendChild(this.a);this.a.src=b;this.va(d);b=x({type:"adaptation",bubbles:!0,contentType:"text",size:null,bandwidth:a.bandwidth});this.dispatchEvent(b);c||this.c.resolve(0)}}))};k.jb=function(){};
k.kb=function(){return!0};k.va=function(a){this.g=a;this.a&&(this.a.track.mode=a?"showing":"disabled")};k.Da=function(){this.a&&(this.g="showing"==this.a.track.mode);return this.g};function Ne(){}
Ne.prototype.parse=function(a,b,c,d){var e=null;try{var f;var g=new $a(b);if(440786851!=bb(g).id)f=null;else{var h=bb(g);if(408125543!=h.id)f=null;else{var l=h.a.byteOffset,m;var n=new $a(h.a);for(b=null;Va(n.a);){var t=bb(n);if(357149030==t.id){b=t;break}}if(b){for(var A=new $a(b.a),n=1E6;Va(A.a);){var N=bb(A);if(2807729==N.id){n=fb(N);break}}m=n/1E9}else m=null;f=m?{Qb:l,Ub:m}:null}}if(f){var I=bb(new $a(a));if(475249515!=I.id)e=null;else{var wa=f.Qb,Nb=f.Ub;a=[];var ee=new $a(I.a);for(f=I=-1;Va(ee.a);){var fe=
bb(ee);if(187==fe.id){var Ia;var ge=new $a(fe.a),he=bb(ge);if(179!=he.id)Ia=null;else{var Cf=fb(he),ie=bb(ge);if(183!=ie.id)Ia=null;else{for(var je=new $a(ie.a),l=0;Va(je.a);){var ke=bb(je);if(241==ke.id){l=fb(ke);break}}Ia={Wb:Cf,Pb:l}}}if(Ia){var le=Nb*Ia.Wb,me=wa+Ia.Pb;if(0<=I){var Uc=new G(d,c,f,me-1);a.push(new Td(I,le,Uc))}I=le;f=me}}}0<=I&&(Uc=new G(d,c,f,null),a.push(new Td(I,null,Uc)));e=a}}else e=null}catch(ne){if(!(ne instanceof RangeError))throw ne;}return e};function Oe(a,b,c,d,e,f,g){this.g=a;this.i=b;this.f=c;this.a=d;this.c=e;this.j=f;this.b=null;this.h=g}Oe.prototype.destroy=function(){this.h=this.i=this.g=null;this.a.g();this.a=null;this.c&&(this.c.g(),this.c=null);this.b=null};
Oe.prototype.create=function(){if(this.b)return this.b;var a=[bc(this.a)];"webm"==this.f&&a.push(bc(this.c));return this.b=Promise.all(a).then(F(this,function(a){var c=a[0];a=a[1]||null;var d=null;"mp4"==this.f?(d=new Zd,d=d.parse(new DataView(c),this.a.f,this.a.b,this.h)):"webm"==this.f&&(d=new Ne,d=d.parse(new DataView(c),new DataView(a),this.a.b,this.h));if(!d)return c=Error("Failed to parse SegmentReferences from "+this.a.toString()+" (or one of its fallbacks)."),c.type="stream",Promise.reject(c);
var e;"dynamic"==this.g.type?e=new T(d,this.g,this.i,this.j):e=new R(d);return Promise.resolve(e)}))};function Pe(a){this.a=a}
function Qe(a,b,c){for(var d=v()/1E3,e=0;e<b.a.length;++e)for(var f=b.a[e],g=0;g<f.b.length;++g){var h=f.b[g];if("text"!=h.contentType)for(var l=0;l<h.a.length;++l){var m=h.a[l],n=0,n=n+(m.g?1:0),n=n+(m.b?1:0),n=n+(m.a?1:0);0==n?(h.a.splice(l,1),--l):1!=n&&(m.g?(m.b=null,m.a=null):m.b&&(m.a=null))}}Re(b);for(e=0;e<b.a.length;++e)for(f=b.a[e],g=0;g<f.b.length;++g){l=h=f.b[g];m=null;for(n=0;n<l.a.length;++n){var t=l.a[n].f||"";m?t!=m&&(l.a.splice(n,1),--n):m=t}0==h.a.length&&(f.b.splice(g,1),--g)}"dynamic"==
b.type&&null==b.c&&(b.c=d);e=new Ce;"dynamic"==b.type&&(e.b=!0,e.f=b.g,e.g=new G(c,b.j||b.url),e.h=b.c);e.c=b.h||5;for(f=0;f<b.a.length;++f){g=b.a[f];if(null==g.start)break;g=Se(a,b,g,d,c);e.a.push(g)}return e}
function Re(a){if(a.a.length){null==a.a[0].start&&(a.a[0].start=0);var b=function(a){return 0==a||!!a};"dynamic"==a.type&&(a.b=null);b(a.b)&&1==a.a.length&&!b(a.a[0].a)&&(a.a[0].a=a.b);for(var c=0,d=!0,e=0;e<a.a.length;++e){var f=a.a[e-1],g=a.a[e],h=a.a[e+1]||{start:a.b};!b(g.start)&&f&&b(f.start)&&b(f.a)&&(g.start=f.start+f.a);!b(g.a)&&b(h.start)&&(g.a=h.start-g.start);null!=g.start&&null!=g.a?c+=g.a:d=!1}b(a.b)||(e=a.a[a.a.length-1],d?a.b=c:b(e.start)&&b(e.a)?a.b=e.start+e.a:"dynamic"!=a.type&&
(a.b=c))}}function Se(a,b,c,d,e){var f=new Be;f.id=c.id;f.start=c.start;f.b=c.a;var g=new z;c.b.forEach(function(a){g.push(a.contentType||"",a)});for(var h=wb(g),l=0;l<h.length;++l){var m=new z;g.get(h[l]).forEach(function(a){m.push(a.group,a)});for(var n=wb(m),t=0;t<n.length;++t){var A=new z;m.get(n[t]).forEach(function(a){A.push(a.lang,a)});for(var N=wb(A),I=0;I<N.length;++I){var wa=A.get(N[I]),wa=Te(a,b,c,wa,d,e);f.a.push(wa)}}}return f}
function Te(a,b,c,d,e,f){ba(d.every(function(a){return a.group==d[0].group&&(a.lang||"")==(d[0].lang||"")&&(a.contentType||"")==(d[0].contentType||"")}));var g=new xe,h=d.filter(function(a){return null!=a.id});h.length==d.length&&(g.id=h.map(function(a){return a.id}).sort().reduce(function(a,b){return a+","+b}));g.lang=d[0].lang||"";g.contentType=d[0].contentType||"";g.b=d.some(function(a){return a.c});for(var h={},l=0;l<d.length;++l)for(var m=d[l],n=0;n<m.a.length;++n){var t=m.a[n],A=Ue(a,t),N=g.a.slice(0);
Ve(A,N);0==N.length&&0<g.a.length||!(t=We(b,c,t,e,f))||(g.m.push(t),g.a=N,h[t.C]=m)}if(g.a.some(function(a){return""==a.a}))return g.m.forEach(function(a){a.N=!0}),g;a=Xe(d);for(l=0;l<g.m.length;++l)t=g.m[l],m=h[t.C],m==a&&(t.N=!0);return g}function Xe(a){for(var b=null,c=null,d=0;d<a.length;++d)for(var e=a[d],f=0;f<e.a.length;++f){var g=e.a[f],g=(g.width||1)*(g.height||1)*(g.bandwidth||1);if(null==b||g<b)b=g,c=e}return c}
function Ve(a,b){if(0==b.length)Array.prototype.push.apply(b,a);else for(var c=0;c<b.length;++c){for(var d=!1,e=0;e<a.length;++e){var f=b[c],g=a[e];if(f.a==g.a&&f.h==g.h&&f.i==g.i&&f.g==g.g&&f.v==g.v&&f.f==g.f&&f.j==g.j&&db(f.c,g.c)){d=!0;oc(b[c],a[e].b);break}}d||(b.splice(c,1),--c)}}function Ue(a,b){var c=[];if(0==b.c.length)c.push(new lc);else if(a.a)for(var d=0;d<b.c.length;++d)c.push.apply(c,Ye(a,b.c[d]));return c}
function Ye(a,b){var c=[];if(2!=a.a.length)return[];var d=a.a(b.c||"",b.f);if(!(d&&d instanceof Array))return[];for(var e=0;e<d.length;++e){var f=mc(d[e]);0==f.b.length&&b.a&&b.a.psshBox&&oc(f,[{initData:b.a.psshBox,initDataType:"cenc"}]);c.push(f)}return c}
function We(a,b,c,d,e){if(!c.u||0===c.u.length)return null;var f=null,g=1,h=0;if(c.g)f=c.f.split("/")[1],"mp4"!=f&&"webm"!=f?f=null:(g=c.g,"webm"!=f||g.c?g.a||g.b&&g.b.a?(h=g.b,h||(h=new od,h.url=c.u,h.a=g.a?g.a.clone():null),h=Ze(h,e),g=g.c?Ze(g.c,e):null,a=new Oe(a,b,f,h,g,d,e),b=new Wd(g),d=new ue,d.I=a,d.H=b,f=d):f=null:f=null),g=c.g.g,h=c.g.f;else if(c.b)f=c.b,!f.b&&!f.c&&1<f.a.length?f=null:f.b||b.a||f.c||1!=f.a.length?f.c&&0===f.c.a.length?f=null:(f=f.h?Ze(f.h,e):null,a=new re(a,b,c,d,e),b=
new Wd(f),d=new ue,d.I=a,d.H=b,f=d):f=null,g=c.b.f,h=c.b.g;else if(c.a){a:if(f=c.a,g=0+(f.f?1:0),g+=f.c?1:0,g+=f.b?1:0,0==g?g=!1:(1!=g&&(f.f?(f.c=null,f.b=null):f.c&&(f.b=null)),g=!0),g){g=null;if(f.g&&(g=(f=c.a.g)?$e(c,f,pd):null,!g)){f=null;break a}f=g?Ze(g,e):null;g=c.a;g.f?(g=c.f.split("/")[1],"mp4"!=g&&"webm"!=g?a=null:"webm"!=g||f?Sd(e,c,1,0)?(h=(h=c.a.f)?$e(c,h,od):null)?(h=Ze(h,e),a=new Oe(a,b,g,h,f,d,e)):a=null:a=null:a=null):a=g.h?g.c?new se(a,b,c,d,e):g.b?"dynamic"!=a.type&&null==b.a?null:
new qe(a,b,c,d,e):null:null;a?(b=new Wd(f),d=new ue,d.I=a,d.H=b,f=d):f=null}else f=null;g=c.a.a;h=c.a.i}else"text"==c.f.split("/")[0]&&(f=new ue,f.I=new Le(new G(e,c.u)));if(!f)return null;f.id=c.id;h&&(f.c=-1*h/g);f.bandwidth=c.bandwidth;f.width=c.width;f.height=c.height;f.a=c.f||"";f.b=c.h||"";for(a=0;a<c.c.length;++a)b=c.c[a],b.b&&f.f.push(b.b);return f}function $e(a,b,c){b=Ud(b,a.id,null,a.bandwidth,null);if(!b)return null;c=new c;c.url=Nd(a.u,b);return c}
function Ze(a,b){var c=a.url,d=0,e=null;a.a&&(d=a.a.na,e=a.a.end);return new G(b,c,d,e)};function af(){this.streamStats=null;this.droppedFrames=this.decodedFrames=NaN;this.bufferingTime=this.playTime=this.estimatedBandwidth=0;this.playbackLatency=NaN;this.bufferingHistory=[];this.bandwidthHistory=[];this.streamHistory=[]}function bf(a,b){var c=new cf(b);a.streamHistory.push(new df(c));if(c.videoHeight||!a.streamStats)a.streamStats=c}function cf(a){this.videoWidth=a.width;this.videoHeight=a.height;this.videoMimeType=a.a;this.videoBandwidth=a.bandwidth}
function df(a){this.timestamp=v()/1E3;this.value=a};function ef(a,b){Gb.call(this,"readwrite",b);this.j=a;this.b=0}q(ef,Gb);
function ff(a,b,c,d,e){for(var f=[],g=[],h=0,l=0,m=[],n=b.map(function(a){return a.I.create()}),n=Promise.all(n),t=b.map(function(a){return a.H.create()}),t=Promise.all(t),n=Promise.all([n,t]).then(function(a){f=a[0];g=a[1];h=f.reduce(function(a,b){return a+b.length()},0)}),t=0;t<b.length;++t)n=n.then(function(a){return gf(this,b[a],f[a],g[a],h,l)}.bind(a,t)),n=n.then(function(a,b){l+=f[a].length();m.push(b)}.bind(a,t));return n.then(F(a,function(){return hf(Ob(this))})).then(F(a,function(a){var b=
new E;c=Ra(c);var f={group_id:a,stream_ids:m,session_ids:c,duration:d,key_system:e.a,license_server:e.h,with_credentials:e.i,distinctive_identifier:e.g,audio_robustness:e.f,video_robustness:e.j},g=Ob(this).put(f);g.onsuccess=function(){b.resolve(a)};g.onerror=function(){b.reject(g.error)};return b}))}function jf(a,b){return Pb(Ob(a),b).then(F(a,function(a){var d=[],e;for(e in a.stream_ids)d.push(kf(this,a.stream_ids[e]));a=Ob(this);d.push(a.delete(b));return Promise.all(d)}))}
function gf(a,b,c,d,e,f){var g=[hf(Mb(a)),hf(Kb(a).index("stream"))],g=Promise.all(g).then(F(a,function(a){return{qa:Math.max(a[0],a[1]),ja:new ArrayBuffer(0),Ja:0,o:[],Ca:null,Vb:e,ib:f}})),g=g.then(a.f.bind(a,c));return g=g.then(a.g.bind(a,b,d))}function hf(a){var b=new E,c=a.openCursor(null,"prev");c.onsuccess=function(a){a.target.result?b.resolve(a.target.result.key+1):b.resolve(0)};c.onerror=function(){b.reject(c.error)};return b}
ef.prototype.g=function(a,b,c){var d=new E;a={stream_id:c.qa,mime_type:a.a,codecs:a.b,init_segment:b,references:c.o};var e=Mb(this).put(a);e.onsuccess=function(){d.resolve(c.qa)};e.onerror=function(){d.reject(e.error)};return d};ef.prototype.f=function(a,b){for(var c=Promise.resolve(),d=0;d<a.length();++d)var e=a.get(d),f=d==a.length()-1,f=this.c.bind(this,e,b,f),c=c.then(this.i.bind(this,e)),c=c.then(f);return c.then(function(){return Promise.resolve(b)}).catch(F(this,function(a){kf(this,b.qa);return Promise.reject(a)}))};
ef.prototype.c=function(a,b,c,d){var e=new E;0==b.ja.byteLength&&(b.Ca=a);b.ja=lf(b.ja,d);b.ib++;var f=x({type:"progress",detail:b.ib/b.Vb*100,bubbles:!0});if(1048576<=b.ja.byteLength||c){c={stream_id:b.qa,segment_id:b.Ja,content:b.ja};var g=Kb(this).put(c);b.o.push({start_time:b.Ca.b,start_byte:b.Ca.url.f,end_time:a.a,url:"idb://"+b.qa+"/"+b.Ja});b.Ja++;b.ja=new ArrayBuffer(0);g.onerror=function(){e.reject(g.error)};g.onsuccess=F(this,function(){this.dispatchEvent(f);e.resolve()})}else this.dispatchEvent(f),
e.resolve();return e};function lf(a,b){var c=new Uint8Array(a.byteLength+b.byteLength);c.set(new Uint8Array(a),0);c.set(new Uint8Array(b),a.byteLength);return c.buffer}ef.prototype.i=function(a){var b=new ac;b.c=1E3*this.b;return bc(a.url,b,this.j)};
function kf(a,b){var c=new E,d=Mb(a).delete(b);d.onerror=function(){c.reject(d.error)};var e=Kb(a);e.index("stream").openKeyCursor(IDBKeyRange.only(b)).onsuccess=function(a){if(a=a.target.result)e.delete(a.primaryKey),a.continue()};e.transaction.oncomplete=function(){c.resolve()};return c};function mf(a,b,c,d,e,f){this.b=new G(null,[new H(a)]);this.a=new ac;this.a.body=b;this.a.method=c;this.a.a=3;this.a.j=d;this.a.c=1E3*(null!=f?f:0);a=e||{};for(var g in a)this.a.b[g]=a[g]}function nf(a){return bc(a.b,a.a).then(function(a){return Promise.resolve(new Uint8Array(a))})};function U(a,b,c){D.call(this,a);this.h=b;this.b=c;this.a=this.i=null;this.l=new B;this.c=[];this.f=[];this.s=0;this.g=new E;this.j=null;this.w=0}q(U,D);U.prototype.destroy=function(){this.v=null;for(var a=0;a<this.f.length;++a)this.f[a].close().catch(function(){});this.f=[];this.c=this.a=this.i=null;this.g.destroy();this.g=null;this.l.destroy();this.l=null;this.j&&(window.clearTimeout(this.j),this.j=null);this.h=this.b=null};
U.prototype.initialize=function(){for(var a=new z,b=this.b.ab(),c=0;c<b.length;++c){var d=b[c];d.a.a||d.b&&!of(d.b)||a.push(d.contentType,d)}for(var c={},d=!1,e=0;e<b.length;++e){var f=b[e];if(f.a.a&&!a.a.hasOwnProperty(f.contentType)){var g=f.a.a,h=c[g];h||(h=f.a,h={audioCapabilities:void 0,videoCapabilities:void 0,initDataTypes:void 0,distinctiveIdentifier:h.g?"required":"optional",persistentState:h.v||this.b.ha()?"required":"optional",sessionTypes:[this.b.ha()?"persistent-license":"temporary"]},
c[g]=h);if(f.b&&(g=f.contentType+"Capabilities",g in h)){d=!0;h[g]||(h[g]=[]);var l;"audio"==f.contentType?l=f.a.f:"video"==f.contentType&&(l=f.a.j);h[g].push({contentType:f.b,robustness:l})}}}if(!d)if(b.length)this.a=b[0].a;else throw (a=Error("No DrmInfo exists!"), a.type="drm", a);if(0==Object.keys(c).length)return this.b.Ka(a),this.g.resolve(),Promise.resolve();l=new E;c=pf(this,c,l);c=c.then(this.D.bind(this,b,a));l.reject(null);return c};
function qf(a,b){null==a.j&&(a.j=window.setTimeout(function(){var a=Error("Timeout waiting for sessions.");a.type="storage";this.g.reject(a)}.bind(a),b));return a.g}function rf(a){return Promise.all(a.f.map(function(a){return a.remove()}))}
function pf(a,b,c){for(var d in b)c=c.catch(function(a,b){return navigator.requestMediaKeySystemAccess(a,[b])}.bind(null,d,b[d]));a.b.ha()&&(c=c.catch(function(){throw Error("Either none of the requested key systems are supported or none of the requested key systems support persistent state.");}));return c}
U.prototype.D=function(a,b,c){if(!this.h)return sf();for(var d=c.keySystem,e=c.getConfiguration(),f=["audio","video"],g=0;g<f.length;++g){var h=f[g];if(!b.a.hasOwnProperty(h)){var l=e[h+"Capabilities"];if(l){for(var l=l[0],m=[],n={},t=0;t<a.length;++t){var A=a[t],N=l?A.b==l.contentType:A.contentType==h;A.a.a!=d||!N||A.id in n||(m.push(A),n[A.id]=!0,this.a=this.a?nc(this.a,A.a):A.a)}b.set(h,m)}}}this.b.Ka(b);return c.createMediaKeys().then(function(a){this.i=a}.bind(this))};
function tf(a){return a.h?a.i?a.h.setMediaKeys(a.i).then(F(a,function(){return this.h?this.a.c?this.i.setServerCertificate(this.a.c):Promise.resolve():sf()})).then(F(a,function(){if(!this.h)return sf();if(0<this.b.ua().length)uf(this);else{for(var a=0;a<this.a.b.length;++a){var c=this.a.b[a];this.B({type:"encrypted",initDataType:c.initDataType,initData:c.initData})}0==this.a.b.length&&C(this.l,this.h,"encrypted",this.B.bind(this))}})):Promise.resolve():sf()}
function sf(){var a=Error("EmeManager destroyed");a.type="destroy";return Promise.reject(a)}
U.prototype.B=function(a){for(var b=new Uint8Array(a.initData),c=0;c<this.c.length;++c)if(db(b,this.c[c].data))return;try{var d=vf(this)}catch(e){b=y(e);this.dispatchEvent(b);this.g.reject(e);return}a=d.generateRequest(a.initDataType,a.initData);this.c.push({data:b,La:d});a.catch(F(this,function(a){if(this.h){for(var b=0;b<this.c.length;++b)if(this.c[b].La==d){this.c.splice(b,1);break}b=y(a);this.dispatchEvent(b);this.g.reject(a)}}));this.f.push(d)};
function uf(a){for(var b=a.b.ua(),c=0;c<b.length;++c){var d=vf(a),e=d.load(b[c]);a.f.push(d);e.then(F(a,function(){this.s++;this.s>=this.f.length&&this.g.resolve()})).catch(F(a,function(a){a=y(a);this.dispatchEvent(a)}))}}
function vf(a){var b=null;if(a.b.ha())try{b=a.i.createSession("persistent-license")}catch(c){throw Error("Persistent licenses are not supported by this key system or platform.");}else b=a.i.createSession();C(a.l,b,"message",a.G.bind(a));C(a.l,b,"keystatuseschange",a.F.bind(a));return b}U.prototype.G=function(a){wf(this,a.target,this.a,a.message)};
U.prototype.F=function(a){a=a.target;var b={};a.keyStatuses.forEach(function(a,c){if("string"==typeof a){var f=a;a=c;c=f}if("com.microsoft.playready"==this.a.a&&16==a.byteLength){var f=new DataView(a),g=f.getUint32(0,!0),h=f.getUint16(4,!0),l=f.getUint16(6,!0);f.setUint32(0,g,!1);f.setUint16(4,h,!1);f.setUint16(6,l,!1)}f=kc(new Uint8Array(a));b[f]=c}.bind(this));if(a.expiration<Date.now()){for(var c=0;c<this.c.length;++c)if(this.c[c].La==a){this.c.splice(c,1);break}a.close();this.f.splice(this.f.indexOf(a),
1)}this.b.cb(b)};function wf(a,b,c,d){d=xf(c,d);nf(new mf(d.url,d.body,d.method,c.i,d.headers,a.w)).then(F(a,function(a){c.l&&(a=c.l(a));return b.update(a)})).then(F(a,function(){var a=x({type:"sessionReady",detail:b});this.dispatchEvent(a);this.s++;this.s>=this.f.length&&this.g.resolve()})).catch(F(a,function(a){a.La=b;a=y(a);this.dispatchEvent(a)}))}
function xf(a,b){var c={url:a.h,body:b.slice(0),method:"POST",headers:{}};if("com.microsoft.playready"===a.a){for(var d=String.fromCharCode.apply(null,new Uint16Array(c.body)),d=(new DOMParser).parseFromString(d,"application/xml"),e=d.getElementsByTagName("name"),f=d.getElementsByTagName("value"),g=0;g<e.length;g++)c.headers[e[g].childNodes[0].nodeValue]=f[g].childNodes[0].nodeValue;c.body=window.atob(d.getElementsByTagName("Challenge")[0].childNodes[0].nodeValue)}if(!a.s)return c;a.s(c);c.url=sb(c,
"url");if(null==c.url)throw Error("'url' cannot be null.");if(!(c.body instanceof ArrayBuffer||"string"==typeof c.body||null==c.body))throw new TypeError("'body' must be an ArrayBuffer, a string, or null.");c.method=sb(c,"method");if("GET"!=c.method&&"POST"!=c.method)throw Error("'method' must be either 'GET' or 'POST'.");c.headers=tb(c,"headers",Object);if(null==c.headers)throw Error("'headers' cannot be null.");return c};function V(a){D.call(this,null);this.a=a;this.b=null;this.f=new B;this.j=this.i=null;this.D=0;this.w=null;this.h=!1;this.g=new af;this.c={enableAdaptation:!0,streamBufferSize:15,liveStreamEndTimeout:15,licenseRequestTimeout:0,mpdRequestTimeout:0,segmentRequestTimeout:0,preferredLanguage:"en",restrictions:new ja};this.l=1;this.F=null}q(V,D);p("shaka.player.Player",V);V.version="v1.6.5";
V.isBrowserSupported=function(){return!!window.MediaSource&&!!window.MediaKeys&&!!window.navigator&&!!window.navigator.requestMediaKeySystemAccess&&!!window.MediaKeySystemAccess&&!!window.MediaKeySystemAccess.prototype.getConfiguration&&!!window.Promise&&!!Element.prototype.requestFullscreen&&!!document.exitFullscreen&&"fullscreenElement"in document&&!!window.Uint8Array};function of(a){return"text/vtt"==a?!!window.VTTCue:MediaSource.isTypeSupported(a)}V.isTypeSupported=of;
V.setTextStyle=function(a){var b=document.getElementById("ShakaPlayerTextStyle");b||(b=document.createElement("style"),b.id="ShakaPlayerTextStyle",document.head.appendChild(b));for(b=b.sheet;b.cssRules.length;)b.deleteRule(0);b.insertRule("::cue { "+oa(a)+" }",0)};V.prototype.destroy=function(){return this.s().then(F(this,function(){this.f.destroy();this.a=this.f=null})).catch(function(){})};V.prototype.destroy=V.prototype.destroy;
V.prototype.s=function(){if(!this.b)return Promise.resolve();this.h&&yf(this);this.a.pause();xb(this.f);zf(this);Af(this);this.i&&(this.i.destroy(),this.i=null);this.a.src="";var a=this.a.setMediaKeys(null);this.b&&(this.b.destroy(),this.b=null);this.h=!1;this.g=new af;return a};V.prototype.unload=V.prototype.s;
V.prototype.ea=function(a){var b=this.s();this.a.autoplay&&(da("load"),C(this.f,this.a,"timeupdate",this.wb.bind(this)));a.T(this.c);a.pb(this.F);this.F=null;b=b.then(F(this,function(){return a.X()}));b.catch(F(this,function(b){a.destroy();return Promise.reject(b)}));return b.then(F(this,function(){if(!this.a)return Bf();this.b=a;C(this.f,this.b,"seekrangechanged",this.Fb.bind(this));this.i=new U(this,this.a,this.b);return this.i.initialize()})).then(F(this,function(){if(!this.a)return Bf();C(this.f,
this.a,"error",this.Rb.bind(this));C(this.f,this.a,"playing",this.Db.bind(this));C(this.f,this.a,"pause",this.Cb.bind(this));return this.b.lb(this,this.a)})).then(F(this,function(){return this.a?tf(this.i):Bf()})).then(F(this,function(){if(!this.a)return Bf();Df(this)})).catch(F(this,function(a){if(!this.a)return Bf();if("destroy"!=a.type){var b=y(a);this.dispatchEvent(b)}return this.s().then(function(){return Promise.reject(a)})}))};V.prototype.load=V.prototype.ea;
function Bf(){var a=Error("Player destroyed");a.type="destroy";return Promise.reject(a)}k=V.prototype;k.wb=function(){ga("load");this.g.playbackLatency=ha("load")/1E3;this.f.sa(this.a,"timeupdate")};k.Rb=function(){if(this.a.error){var a=this.a.error.code;a!=MediaError.MEDIA_ERR_ABORTED&&(a=Error(Ef[a]||"Unknown playback error."),a.type="playback",a=y(a),this.dispatchEvent(a))}};
k.Db=function(){da("playing");!this.j&&0>this.l&&(this.a.playbackRate=0,this.B(this.a.currentTime,Date.now(),this.l));this.h&&yf(this)};k.Cb=function(){ga("playing");var a=ha("playing");if(!isNaN(a)){var b=this.g;b.playTime+=a/1E3}Af(this)};k.Fb=function(a){this.D=a.start};
k.qb=function(){if(!this.a.paused){ga("playing");var a=ha("playing");if(!isNaN(a)){var b=this.g;b.playTime+=a/1E3;da("playing")}}a=this.g;b=this.a;b.getVideoPlaybackQuality&&(b=b.getVideoPlaybackQuality(),a.decodedFrames=b.totalVideoFrames,a.droppedFrames=b.droppedVideoFrames);return this.g};V.prototype.getStats=V.prototype.qb;V.prototype.da=function(){return this.b?this.b.ma():[]};V.prototype.getVideoTracks=V.prototype.da;V.prototype.Y=function(){return this.b?this.b.pa():[]};
V.prototype.getAudioTracks=V.prototype.Y;V.prototype.$=function(){return this.b?this.b.Oa():[]};V.prototype.getTextTracks=V.prototype.$;V.prototype.selectVideoTrack=function(a,b){return this.b?this.b.selectVideoTrack(a,void 0==b?!0:b):!1};V.prototype.selectVideoTrack=V.prototype.selectVideoTrack;V.prototype.M=function(a,b,c){return this.b?this.b.nb(a,void 0==b?!0:b,c):!1};V.prototype.selectAudioTrack=V.prototype.M;V.prototype.fa=function(a){return this.b?this.b.ob(a,!1):!1};
V.prototype.selectTextTrack=V.prototype.fa;V.prototype.V=function(a){this.b&&this.b.Na(a)};V.prototype.enableTextTrack=V.prototype.V;V.prototype.T=function(a){Af(this);0<=a?this.a.playbackRate=a:this.a.paused||(this.a.playbackRate=0,this.B(this.a.currentTime,Date.now(),a));this.l=a};V.prototype.setPlaybackRate=V.prototype.T;V.prototype.K=function(){return this.l};V.prototype.getPlaybackRate=V.prototype.K;V.prototype.R=function(a){this.F=a};V.prototype.setPlaybackStartTime=V.prototype.R;
V.prototype.G=function(){return this.b?this.b.mb():!1};V.prototype.isLive=V.prototype.G;
V.prototype.U=function(a){if(a){var b=pb(a,"enableAdaptation");null!=b&&(this.c.enableAdaptation=b);b=rb(a,"streamBufferSize");null!=b&&(this.c.streamBufferSize=b);b=rb(a,"liveStreamEndTimeout");null!=b&&(this.c.liveStreamEndTimeout=b);b=rb(a,"licenseRequestTimeout");null!=b&&(this.c.licenseRequestTimeout=b);b=rb(a,"mpdRequestTimeout");null!=b&&(this.c.mpdRequestTimeout=b);b=rb(a,"segmentRequestTimeout");null!=b&&(this.c.segmentRequestTimeout=b);b=sb(a,"preferredLanguage");null!=b&&(this.c.preferredLanguage=
b);b=tb(a,"restrictions",ja);null!=b&&(this.c.restrictions=b.clone());a=pb(a,"disableCacheBustingEvenThoughItMayAffectBandwidthEstimation");null!=a&&(Hd=!a);this.b&&this.b.T(this.c)}};V.prototype.configure=V.prototype.U;V.prototype.Z=function(){return this.c};V.prototype.getConfiguration=V.prototype.Z;function Af(a){a.j&&(window.clearTimeout(a.j),a.j=null)}function Df(a){zf(a);a.w=window.setTimeout(a.L.bind(a),100)}function zf(a){a.w&&(window.clearTimeout(a.w),a.w=null)}
V.prototype.B=function(a,b,c){this.j=null;var d=(Date.now()-b)/1E3*c;this.a.currentTime<this.D+(this.G()?1:.05)?this.a.pause():(d=Math.max(this.D,a+d),this.a.currentTime=d,this.j=window.setTimeout(this.B.bind(this,a,b,c),250))};function yf(a){ga("buffering");var b=a.g;b.bufferingTime+=ha("buffering")/1E3;a.h=!1;a.dispatchEvent(x({type:"bufferingEnd"}))}
V.prototype.L=function(){Df(this);if(!this.a.ended&&!this.a.seeking){var a=this.a.buffered,b=a.length?a.end(a.length-1):0,a=Math.max(b-this.a.currentTime,0),c=this.a.duration,c=isNaN(c)?0:Math.max(c-.05,0),b=b>=c||this.a.currentTime>=c;if(this.h){if(c=this.b.$a(),b||a>c)yf(this),this.a.play()}else!this.a.paused&&!b&&.5>a&&(this.h=!0,this.a.pause(),this.g.bufferingHistory.push(v()/1E3),da("buffering"),this.dispatchEvent(x({type:"bufferingStart"})))}};
var Ef={2:"A network failure occured while loading media content.",3:"The browser failed to decode the media content.",4:"The browser does not support the media content."};function Ff(a){for(var b=0;b<a.length;++b)for(var c=a[b],d=0;d<c.a.length;++d){for(var e=c.a[d],f=e,g=0;g<f.m.length;++g)of(we(f.m[g]))||(f.m.splice(g,1),--g);0==e.m.length&&(c.a.splice(d,1),--d)}}function Gf(a){for(var b=0;b<a.length;++b)for(var c=a[b],d=0;d<c.a.length;++d)c.a[d].m.sort(Hf)}function Hf(a,b){var c=a.bandwidth||Number.MAX_VALUE,d=b.bandwidth||Number.MAX_VALUE;return c<d?-1:c>d?1:0};function If(a){this.a=a}If.prototype.destroy=function(){this.a.destroy();this.a=null};If.prototype.update=function(a){var b=Jf(a),c=Jf(this.a);return Promise.all([b,c]).then(F(this,function(b){var c=b[0];b=b[1];var f=this.a.a;Ff(f);Gf(f);a.f=this.a.f;a.g=this.a.g?this.a.g.clone():null;a.c=this.a.c;f=[];Kf(a,this.a,c,b,f);c=a.a;Ff(c);Gf(c);return Promise.resolve(f)}))};
function Jf(a){function b(a,b){return a.concat(b)}var c=a.a.map(function(a){return a.a}).reduce(b,[]).map(function(a){return a.m}).reduce(b,[]);a=c.map(function(a){return a.I.create()});return Promise.all(a).then(function(a){for(var b={},f=0;f<c.length;++f)b[c[f].C]=a[f];return Promise.resolve(b)})}
function Kf(a,b,c,d,e){var f=new z;a.a.forEach(function(a,b){f.push(a.id||""+b,a)});var g=new z;b.a.forEach(function(a,b){g.push(a.id||""+b,a)});a=wb(f);for(b=0;b<a.length;++b){var h=a[b],l=f.get(h);1<l.length||(h=g.get(h))&&0!=h.length&&1==h.length&&(Lf(l[0],h[0],c,d,e),l[0].b=h[0].b)}}
function Lf(a,b,c,d,e){var f=new z;a.a.forEach(function(a,b){f.push(a.id||""+b,a)});var g=new z;b.a.forEach(function(a,b){g.push(a.id||""+b,a)});a=wb(f);for(b=0;b<a.length;++b){var h=a[b],l=f.get(h);1<l.length||(h=g.get(h))&&0!=h.length&&1==h.length&&Mf(l[0],h[0],c,d,e)}}
function Mf(a,b,c,d,e){var f=new z;a.m.forEach(function(a,b){f.push(a.id||""+b,a)});var g=new z;b.m.forEach(function(a,b){g.push(a.id||""+b,a)});b={};for(var h=wb(f),l=0;l<h.length;++l){var m=h[l];b[m]=m;var n=f.get(m);1<n.length||((m=g.get(m))&&0!=m.length?1==m.length&&(Nf(n[0],m[0],c,d),n[0].H=m[0].H,m[0].H=null,n[0].c=m[0].c):(e.push(n[0]),a.m.splice(a.m.indexOf(n[0]),1)))}h=wb(g);for(l=0;l<h.length;++l)m=h[l],b[m]||(b[m]=m,m=g.get(m),a.m.push(m[0]))}
function Nf(a,b,c,d){a=c[a.C];b=d[b.C];a.length();a.Ha(b)&&a.length()};function W(){this.a=this.b=null;this.f=new B;this.c=Number.POSITIVE_INFINITY;this.i=!0;this.g=!1}p("shaka.media.SimpleAbrManager",W);W.prototype.destroy=function(){this.f.destroy();this.a=this.b=this.f=null};W.prototype.initialize=function(a,b){this.b||this.a||(this.b=a,this.a=b)};
W.prototype.start=function(){this.b&&this.a&&!this.g&&(this.c=Date.now()+4E3,C(this.f,this.b,"bandwidth",this.v.bind(this)),C(this.f,this.a,"adaptation",this.j.bind(this)),C(this.f,this.a,"trackschanged",this.h.bind(this)),this.g=!0)};W.prototype.enable=function(a){this.i=a};W.prototype.getInitialVideoTrackId=function(){if(!this.b||!this.a)return null;var a=Of(this);return a?a.id:null};W.prototype.selectVideoTrack=function(a,b,c){this.g&&this.a.selectVideoTrack(a.id,b,c)};
W.prototype.v=function(){Date.now()<this.c||this.h()};W.prototype.h=function(){if(this.i){var a=Of(this);if(a){if(a.active){this.c=Date.now()+3E3;return}this.selectVideoTrack(a,!1)}this.c=Number.POSITIVE_INFINITY}};W.prototype.j=function(){this.c==Number.POSITIVE_INFINITY&&(this.c=Date.now()+3E4)};
function Of(a){var b=a.a.ma();if(0==b.length)return null;b.sort(sa);var c;a:{c=a.a.pa();for(var d=0;d<c.length;++d)if(c[d].active){c=c[d];break a}c=null}c=c?c.bandwidth:0;a=a.b.getBandwidth();for(var d=b[0],e=0;e<b.length;++e){var f=b[e],g=e+1<b.length?b[e+1]:{bandwidth:Number.POSITIVE_INFINITY};if(f.bandwidth&&(g=(g.bandwidth+c)/.85,a>=(f.bandwidth+c)/.95&&a<=g&&(d=f,d.active)))break}return d};function Pf(a,b,c){D.call(this,null);this.f=a;this.c=b;this.b=mc(c);this.a=null}q(Pf,D);p("shaka.player.HttpVideoSource",Pf);Pf.prototype.T=function(){};Pf.prototype.destroy=function(){this.a&&(this.a.parentElement.removeChild(this.a),this.a=null);this.v=this.b=null};k=Pf.prototype;k.lb=function(a,b){this.v=a;var c=b.mediaKeys;b.src=this.f;c=b.setMediaKeys(c);this.c&&(this.a=document.createElement("track"),this.a.src=this.c,b.appendChild(this.a),this.a.track.mode="showing");return c};k.X=function(){return Promise.resolve()};
k.ma=function(){return[]};k.pa=function(){return[]};k.Oa=function(){return[]};k.$a=function(){return 5};k.ab=function(){var a=new Ae;a.a=this.b;return[a]};k.Ka=function(){};Pf.prototype.selectVideoTrack=function(){return!1};k=Pf.prototype;k.nb=function(){return!1};k.ob=function(){return!1};k.Na=function(a){this.a&&(this.a.track.mode=a?"showing":"disabled")};k.pb=function(){};k.ua=function(){return[]};k.ha=function(){return!1};k.mb=function(){return!1};
k.cb=function(a){for(var b in a){var c=a[b],d=gb[c]||null;if(d){var e=Bb(b),d=Error("Key "+e+" is not usable. "+d);d.type="drm";d.code=c;c=y(d);this.dispatchEvent(c)}}};function X(a,b,c){D.call(this,null);this.a=a;this.Z=b;this.i=new B;this.g=new MediaSource;this.f=null;this.da=0;this.b=new z;this.G=c;this.G.initialize(b,this);this.L=!1;this.K="en";this.fa=!1;this.U=null;this.B=new E;this.h=new ja;this.D=null;this.Va=1;this.c={};this.ea=new E;this.Ta=0;this.Ua=15;this.w=null;this.Ra=this.Sa=!1;this.s={};this.$=this.Y=this.V=null;this.F={}}q(X,D);p("shaka.player.StreamVideoSource",X);
X.prototype.T=function(a){null!=a.streamBufferSize&&(this.F.streamBufferSize=a.streamBufferSize);null!=a.segmentRequestTimeout&&(this.F.segmentRequestTimeout=a.segmentRequestTimeout);Qf(this);null!=a.enableAdaptation&&this.G.enable(Boolean(a.enableAdaptation));null!=a.mpdRequestTimeout&&(this.da=Number(a.mpdRequestTimeout));null!=a.liveStreamEndTimeout&&(this.Ua=Number(a.liveStreamEndTimeout));null!=a.preferredLanguage&&(this.K=kb(String(a.preferredLanguage)));null!=a.restrictions&&(this.h=a.restrictions,
this.L&&Rf(this))};X.prototype.destroy=function(){this.B.destroy();this.ea.destroy();this.ea=this.B=null;this.Y&&(window.clearTimeout(this.Y),this.Y=null);this.V&&(window.clearTimeout(this.V),this.V=null);this.s=null;this.i.destroy();this.i=null;ob(this.c).forEach(function(a){a.destroy()});this.b=this.c=null;this.a&&(this.a.destroy(),this.a=null);this.G.destroy();this.v=this.h=this.U=this.f=this.g=this.Z=this.G=null};k=X.prototype;
k.lb=function(a,b){if(!this.L){var c=Error("Cannot call attach() right now.");c.type="app";return Promise.reject(c)}this.v=a;this.f=b;this.U=a.qb();C(this.i,this.g,"sourceopen",this.yb.bind(this));C(this.i,this.Z,"bandwidth",this.Sb.bind(this));this.a.b&&(C(this.i,a,"bufferingStart",this.vb.bind(this)),C(this.i,a,"bufferingEnd",this.ub.bind(this)));c=this.f.mediaKeys;this.f.src=window.URL.createObjectURL(this.g);c=this.f.setMediaKeys(c);return Promise.all([this.B,c])};
k.X=function(){if(this.L){var a=Error("Cannot call load() right now.");a.type="app";return Promise.reject(a)}if(!this.a||0==this.a.a.length)return a=Error("The manifest does not specify any content."),a.type="stream",Promise.reject(a);a=this.a.a;Ff(a);Gf(a);if(0==this.a.a.length||0==this.a.a[0].a.length)return a=Error("The manifest specifies content that cannot be displayed on this browser/platform."),a.type="stream",Promise.reject(a);this.L=!0;this.F.initialStreamBufferSize=this.a.c;Qf(this);Rf(this);
return Promise.resolve()};k.gb=function(a){var b=Date.now(),c=this.V=null,d=this.a.g;(a?this.eb():this.fb(d)).then(F(this,function(a){c=new If(a);return c.update(this.a)})).then(F(this,function(a){c.destroy();c=null;for(var d=0;d<a.length;++d)Sf(this,a[d]);this.F.initialStreamBufferSize=this.a.c;Qf(this);Rf(this);0==Object.keys(this.c).length?Tf(this):Uf(this,(Date.now()-b)/1E3)})).catch(F(this,function(a){c&&(c.destroy(),c=null);"aborted"!=a.type&&(a=y(a),this.dispatchEvent(a),this.a&&Uf(this,0))}))};
k.fb=function(){return Promise.reject("Cannot update manifest with this VideoSource implementation.")};k.eb=function(){return Promise.reject("Cannot update manifest with this VideoSource implementation.")};function Uf(a,b){if(null!=a.a.f){var c=Math.max(a.a.f,3),c=Math.max(c-b,0);a.V=window.setTimeout(a.gb.bind(a,!1),1E3*c)}}
function Sf(a,b){var c=b.a.split("/")[0],d=a.c[c];if(d&&d.oa()==b){var e=a.b.get(b.a.split("/")[0]).map(function(a){return a.m}).reduce(function(a,b){return a.concat(b)},[]).filter(function(a){return a.N&&a.J});if(0==e.length){c=Error("All usable streams have been removed from the manifest.");c.type="app";c=y(c);a.dispatchEvent(c);return}a.s[c].Pa==b&&delete a.s[c];d.ra(e[0],!0);b.destroy()}b.destroy()}
k.ma=function(){if(!this.b.a.hasOwnProperty("video"))return[];for(var a=this.c.video,a=(a=a?a.oa():null)?a.C:0,b=[],c=this.b.get("video"),d=0;d<c.length;++d)for(var e=c[d],f=0;f<e.m.length;++f){var g=e.m[f];if(g.N&&g.J){var h=g.C,g=new ra(h,g.bandwidth,g.width,g.height);h==a&&(g.active=!0);b.push(g)}}return b};X.prototype.getVideoTracks=X.prototype.ma;
X.prototype.pa=function(){if(!this.b.a.hasOwnProperty("audio"))return[];for(var a=this.c.audio,a=(a=a?a.oa():null)?a.C:0,b=[],c=this.b.get("audio"),d=0;d<c.length;++d)for(var e=c[d],f=e.lang,g=0;g<e.m.length;++g){var h=e.m[g];if(h.N&&h.J){var l=h.C,h=new ia(l,h.bandwidth,f);l==a&&(h.active=!0);b.push(h)}}return b};X.prototype.getAudioTracks=X.prototype.pa;
X.prototype.Oa=function(){if(!this.b.a.hasOwnProperty("text"))return[];for(var a=this.c.text,b=a?a.oa():null,b=b?b.C:0,c=[],d=this.b.get("text"),e=0;e<d.length;++e)for(var f=d[e],g=f.lang,h=0;h<f.m.length;++h){var l=f.m[h].C,m=new qa(l,g);l==b&&(m.active=!0,m.enabled=a.Da());c.push(m)}return c};X.prototype.getTextTracks=X.prototype.Oa;X.prototype.$a=function(){return Number(this.F.initialStreamBufferSize)};
X.prototype.ab=function(){var a;if(this.L){a=this.a.a[0];for(var b=[],c=0;c<a.a.length;++c)b.push.apply(b,ze(a.a[c]));a=b}else a=[];return a};
X.prototype.Ka=function(a){if(this.L){for(var b={},c=this.a.a[0],d=0;d<c.a.length;++d){var e=c.a[d];b[e.C]=e}this.b.a={};c=wb(a);for(d=0;d<c.length;++d){var e=c[d],f=a.get(e);if("video"==e){var g=f[0].id;this.b.push(e,b[g])}else if("audio"==e)for(var g=f[0].b.split(";")[0],h=0;h<f.length;++h){var l=f[h];l.b.split(";")[0]==g&&this.b.push(e,b[l.id])}else for(h=0;h<f.length;++h)g=f[h].id,this.b.push(e,b[g])}this.fa=!0;if(a=this.b.get("audio"))Vf(this,a),this.b.set("audio",a),a=a[0].lang||this.K,jb(2,
this.K,a)&&(this.fa=!1);if(a=this.b.get("text"))Vf(this,a),this.b.set("text",a),a=a[0].lang||this.K,jb(2,this.K,a)||(this.fa=!1)}};X.prototype.selectVideoTrack=function(a,b,c){return Wf(this,"video",a,b,c)};k=X.prototype;k.nb=function(a,b,c){return Wf(this,"audio",a,b,c)};k.ob=function(a,b){return Wf(this,"text",a,b)};k.Na=function(a){var b=this.c.text;b&&b.va(a)};k.pb=function(a){this.$=a};
function Rf(a){if(a.h){for(var b=!1,c=0;c<a.a.a.length;++c)for(var d=a.a.a[c],e=0;e<d.a.length;++e){var f=d.a[e];if("video"==f.contentType)for(var g=0;g<f.m.length;++g){var h=f.m[g],l=h.J;h.J=!0;a.h.maxWidth&&h.width>a.h.maxWidth&&(h.J=!1);a.h.maxHeight&&h.height>a.h.maxHeight&&(h.J=!1);a.h.minHeight&&h.height<a.h.minHeight&&(h.J=!1);a.h.maxBandwidth&&h.bandwidth>a.h.maxBandwidth&&(h.J=!1);a.h.minBandwidth&&h.bandwidth<a.h.minBandwidth&&(h.J=!1);l!=h.J&&(b=!0)}}0!=ub(a.b).length&&b&&(Xf(a),0<a.ma().length||
(b=Error("The application has restricted all video tracks!"),b.type="app",b=y(b),a.dispatchEvent(b)))}}k.ua=function(){return[]};k.ha=function(){return!1};k.mb=function(){return this.a?this.a.b:!1};
k.cb=function(a){for(var b,c=!1,d=new z,e=ub(this.b),f=0;f<e.length;++f)for(var g=e[f],h=0;h<g.m.length;++h){var l=g.m[h];l.f.forEach(function(a){d.push(a,l)})}for(b in a)if(e=gb[a[b]]||null,g=d.get(b))for(f=0;f<g.length;++f)l=g[f],h=l.N,l.N=!e,h!=l.N&&(c=!0);else Bb(b);c&&(Xf(this),b=this.pa(),a=this.ma(),b=this.b.a.hasOwnProperty("audio")&&0==b.length,a=this.b.a.hasOwnProperty("video")&&0==a.length,b||a)&&(a=Error("The key system has restricted all "+(b&&a?"audio and video tracks.":b?"audio tracks.":
"video tracks.")),a.type="drm",a=y(a),this.dispatchEvent(a))};function Xf(a){var b=x({type:"trackschanged",bubbles:!0});a.dispatchEvent(b)}function Wf(a,b,c,d,e){if(!a.b.a.hasOwnProperty(b)||!a.c[b])return!1;for(var f=a.b.get(b),g=0;g<f.length;++g)for(var h=f[g],l=0;l<h.m.length;++l){var m=h.m[l];if(m.C==c){if(!m.N||!m.J)return!1;if("text"!=b&&!a.Ra)return c=a.s[b],a.s[b]={Pa:m,Wa:null!=c&&c.Wa||d,Xa:null!=c&&c.Xa||e},!0;bf(a.U,m);a.c[b].ra(m,d,e);return!0}}return!1}
function Vf(a,b){for(var c=0;2>=c;++c)for(var d=0;d<b.length;++d){var e=b[d];if(jb(c,a.K,e.lang)){b.splice(d,1);b.splice(0,0,e);return}}for(d=0;d<b.length;++d)if(e=b[d],e.b){b.splice(d,1);b.splice(0,0,e);break}}k.yb=function(){this.i.sa(this.g,"sourceopen");Tf(this).then(F(this,function(){this.B&&this.B.resolve()})).catch(F(this,function(a){this.B&&this.B.reject(a)}))};
function Tf(a){for(var b=[],c=["audio","video","text"],d=0;d<c.length;++d){var e=c[d];a.b.a.hasOwnProperty(e)&&b.push(a.b.get(e)[0])}for(var f=Yf(a,b),d=0;d<c.length;++d)if(e=c[d],a.b.a.hasOwnProperty(e)&&!f[e])return a=Error("Unable to select an initial "+e+" stream: all "+e+" streams have been restricted (by the application or by the key system)."),a.type="stream",Promise.reject(a);b=ob(f).map(function(a){return a.I.create()});return Promise.all(b).then(F(a,function(a){if(!a.every(function(a){return a.length()}))return a=
Error("Some streams are not available."),a.type="stream",Promise.reject(a);a=Zf(this,a);if(!a)return a=Error("Some streams are not available."),a.type="stream",Promise.reject(a);if(!$f(this,f))return a=Error("Failed to create Stream objects."),a.type="stream",Promise.reject(a);this.G.start();ag(this,f,a);return Promise.resolve()})).catch(F(a,function(a){if("aborted"!=a.type)return Object.keys(this.c),this.a.b?(v()<this.a.h?(a=Math.max(this.a.h-Date.now()/1E3,3),this.V=window.setTimeout(this.gb.bind(this,
!0),1E3*a)):Uf(this,0),Promise.resolve()):Promise.reject(a)}))}function Yf(a,b){for(var c={},d=0;d<b.length;++d){var e=b[d],f=null;if("video"==e.contentType){var g=a.G.getInitialVideoTrackId();if(null==g)continue;f=e.m.filter(function(a){return a.C==g});if(0==f.length)continue;f=f[0]}else if("audio"==e.contentType){f=e.m.filter(function(a){return a.N&&a.J});if(0==f.length)continue;f=e.m[Math.floor(f.length/2)]}else 0<e.m.length&&(f=e.m[0]);c[e.contentType]=f}return c}
function $f(a,b){var c={},d;for(d in b){var e=b[d],e="text"==d?new Me(a,a.f):bg(a,e);if(!e)return ob(c).forEach(function(a){a.destroy()}),!1;c[d]=e}a.c=c;return!0}function bg(a,b){var c=new De(a,a.f,a.g,we(b),a.Z);c.F(a.F);return c}
function ag(a,b,c){a.Va=a.f.playbackRate;a.f.playbackRate=0;cg(a,c);var d;a.$&&a.$<=c.end&&a.$>=c.start?d=a.$:a.a.b?(d=c.end,a.Sa=!0):d=c.start;C(a.i,a.f,"seeking",a.Gb.bind(a));a.f.currentTime!=d&&(a.f.currentTime=d,a.D=d);dg(a,c.start,c.end);c=[];for(var e in a.c){d=a.c[e];c.push(d.sb(a.ea));C(a.i,d,"ended",a.Hb.bind(a));var f=b[e];bf(a.U,f);d.ra(f,!1)}Promise.all(c).then(a.tb.bind(a)).catch(F(a,function(a){"destroy"!=a.type&&(a=y(a),this.dispatchEvent(a))}));a.Na(a.fa)}
k.tb=function(a){ba(a&&a.length==Object.keys(this.c).length);for(var b=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,d=0;d<a.length;++d)var e=a[d],b=Math.min(b,e),c=Math.max(c,e);a=eg(this);for(d=0;d<a.length;++d)a[d].ka(c);fg(this,a,c);d=ub(this.b).map(function(a){return a.m}).reduce(function(a,b){return a.concat(b)},[]).map(function(a){var b=[a.I.create()];a.H&&b.push(a.H.create());return Promise.all(b)});Promise.all(d).then(F(this,function(a){for(var b=0;b<a.length;++b)a[b][0].ka(c);this.Ra=
!0;for(var d in this.s)a=this.s[d],b=this.c[d],bf(this.U,a.Pa),b.ra(a.Pa,a.Wa,a.Xa);this.s={}})).catch(F(this,function(a){"aborted"!=a.type&&(a=y(a),this.dispatchEvent(a))}))};function fg(a,b,c){if(b=Zf(a,b))cg(a,b),dg(a,b.start,b.end);0!=c&&(c=a.f.currentTime+c,a.f.currentTime=c,a.D=c);a.Sa&&b&&(a.f.currentTime=b.end);a.f.playbackRate=a.Va;a.a.b&&null!=a.a.f&&Uf(a,0);gg(a);a.ea.resolve()}
function cg(a,b){if(a.a.b)isNaN(a.g.duration)&&(a.g.duration=b.end+2592E3);else if(isNaN(a.g.duration)||b.end>a.g.duration){a.g.duration=b.end;for(var c=0;c<a.g.sourceBuffers.length;++c)a.g.sourceBuffers[c].appendWindowEnd=b.end}}k.Jb=function(){this.Y=null;gg(this);var a=Zf(this,eg(this));a&&(this.a.b&&this.Ta!=a.A&&(this.Ta=a.A,null!=this.w&&(window.clearTimeout(this.w),this.w=null)),dg(this,a.start,a.end),this.f.paused||hg(this,this.f.currentTime,a.start,a.end))};
function dg(a,b,c){b=x({type:"seekrangechanged",bubbles:!0,start:b,end:c});a.dispatchEvent(b)}k.Gb=function(){var a=this.f.currentTime;if(null!=this.D){if(a>=this.D-.01&&a<=this.D+.01){this.D=null;return}this.D=null}var b=Zf(this,eg(this));if(b){var c=b.end;(b=hg(this,a,b.start,c))||(a<=c+.01?b=!1:(this.f.currentTime=c,b=!0));if(!b)for(var d in this.c)this.c[d].jb()}};
function hg(a,b,c,d){if(b>=c-.01)return!1;b=0;if(a.a.b){b=.5;for(var e in a.c)if(!a.c[e].kb(c+b)){b=a.a.c;break}}a.f.currentTime=Math.min(c+b,d);return!0}k.Hb=function(){if(!this.a.b){for(var a in this.c)if(!this.c[a].Ga())return;this.Za()}};k.vb=function(){ob(this.c).every(function(a){return a.Ga()})&&(this.w=window.setTimeout(this.Za.bind(this),1E3*this.Ua))};k.ub=function(){null!=this.w&&(window.clearTimeout(this.w),this.w=null)};
k.Sb=function(){var a=this.U,b=this.Z.getBandwidth();a.estimatedBandwidth=b;a.bandwidthHistory.push(new df(b))};k.Za=function(){this.w=null;this.g.endOfStream()};function eg(a){return ob(a.c).map(function(a){return a.bb()}).filter(function(a){return null!=a})}
function Zf(a,b){for(var c=0,d=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,f=0;f<b.length;++f){var g=b[f].Ea(),c=Math.max(c,g.start);null!=g.end&&(d=Math.min(d,g.end));b[f].length()&&(e=Math.min(e,b[f].A().a))}if(d==Number.POSITIVE_INFINITY)if(d=a.a.a[0],d.b)d=(d.start||0)+d.b;else return null;a.a.b&&(d=Math.max(d-a.a.c,c));return c>d?null:{start:c,end:d,A:e}}function gg(a){a.a.b&&(a.Y=window.setTimeout(a.Jb.bind(a),1E3))}function Qf(a){for(var b in a.c)a.c[b].F(a.F)};function Y(a,b,c,d){c||(c=new Ab);d||(d=new W);X.call(this,null,c,d);this.za=a;this.l=null;this.M=b;this.R=[];this.ga=[];this.ta=[];this.j=null}q(Y,X);p("shaka.player.DashVideoSource",Y);Y.prototype.Aa=function(a,b,c){this.R.push(a);this.ga.push(b||"");this.ta.push(c||"")};Y.prototype.addExternalCaptions=Y.prototype.Aa;Y.prototype.xa=function(a){this.j=a};Y.prototype.setNetworkCallback=Y.prototype.xa;Y.prototype.destroy=function(){this.l=this.j=this.M=null;X.prototype.destroy.call(this)};
Y.prototype.X=function(){var a=new G(this.j,[new H(this.za)]);return Qd(new Pd(a,this.da)).then(F(this,function(a){this.l=a;for(var c=0;c<this.R.length;c++){var d=a,e=this.R[c],f=this.ga[c],g=this.ta[c];if(0!==d.a.length){var h=new ed;h.contentType="text";h.lang=f||"en";h.c=!0;f=new hd;f.bandwidth=0;f.f=g||"text/vtt";f.u=[new H(e)];h.a.push(f);d.a[0].b.push(h);Ad(d.a[0])}}this.a=Qe(new Pe(this.M),a,this.j);return X.prototype.X.call(this)}))};
Y.prototype.fb=function(a){return Qd(new Pd(a,this.da)).then(F(this,function(a){this.l=a;a=Qe(new Pe(this.M),a,this.j);return Promise.resolve(a)}))};Y.prototype.eb=function(){var a=Qe(new Pe(this.M),this.l,this.j);return Promise.resolve(a)};function Z(a,b,c){b||(b=new Ab);c||(c=new W);X.call(this,null,b,c);this.R=a;this.M=[];this.timeoutMs=3E4;this.l={};this.j=this.ga=null}q(Z,X);p("shaka.player.OfflineVideoSource",Z);Z.prototype.T=function(a){null!=a.licenseRequestTimeout&&(this.l.licenseRequestTimeout=a.licenseRequestTimeout);null!=a.segmentRequestTimeout&&(this.l.segmentRequestTimeout=a.segmentRequestTimeout);X.prototype.T.call(this,a)};
p("shaka.player.OfflineVideoSource.retrieveGroupIds",function(){var a=new Qb,b=Hb(a).then(function(){return Rb(a)});b.then(function(){Jb(a)}).catch(function(){Jb(a)});return b});
Z.prototype.xa=function(a,b,c,d){var e,f=null,g={},h=[];a=new G(this.ga,[new H(a)]);return Qd(new Pd(a,this.da)).then(F(this,function(a){this.a=Qe(new Pe(c),a,this.ga);if(this.a.b)return a=Error("Unable to store live streams offline."),a.type="app",Promise.reject(a);this.T({preferredLanguage:b});return X.prototype.X.call(this)})).then(F(this,function(){var a=document.createElement("video");a.src=window.URL.createObjectURL(this.g);e=new U(null,a,this);null!=this.l.licenseRequestTimeout&&(e.w=Number(this.l.licenseRequestTimeout));
C(this.i,e,"sessionReady",this.ta.bind(this));C(this.i,e,"error",function(a){f=a});return e.initialize()})).then(F(this,function(){for(var a=ub(this.b),b=0;b<a.length;++b)for(var c=a[b],e=0;e<c.m.length;++e){var f=c.m[e];g[f.C]=f}return d()})).then(F(this,function(a){for(var b=0;b<a.length;++b){var c=a[b],d=g[c];if(d)h.push(d);else return Promise.reject(Error("Invalid stream ID chosen: "+c))}var e=["audio","video"];h=h.filter(function(a){return 0>e.indexOf(a.a.split("/")[0])?!1:!0});a=h.map(function(a){return a.H.create()});
return Promise.all(a)})).then(F(this,function(a){for(var b=h,c=[],d=0;d<b.length;++d)try{c[d]=this.g.addSourceBuffer(we(b[d]))}catch(e){}if(b.length!=c.length)a=Error("Error initializing streams."),a.type="storage",a=Promise.reject(a);else{for(d=0;d<a.length;++d)(b=a[d])&&c[d].appendBuffer(b);a=Promise.resolve()}return a})).then(F(this,function(){return qf(e,this.timeoutMs)})).then(F(this,function(){return f?Promise.reject(f):ig(this,h,e.a,this.a.a[0].b)})).then(F(this,function(a){this.R=a;return f?
(jg(this),Promise.reject(f)):Promise.resolve(a)}))};p("shaka.player.OfflineVideoSource.prototype.store",Z.prototype.xa);Z.prototype.Aa=function(a){this.ga=a};Z.prototype.setNetworkCallback=Z.prototype.Aa;Z.prototype.ta=function(a){this.M.push(a.detail.sessionId)};
function ig(a,b,c,d){var e=new ef(a.Z,a);null!=a.l.segmentRequestTimeout&&(e.b=Number(a.l.segmentRequestTimeout));return Hb(e).then(F(a,function(){return ff(e,b,this.M,d,c)})).then(function(a){Jb(e);return Promise.resolve(a)}).catch(function(a){Jb(e);return Promise.reject(a)})}
Z.prototype.X=function(){var a=new Qb,b,c;return Hb(a).then(F(this,function(){return Sb(a,this.R)})).then(F(this,function(d){var e=[];this.M=d.session_ids;b=d.duration;c={keySystem:d.key_system,distinctiveIdentifierRequired:d.distinctive_identifier,persistentStorageRequired:!0,audioRobustness:d.audio_robustness,videoRobustness:d.video_robustness,withCredentials:d.with_credentials,licenseServerUrl:d.license_server};for(var f=0;f<d.stream_ids.length;++f)e.push(Tb(a,d.stream_ids[f]));return Promise.all(e)})).then(F(this,
function(a){var e=b,f=c,g=new Ce;g.c=5;for(var h=new Be,l=0;l<a.length;++l){var m=a[l],n=new ue,t=new te(m.references),A=new Wd(null,m.init_segment);n.I=t;n.H=A;n.a=m.mime_type;n.b=m.codecs;n.N=!0;this.j&&(null!=this.j.licenseServerUrl&&(f.licenseServerUrl=this.j.licenseServerUrl),null!=this.j.withCredentials&&(f.withCredentials=this.j.withCredentials),f.licensePostProcessor=this.j.licensePostProcessor,f.licensePreProcessor=this.j.licensePreProcessor,f.serverCertificate=this.j.serverCertificate);
m=mc(f);t=new xe;t.m.push(n);t.a.push(m);t.contentType=n.a.split("/")[0];h.a.push(t);h.b=e}g.a.push(h);this.a=g;return X.prototype.X.call(this)})).then(function(){Jb(a);return Promise.resolve()}).catch(function(b){Jb(a);return Promise.reject(b)})};
Z.prototype.za=function(a,b){a&&(this.j={licenseServerUrl:a.licenseServerUrl,withCredentials:a.withCredentials,serverCertificate:a.serverCertificate,licensePreProcessor:a.licensePreProcessor,licensePostProcessor:a.licensePostProcessor});var c=null;return kg(this).catch(function(a){return b?(c=a,Promise.resolve()):Promise.reject(a)}).then(F(this,function(){return jg(this)})).then(function(){return Promise.resolve(c)})};Z.prototype.deleteGroup=Z.prototype.za;Z.prototype.ua=function(){return this.M};
Z.prototype.ha=function(){return!0};function jg(a){var b=new ef(null,null);return Hb(b).then(F(a,function(){return jf(b,this.R)})).then(function(){Jb(b);return Promise.resolve()}).catch(function(a){Jb(b);return Promise.reject(a)})}
function kg(a){var b=document.createElement("video");b.src=window.URL.createObjectURL(a.g);var c=new U(null,b,a);null!=a.l.licenseRequestTimeout&&(c.w=Number(a.l.licenseRequestTimeout));return a.X().then(function(){return c.initialize()}).then(F(a,function(){return qf(c,this.timeoutMs)})).then(function(){return rf(c)}).then(F(a,function(){c.destroy();this.destroy();return Promise.resolve()})).catch(F(a,function(a){c.destroy();this.destroy();return Promise.reject(a)}))};}.bind(g,this))();
if (typeof(module)!="undefined"&&module.exports)module.exports=g.shaka;
else if (typeof(define)!="undefined" && define.amd)define(function(){return g.shaka});
else this.shaka=g.shaka;
})();


},{}],545:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":547}],546:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":545,"./parser":547}],547:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],548:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],549:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":553}],550:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":549,"spotify-deferred":555}],551:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var SpotifyApi = global.SpotifyApi;
var useApiRequest = !!(SpotifyApi && SpotifyApi.api &&
    typeof SpotifyApi.api.request === 'function');

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * If SpotifyApi is loaded, use api requests to send messages to bridge
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  if (useApiRequest) {
    this._sendApiRequest(requestName, args, caller, this._handleResponse, this._handleError);
  } else {
    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  }
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Use old API to send messages to the bridge.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendApiRequest = function(requestName, args, caller, onSuccess, onError) {
  SpotifyApi.api.request(
      requestName,
      args,
      caller,
      onSuccess,
      onError
  );
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":549,"spotify-deferred":555}],552:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":549,"spotify-deferred":555}],553:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":555}],554:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":550,"./env/bootstrap.native.js":551,"./env/bootstrap.web.js":552,"./scripts/resolver":556,"cosmos-common-js":364}],555:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":569}],556:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":364}],557:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

for (var i = 0; i < digits.length; ++i) { invDigits[digits[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }

/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    var tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  for (var i = 0, r = []; i < data.length; ++i) { r.push(mapping[data[i]]); }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],558:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],559:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap = {};
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 *
 * @param {string} type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  _listenerMap[type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the 
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addEvent(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceEvent(type, listener);
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":558}],560:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],561:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":560,"./inherit":562}],562:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],563:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/src/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var anchor;

  var hashSplit = str.split('#');

  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format) {
  var _current = 0;

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent());
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent());
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(id, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type The uri type.
 * @param {Object} props The uri properties.
 */
function URI(type, props) {
  /**
   * The uri type.
   *
   * @type {string}
   */
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor) {
  return new URI(URI.Type.TRACK, {id: id, anchor: anchor});
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id) {
  return new URI(URI.Type.EPISODE, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/src/base62":557}],564:[function(require,module,exports){
'use strict';

var Range = require('spotify-range2');

/**
 * Get the needed operations for inserting items at a specific index.
 *
 * @param {Array} items Array of items to insert.
 * @param {number} index Index to insert the items at, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getInsertOperations(items, index) {
  return [{type: 'insert', index: index, values: items}];
}

/**
 * Get the needed operations for removing items from the specified indices.
 *
 * @param {Array.<number>} indices Array of indices relative to the list before
 *     the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getRemoveOperations(indices) {
  var ranges = Range.fromIndices(indices);

  var removed = 0;
  var operations = [];

  for (var r = 0, range; (range = ranges[r]); r++) {
    operations.push({type: 'remove', index: range.start - removed, length: range.length});
    removed += range.length;
  }

  return operations;
}

/**
 * Get the needed operations for moving items from a set of indices to a
 * target index.
 *
 * @param {Array.<number>} fromIndices Array of indices relative to the list
 *     before the operations.
 * @param {number} toIndex Index to move the items to, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getMoveOperations(fromIndices, toIndex) {

  // We're going through one range at a time, and when a range is moved down,
  // we need to decrease the start of the next range to account for the
  // range we moved down (since each operation is based on the result of
  // the previous operation).
  var movedAbove = 0;

  // The maximum index starts at the index we want to move to.
  // When operations are created to move ranges, this maximum index
  // is increased to always point to the bottom index of the moved
  // items. If five items are moved from far down up to the 'to' index,
  // the new maxIndex will be toIndex + 5.
  var maxIndex = toIndex;

  var ranges = Range.fromIndices(fromIndices);
  var r, range;
  var toRange;

  // Find any range that intersects with the 'to' index. Referred below as
  // the 'to' range. This range can't be split, so we need to move items to
  // positions above or below this range if it exists.
  for (r = 0; (range = ranges[r]); r++) {
    if (range.start <= toIndex && range.end >= toIndex) {
      toRange = range;
      break;
    }
  }

  var operations = [];

  for (r = 0; (range = ranges[r]); r++) {
    var length = range.length;
    var to;
    var from = range.start - movedAbove;

    // If the 'to' index is inside a range
    if (toRange) {

      // Range is above the 'to' range, so move it to right above that range.
      if (range.end < toRange.start) {
        from = range.start - movedAbove;
        to = toRange.start - length;
        movedAbove += length;

      // Range is the 'to' range, which means it will not move anywhere.
      } else if (range === toRange) {
        maxIndex = Math.max(maxIndex, range.end);
        continue;

      // Range is below the 'to' range, so move it to the maximum index
      // we've reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }

    // If the 'to' index is not inside a range
    } else {

      // Range is above the 'to' index, so move it to right above the maximum index.
      if (range.end < toIndex) {
        from = range.start - movedAbove;
        to = maxIndex - length;
        movedAbove += length;

      // Range is below the 'to' index, so move it to the maximum index we've
      // reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
    }

    operations.push({type: 'move', from: from, length: length, to: to});
  }

  return operations;
}

exports.getInsertOperations = getInsertOperations;
exports.getRemoveOperations = getRemoveOperations;
exports.getMoveOperations = getMoveOperations;

},{"spotify-range2":570}],565:[function(require,module,exports){
var player = require("./player");
var types = require("./types");
var play = require("./play");

exports.Play = play.Play;
exports.Player = player.Player;
exports.PlayerContext = types.Context;
exports.PlayOptions = types.PlayOptions;
exports.PlayerRestrictions = types.Restrictions;
exports.PlayerSuppressions = types.Suppressions;
exports.PlayerTrack = types.Track;
exports.PlayerContextPage = types.ContextPage;
exports.IndexPath = types.IndexPath;

},{"./play":566,"./player":567,"./types":568}],566:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');

/**
 * Play is exposed as Player.Play. It represents a prepared playback action.
 * Play objects are obtained from the preparePlay method on the Player; the
 * constructor is not a public API.
 *
 * Instantiating a Play object does not make a Cosmos request, the caller is
 * expected to make that call and pass in a promise of the result in the
 * createSessionPromise parameter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {Promise} createSessionPromise A promise of a Cosmos.Response for
 *     the call to sp://player/v2/xyz/session.
 * @param {Player} player The player that initiated the call.
 * @param {function()=Number} getTime Clock. Should usually return
 *     new Date().getTime()
 * @param {module:spotify-player/types.Context} The context that was passed
 *     to the preparePlay call.
 * @param {Cosmos.PlayOptions=} opt_options The options that were passed to
 *     the preparePlay call.
 */
function Play(resolver, createSessionPromise, player, getTime, context, opt_options) {
  if (!(this instanceof Play)) {
    return new Play(resolver, createSessionPromise, player, getTime, context, opt_options);
  }

  if (!resolver || !createSessionPromise || !player || !getTime || !context) {
    throw new TypeError('Missing parameters for Play');
  }

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {Promise}
   */
  this._createSessionPromise = createSessionPromise;

  /**
   * @type {Player}
   */
  this._player = player;

  /**
   * @type {function()=Number}
   */
  this._getTime = getTime;

  /**
   * @type {module:spotify-player/types.Context}
   */
  this._context = context;

  /**
   * @type {Cosmos.PlayOptions=}
   */
  this._opt_options = opt_options;
}

/**
 * @return Promise of the session URL
 */
Play.prototype._sessionUrl = function() {
  return this._createSessionPromise.then(function(response) {
    return response.getJSONBody().session;
  });
};

Play.prototype._createPlayRequest = function(sessionUrl) {
  var body = {
    logging_params: {
      command_initiated_time: this._getTime()
    }
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/play', null, body);
};

Play.prototype._createUpdateRequest = function(sessionUrl, body) {
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/update', null, body);
};

/**
 * Perform the playback action that this handle represents.
 *
 * It is legal to call play more than once, but the playback action is only
 * prefetched the first time. If subsequent preparation is required, a new
 * Play object should be obtained.
 */
Play.prototype.play = function(opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (this._createSessionPromise) {
    this._sessionUrl()
      .then(function(sessionUrl) {
        return nodefn.call(
          self._resolver.resolve.bind(self._resolver), self._createPlayRequest(sessionUrl));
      })
      .done(function() {
          opt_callback(null);
        }, function(error) {
          if (error.response && error.response.getStatusCode() === 404) {
            // The session has been invalidated. Try again without prefetching.
            self._createSessionPromise = null;
            self.play(opt_callback);
          } else {
            var wrappedError = new Error('Failed to prepare playback session: ' + error.message);
            wrappedError.cause = function() { return error; };
            opt_callback(wrappedError);
          }
        });
  } else {
    this._player.play(this._context, this._opt_options, opt_callback);
  }
};

Play.prototype._update = function(body, opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (!this._createSessionPromise) {
    return opt_callback(new Error('Cannot update invalidated Play'));
  }

  this._sessionUrl()
    .then(function(sessionUrl) {
      return nodefn.call(
        self._resolver.resolve.bind(self._resolver), self._createUpdateRequest(sessionUrl, body));
    })
    .done(function() {
        opt_callback(null);
      }, function(error) {
        var wrappedError = new Error('Failed to update playback session: ' + error.message);
        wrappedError.cause = function() { return error; };
        opt_callback(wrappedError);
      });
};

Play.prototype.updateContext = function(context, opt_callback) {
  this._update({ context: context }, opt_callback);
};

Play.prototype.updatePage = function(page, opt_callback) {
  this._update({ page: page }, opt_callback);
};

Play.prototype.updateTrack = function(track, opt_callback) {
  this._update({ track: track }, opt_callback);
};

Play.prototype.updateViewUri = function(view_uri, opt_callback) {
  this._update({ view_uri: view_uri }, opt_callback);
};

/**
 * Invalidate the handle. This will cause any ongoing prefetching work to be
 * cancelled. It is good if any holder of a handle calls this method as soon
 * as it knows that it is not interested in its play action anymore.
 *
 * It is illegal to call play after this has been called. Invalidating an
 * invalidated Play is a no-op.
 */
Play.prototype.invalidate = function(opt_callback) {
  if (!this._createSessionPromise) {
    // Already invalidated
    return;
  }

  opt_callback = opt_callback || function() {};

  var self = this;
  this._sessionUrl().done(function(sessionUrl) {
    var request = new cosmos.Request(
      cosmos.Action.DELETE, sessionUrl, null, null);
    self._resolver.resolve(request, function() {
      opt_callback(null);
    });
  }, function() {
    // Ignore errors
    opt_callback(null);
  });

  this._createSessionPromise = null;
};

exports.Play = Play;

},{"spotify-cosmos-api":554,"when/node":606}],567:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');
var play = require('./play');

var PLAYER_URI = 'sp://player/v2/';
var DEFAULT_PLAYER_ID = 'main';

/**
 * The object decribing the context for the playback
 * Can be used to pass viewUri or externalReferrer specific
 * for the play action.
 *
 * @typedef {Object} ContextConfig
 * @property {Cosmos.PlayerContext} context The context to play
 * @property {string=} opt_viewId Optional. Set to override the default viewUri
 * @property {string=} opt_externalReferrer Optional. Set to indicate that
 *      the playback is owne by external website/app.
 */

/**
 * Player is the main entry point to control music playback with cosmos.
 *
 * Player in itself isn't what deals with playback; it is merely an object
 * that controls playback and provides ability to observe the player state.
 * There can be more than one Player object at the same time, and they
 * will sync up as one would expect.
 *
 * In practice there will be at least one Player object per feature that
 * wants to control playback. The feature can choose to create one per view
 * or have only one object, it doesn't really matter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {String} viewUri The uri of the view that owns the playback.
 * @param {String} featureIdentifier The identifier of the feature that started
 *     playback. This is arguably the most important field of this class. It is
 *     used for logging messages, in particular EndSong and EndVideo. (In EndSong,
 *     it ends up in source_start / source_end.) It should be a short human
 *     readable name of the feature, for example "radio", "album", "playlist".
 *     Ideally, it should be the same for a given feature across platforms.
 *
 *     Each feature should have only one string constant that it passes in here.
 *     You must not pass lots of distinct values here; for instance do not send
 *     something that contains the username or artist identifier.
 * @param {String} featureVersion The version of the feature. It often makes sense to set
 *     this value to the version of the spm package, for instance "0.7.5".
 * @param {{playerId: string}} opt_options The additional parameters for the player.
 *  param {string} options.playerId Can be used to override the id of the player
 *      which will result in a different endpoint for the player requests.
 */
function Player(resolver, viewUri, featureIdentifier, featureVersion, opt_options) {
  if (!(this instanceof Player)) {
    return new Player(resolver, viewUri, featureIdentifier, featureVersion);
  }

  if (!resolver || !viewUri || !featureIdentifier || !featureVersion) {
    throw new TypeError('Missing parameters for Player');
  }

  this._getTime = opt_options && opt_options.getTime || function() {
    return new Date().getTime();
  };

  /**
   * @type {string}
   */
  this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

  /**
   * @type {string}
   */
  this._referrerIdentifier = opt_options && opt_options.referrerIdentifier;

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {string}
   */
  this._viewUri = viewUri;

  /**
   * @type {string}
   */
  this._featureId = featureIdentifier;

  /**
   * @type {string}
   */
  this._featureVersion = featureVersion;
}

/**
 * The actions that can be understood by the PlayerResolver
 * in Cosmos Router.
 */
Player.Actions = {
  PLAY: 'play',
  SESSION: 'session',
  STOP: 'stop',
  UPDATE: 'update',
  PAUSE: 'pause',
  RESUME: 'resume',
  SKIP_NEXT: 'skip_next',
  SKIP_PREV: 'skip_prev',
  SHUFFLE: 'set_shuffling_context',
  REPEAT_CONTEXT: 'set_repeating_context',
  REPEAT_TRACK: 'set_repeating_track',
  SEEK_TO: 'seek_to'
};

/**
 * Private helper method for play and preparePlay
 */
Player.prototype._playOrPrepare = function(action, context, opt_options, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  // Allow to not send the opt_options
  if (opt_options instanceof Function && !opt_callback) {
    opt_callback = opt_options;
    opt_options = null;
  }

  var params = {};
  params.context = context;
  params.play_origin = this._makePlayOrigin();
  params.options = opt_options;

  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * Plays the given context.
 * Since both options and callback are optional this method can
 * take from 1 to 3 arguments. if callback is specified, it has to be
 * the last argument:
 *
 *    player.play(myContext);
 *    player.play(myContext, myPlayOptions);
 *    player.play(myContext, function myCallback() {});
 *    player.play(myContext, myPlayOptions, function myCallback() {});
 *
 * @param {module:spotify-player/types.Context} context The context to play.
 * @param {Cosmos.PlayOptions=} opt_options Optional play options.
 * @param {function(Error, Cosmos.Response?)=} opt_callback Optional
 *    callback that will be executed after player request is resolved.
 *
 *    NOTE: The reponse in the callback only has information about the
 *    request itself (i.e. if it was resolved correctly). If you want to have
 *    information about currently playing context you should subscribe to
 *    player events or fetch the current state using. getContext.
 *
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.play = function(context, opt_options, opt_callback) {
  return this._playOrPrepare(Player.Actions.PLAY, context, opt_options, opt_callback);
};

/**
 * This method is like play, but it doesn't actually initiate playback, it
 * merely expresses intent that the user is rather likely going to do a play
 * action like this soon.
 *
 * @return {Player.Play} A handle that is used for actually performing the
 *     playback action. When the object will no longer be used, the user is
 *     responsible for calling invalidate on it, otherwise it will keep
 *     holding resources. As long as this object is not invalidated, the
 *     playback system will take that as a hint that it should try to prepare
 *     playback like this.
 */
Player.prototype.preparePlay = function(context, opt_options) {
  var sessionPromise = nodefn.call(
    this._playOrPrepare.bind(this), Player.Actions.SESSION, context, opt_options);

  return new play.Play(this._resolver, sessionPromise, this, this._getTime, context, opt_options);
};

/**
 * Stop the playback and clear the context.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.stop = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.STOP, opt_callback);
};

/**
 * Update the current context.
 *
 * @see https://short.spotify.net/0I for more detailed information on the
 *    implementation.
 *
 * @param {module:spotify-player/types.Context} context The context to update to.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.update = function(context, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  var params = { context: context };
  return this._sendRequestWithParams(Player.Actions.UPDATE, params, opt_callback);
};

/**
 * Resume the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.resume = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.RESUME, opt_callback);
};

/**
 * Pause the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.pause = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.PAUSE, opt_callback);
};

/**
 * Skip to the previous song.
 *
 * @param {Object=} opt_skip_options The object with the skip options
 *    like allow_seeking
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToPrevTrack = function(opt_skip_options, opt_callback) {
  if (arguments.length === 1) {
    // In order to keep backwards compatibility we still need to support
    // passing just the callback as the first parameter
    if (typeof opt_skip_options === 'function') {
      opt_callback = opt_skip_options;
      opt_skip_options = null;
    }
  }
  var params = {};
  if (opt_skip_options) {
    params.options = opt_skip_options;
  }
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, params, opt_callback);
};

/**
 * Skip to the next song.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToNextTrack = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.SKIP_NEXT, opt_callback);
};

/**
 * Skip backwards until it gets to the specified track. This method never skips
 * to the beginning of the current track. For that, use seekTo.
 *
 * @discussion If the reverse runs out of tracks or skipping becomes disallowed
 *    for some other reason, this method will give up when it can no longer
 *    continue. This means that calling this for MFT users will almost
 *    certainly be a bad idea.
 *
 *    The intended purpose of this method is to make it possible to implement
 *    a view of the current future/reverse and allow the user to skip in it.
 *
 *    This method will look at the track URI and the track's UID (if present)
 *    to determine when it has reached its goal.
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificPrevTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, { track: track }, opt_callback);
};

/**
 * Skip forwards until it gets to the specified track.
 *
 * @discussion See discussion for -skipToPreviousTrack:
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificNextTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, { track: track }, opt_callback);
};

/**
 * Deprecated alias for skipToPrevTrack
 */
Player.prototype.skipToPrev = Player.prototype.skipToPrevTrack;

/**
 * Deprecated alias for skipToNextTrack
 */
Player.prototype.skipToNext = Player.prototype.skipToNextTrack;

/**
 * Set the shuffle flag
 *
 * @param {boolean} isShuffling The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setShufflingContext = function(isShuffling, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SHUFFLE, isShuffling, opt_callback);
};

/**
 * Repeat the whole context
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingContext = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT, isRepeating, opt_callback);
};

/**
 * Repeat the single track
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingTrack = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK, isRepeating, opt_callback);
};

/**
 * Set the seek position. It should be set in seconds.
 *
 * @param {boolean} positionInMs Position to seek to in miliseconds.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.seekTo = function(positionInMs, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SEEK_TO, positionInMs, opt_callback);
};

/**
 * Gets the current player state as an opaque string that can later be used to restore the
 * current state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the snapshot is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.save = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Restores a state string that was previously saved by save().
 *
 * @param {string} state The state to restore.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.restore = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Gets the current player queue as an string that can later be modified to replace
 * the current queue.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the queue is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */

Player.prototype.getQueue = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Replace the player queue. The state will not replace the current one of the player if
 * the revision does not match the current revision of the player. This happens when
 * the player queue was changed elsewhere by the time it was received until it was set.
 * A response-status of 409 will inform about this situation.
 *
 * @param {string} state The queue-state to replace with.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setQueue = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Subscribe to queue changes. There will be an initial callback when subscribing.
 */
Player.prototype.subscribeToQueue = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/queue');
  return this._resolver.resolve(request, callback);
};

/**
 * Get the current player state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the state is available.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.getState = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.GET, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to the player events
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {RequestHandle} The subscription handle.
 *
 *    This object can be used to cancel the subscription
 *    by calling 'cancel()' on it:
 *
 *    var sub = player.subscribe(function(err, response) { });
 *    sub.cancel();
 */
Player.prototype.subscribe = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.SUB, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to player error events
 */
Player.prototype.onError = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/error');
  return this._resolver.resolve(request, callback);
};

Player.prototype._makePlayOrigin = function() {
  return {
    view_uri: this._viewUri,
    feature_identifier: this._featureId,
    feature_version: this._featureVersion,
    referrer_identifier: this._referrerIdentifier
  };
};

Player.prototype.getPlayerEndpointUri = function() {
  return PLAYER_URI + this._id;
};

Player.prototype.getPlayerEndpointUriWithParams = function(params) {
  params = params || {};

  var paramsArray = Object.keys(params).reduce(function(arr, key) {
    arr.push(key + '=' + encodeURIComponent(params[key]));
    return arr;
  }, []);

  if (paramsArray.length > 0) {
    return this.getPlayerEndpointUri() + '?' + paramsArray.join('&');
  } else {
    return this.getPlayerEndpointUri();
  }
};

/**
 * @private
 * Sends context-less request.
 *
 * @param {string} action The action to perform on the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithAction = function(action, opt_callback) {
  return this._sendRequestWithParams(action, null, opt_callback);
};

/**
 * @private
 * Sends the request that only expects the single value in the body.
 *
 * @param {string} action The action to perform on the player.
 * @param {*} paramValue The value to send to the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParam = function(action, paramValue, opt_callback) {
  var params = {
    value: paramValue
  };
  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * @private
 * Sends request with context and optional options.
 *
 * @param {string} action The action to perform on the player.
 * @param {Object?} params The context to play.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParams = function(action, params, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/' + action;
  var body = params || {};
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  var request = new cosmos.Request(
    cosmos.Action.POST, requestUri, null, body);
  return this._resolver.resolve(request, opt_callback);
};

exports.Player = Player;

},{"./play":566,"spotify-cosmos-api":554,"when/node":606}],568:[function(require,module,exports){
/**
 * A PlayerTrack represents a single track in a context.
 *
 * @typedef {Object}
 * @property {String} uri
 *    The URI of the track. This will be one of the Spotify URIs, such as
 *    spotify:track:GID or spotify:local:DATA.
 * @property {String} album_uri
 *    The URI of the album that the track appears on. This property must always
 *    be set if the track URI is set. This is a requirement so that functions
 *    like MFT rules and biased shuffle can operate without having to fetch
 *    additional metadata for each track.
 * @property {String} artist_uri
 *    The URI of the main artist of the track. This property must always be set
 *    if the track URI is set. This is a requirement so that functions like MFT
 *    rules and biased shuffle can operate without having to fetch additional
 *    metadata for each track.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 */
exports.Track;

/**
 * PlayerRestrictions is used to encapsulate limitations of a player or a
 * context. The caller can specify that restrictions should apply when playing a
 * given context (see PlayerContext.restrictions), and a player can notify that
 * restrictions (see PlayState.restrictions).
 *
 * @typedef {Object}
 * @property {Array.<String>} disallow_skipping_prev_reasons
 *    The reasons why skipping to the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_next_reasons
 *    The reasons why skipping to the next track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_prev_reasons
 *    The reasons why peeking at the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_next_reasons
 *    The reasons why peeking at the next track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_to_reasons
 *    The reasons why skipping to a specific track should be / is disallowed.
 * @property {Array.<String>} disallow_pausing_reasons
 *    The reasons why pausing playback should be / is disallowed.
 * @property {Array.<String>} disallow_resuming_reasons
 *    The reasons why resuming playback should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_context_reasons
 *    The reasons why toggling repeat context should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_track_reasons
 *    The reasons why toggling repeat track should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_shuffle_reasons
 *    The reasons why toggling shuffle should be / is disallowed.
 * @property {Array.<String>} disallow_seeking_reasons
 *    The reasons why seeking within a track should be / is disallowed.
 * @property {Array.<String>} disallow_muting_reasons
 *    The reasons why muting audio should be / is disallowed.
 */
exports.Restrictions;

/**
 * PlayerSuppressions are used to disable certain player rules while playing a
 * context. The caller can specify that suppressions should apply when playing a
 * context (see PlayerOptions.suppressions), and a player can notify those
 * suppressions (see PlayState.suppressions).
 *
 * @typedef {Object}
 * @property {Array.<String>} providers
 *    The provider identifiers of the rules that should be disabled.
 */
exports.Suppressions;

/**
 * An object representing the index of the track to play within a context.
 * In the simplest case there is only one page thus its index should be 0.
 *
 * @typedef {Object}
 * @property {Number} page The index of the page to find the track in.
 * @property {Number} track The index of the track in the page.
 */
exports.IndexPath;

/**
 * This structure holds options that should be applied to the player: they are
 * either specified at a global or per-context level. When they are specified
 * globally, finishing the current context or starting to play a new context
 * does not change the player options: specifying them at a context-level means
 * that the previous global setting will be restored when the player is asked to
 * play another context.
 *
 * @typedef {Object}
 * @property {Boolean} shuffling_context
 *    Specifies if the player should shuffle the context or not.
 * @property {Boolean} repeating_context
 *    Specifies if the player should repeat the context or not.
 * @property {Boolean} repeating_track
 *    Specifies if the player should repeat the current track or not.
 */
exports.PlayerOptions;

/**
 * Options for a specific playback request. This object can specify for instance
 * which track to play within the given context, where to seek within the track
 * etc.
 *
 * @typedef {Object}
 * @property {module:spotify-player/types.IndexPath} skip_to_index
 *    The index in the context to start playing from. It is possible to specify
 *    a page that is not yet loaded, in which case the page will be downloaded
 *    before playback starts. The context player state will indicate that the
 *    playback is delayed because of loading the page.
 * @property {Number} seek_to
 *    The number of milliseconds to seek into the track when starting to
 *    play it.
 * @property {Boolean} initially_paused
 *    When this property is set, the context player will load the context but
 *    will not start playing audio for the first track. The is_paused property
 *    is set in the context player state to indicate that playback is paused. To
 *    start playing the track, call the `resume` method on the context player.
 * @property {module:spotify-player/types.PlayerOptions} player_options_override
 *    Use this to temporarily override the player options for this play request
 *    only. This can for instance be used to implement shuffle play buttons that
 *    enable shuffling but only for this particular context.
 */
exports.PlayOptions;

/**
 * Allows the list of tracks that will be played to be split up into chunks.
 * Pages may loaded or unloaded: an unloaded page will be loaded by the player
 * when it needs more tracks to play.
 *
 * @typedef {Object}
 * @property {String} page_url
 *     The URL of this page. If this property is set to a valid URL, it will be
 *     used to fetch the tracks of the page. The URL must be something that is
 *     supported by the context page loader in use, e.g., Hermes endpoints or
 *     Spotify playlist URIs. In the latter case, the context page loader will
 *     trigger the loaded signal each time the underlying playlist changes. If
 *     the tracks for the (static) context page are already provided in the
 *     tracks property, the page is considered loaded and the URL can be left
 *     empty.
 * @property {String} next_page_url
 *     The URL of the next context page. When the context page is stored in a
 *     context, the next page URL will be used to automatically append new pages
 *     at the end of the pages (or the fallback page) array. The new page
 *     will have its page URL set according to the next page URL of the last
 *     page in the context. The context page loaded will be used at some point
 *     to fetch the tracks for the new page. When the new page is fetched from
 *     the backend, it can also have the next page URL set, and yet another page
 *     is added to the context.
 * @property {Array<module:spotify-player/types.Track>} tracks
 *     An optional array with the tracks of this context page. When the context
 *     page is not loaded, the property is not initialized, and a context page
 *     loader will be used to fetch a loaded version of the page. In a loaded
 *     page this property will be set to an array of tracks. Note that the array
 *     can be empty, which means that the page does not have any tracks. This is
 *     not the same as a page that is not loaded, which may or may not have
 *     tracks.
 */
exports.ContextPage;

/**
 * Describes a set of tracks to be played.
 *
 * @typedef {Object}
 * @property {String} entity_uri
 *    An optional Spotify URI that represents what this entire context contains.
 *    For established entities like playlist, album, artist, this should be their
 *    respective URIs. This can be used for inter-feature playback status
 *    indication.
 *
 *    For instance, when the search page starts to play an artist, it should
 *    provide the artist URI in this field. The playback status indication for
 *    that artist in the search result list should be set if the current context
 *    entity URI matches the artist URI. On the artist page, the artist play
 *    button should also look at the entity URI for playback indication.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 * @property {Array<module:spotify-player/types.ContextPage>} pages
 *    An array of context pages that contain the tracks that should be played
 *    for this context. The context pages may or may not be loaded when passing
 *    the context to the player for playback. Note that if the last context page
 *    has a next page URL, at some point a new context page will be added to the
 *    end of the array, for that page URL. This will happen when playback is
 *    nearing the end of the available context pages.
 * @property {Array<module:spotify-player/types.ContextPage>} fallback_pages
 *    A vector of context pages that contain the tracks that should be used as a
 *    fallback if some rule does not allow the tracks in the future to be
 *    played.  An example of this is the MFT rules, which has a number of
 *    restrictions of how many times a track and album can be played during a
 *    given time period.  Another example is the DMCA rules that is used for the
 *    radio feature. When a fallback track is picked from the fallback pages, it
 *    must be removed from the page, so that it is not used again later. The
 *    fallback track can be provided by the feature that starts playback or
 *    they will be populated by the player if they are needed and none are
 *    provided.
 * @property {module:spotify-player/types.Restricitions} restrictions
 *    The restrictons that should be applied to the player when playing tracks
 *    from the context, e.g., whether the user is allowed to skip backward and
 *    forward in the context or enable shuffling and repeating. Note that the
 *    actual restrictions of the player at any given moment is decided not only
 *    by the context restrictions but also by the rules that are applied, e.g.,
 *    the MFT rules will always disable skipping backward, and will disable
 *    skipping forward as well when the user has reached the maximum number of
 *    skips allowed per time period.
 */
exports.Context;

},{}],569:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],570:[function(require,module,exports){
/**
 * @module spotify-range2
 */'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime(/** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function(start, end) {
    if (start != null) this.start = start;
    if (end != null) this.end = end;
    if (this.start == null || this.end == null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function(range) {
    if (!range) return false;
    return (this.start <= range.start && this.end >= range.end);
  },

  /** Range is contained by ranges. */
  contained: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    if (!ranges) return false;

    for (var i = 0; (range = ranges[i]); i++) {
      if (range.start <= this.start && range.end >= this.end)
        return true;
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ?
        new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) :
        null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function(range) {
    var intersected = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function(range) {
    var subtracted = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) { // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) { // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) { // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else { // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
        ranges.splice(k, 1, next.copy());
      }

      if (newRange) {
        if (prev && prev.end === newRange.start) { // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
          ranges.splice(k, 1, newRange);
        }
      }

    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {

        ranges.splice(k, 1, next.copy());

      } else if (this.start > next.start && this.start < next.end) {

        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));

      } else {

        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));

      }

    }

    return this.merge(ranges);

  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;

    ranges = map(ranges, function(r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    for (var k = -1, l = ranges.length; k < l; k++) {

      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {

        if (!prev && next) {

          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }

        } else if (prev && next) {

          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            ranges.splice(k + 1, 0, between);
          }

        } else if (prev && !next) {

          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }

      }

    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) indices.push(i);
    return indices;
  },

  /** Range to a string */
  toString: function() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function(string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function(indices) {
  indices.sort(function(a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [], rstart, rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":571,"prime":584}],571:[function(require,module,exports){
arguments[4][375][0].apply(exports,arguments)
},{"../function/makeIterator_":573,"dup":375}],572:[function(require,module,exports){
arguments[4][381][0].apply(exports,arguments)
},{"dup":381}],573:[function(require,module,exports){
arguments[4][382][0].apply(exports,arguments)
},{"../object/deepMatches":579,"./identity":572,"./prop":574,"dup":382}],574:[function(require,module,exports){
arguments[4][383][0].apply(exports,arguments)
},{"dup":383}],575:[function(require,module,exports){
arguments[4][384][0].apply(exports,arguments)
},{"../object/mixIn":583,"dup":384}],576:[function(require,module,exports){
arguments[4][385][0].apply(exports,arguments)
},{"./isKind":577,"dup":385}],577:[function(require,module,exports){
arguments[4][386][0].apply(exports,arguments)
},{"./kindOf":578,"dup":386}],578:[function(require,module,exports){
arguments[4][388][0].apply(exports,arguments)
},{"dup":388}],579:[function(require,module,exports){
arguments[4][389][0].apply(exports,arguments)
},{"../lang/isArray":576,"./forOwn":581,"dup":389}],580:[function(require,module,exports){
arguments[4][390][0].apply(exports,arguments)
},{"./hasOwn":582,"dup":390}],581:[function(require,module,exports){
arguments[4][391][0].apply(exports,arguments)
},{"./forIn":580,"./hasOwn":582,"dup":391}],582:[function(require,module,exports){
arguments[4][392][0].apply(exports,arguments)
},{"dup":392}],583:[function(require,module,exports){
arguments[4][393][0].apply(exports,arguments)
},{"./forOwn":581,"dup":393}],584:[function(require,module,exports){
arguments[4][395][0].apply(exports,arguments)
},{"dup":395,"mout/lang/createObject":575,"mout/lang/kindOf":578,"mout/object/hasOwn":582,"mout/object/mixIn":583}],585:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],586:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":585,"_process":517,"inherits":404}],587:[function(require,module,exports){
/*
 * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate
 * TimeUUID based on dates for range selections.
 * @see http://www.ietf.org/rfc/rfc4122.txt
 **/

function UUIDjs() {
};

UUIDjs.maxFromBits = function(bits) {
  return Math.pow(2, bits);
};

UUIDjs.limitUI04 = UUIDjs.maxFromBits(4);
UUIDjs.limitUI06 = UUIDjs.maxFromBits(6);
UUIDjs.limitUI08 = UUIDjs.maxFromBits(8);
UUIDjs.limitUI12 = UUIDjs.maxFromBits(12);
UUIDjs.limitUI14 = UUIDjs.maxFromBits(14);
UUIDjs.limitUI16 = UUIDjs.maxFromBits(16);
UUIDjs.limitUI32 = UUIDjs.maxFromBits(32);
UUIDjs.limitUI40 = UUIDjs.maxFromBits(40);
UUIDjs.limitUI48 = UUIDjs.maxFromBits(48);

// Returns a random integer between min and max
// Using Math.round() will give you a non-uniform distribution!
// @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

UUIDjs.randomUI04 = function() {
  return getRandomInt(0, UUIDjs.limitUI04-1);
};
UUIDjs.randomUI06 = function() {
  return getRandomInt(0, UUIDjs.limitUI06-1);
};
UUIDjs.randomUI08 = function() {
  return getRandomInt(0, UUIDjs.limitUI08-1);
};
UUIDjs.randomUI12 = function() {
  return getRandomInt(0, UUIDjs.limitUI12-1);
};
UUIDjs.randomUI14 = function() {
  return getRandomInt(0, UUIDjs.limitUI14-1);
};
UUIDjs.randomUI16 = function() {
  return getRandomInt(0, UUIDjs.limitUI16-1);
};
UUIDjs.randomUI32 = function() {
  return getRandomInt(0, UUIDjs.limitUI32-1);
};
UUIDjs.randomUI40 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);
};
UUIDjs.randomUI48 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
};

UUIDjs.paddedString = function(string, length, z) {
  string = String(string);
  z = (!z) ? '0' : z;
  var i = length - string.length;
  for (; i > 0; i >>>= 1, z += z) {
    if (i & 1) {
      string = z + string;
    }
  }
  return string;
};

UUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
  this.version = (timeHiAndVersion >> 12) & 0xF;
  this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)
             + '-'
             + UUIDjs.paddedString(timeMid.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)
             + UUIDjs.paddedString(clockSeqLow.toString(16), 2)
             + '-'
             + UUIDjs.paddedString(node.toString(16), 12);
  return this;
};

UUIDjs.prototype.toString = function() {
  return this.hex;
};
UUIDjs.prototype.toURN = function() {
  return 'urn:uuid:' + this.hex;
};

UUIDjs.prototype.toBytes = function() {
  var parts = this.hex.split('-');
  var ints = [];
  var intPos = 0;
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i].length; j+=2) {
      ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);
    }
  }
  return ints;
};

UUIDjs.prototype.equals = function(uuid) {
  if (!(uuid instanceof UUID)) {
    return false;
  }
  if (this.hex !== uuid.hex) {
    return false;
  }
  return true;
};

UUIDjs.getTimeFieldValues = function(time) {
  var ts = time - Date.UTC(1582, 9, 15);
  var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
  return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
};

UUIDjs._create4 = function() {
  return new UUIDjs().fromParts(
    UUIDjs.randomUI32(),
    UUIDjs.randomUI16(),
    0x4000 | UUIDjs.randomUI12(),
    0x80   | UUIDjs.randomUI06(),
    UUIDjs.randomUI08(),
    UUIDjs.randomUI48()
  );
};

UUIDjs._create1 = function() {
  var now = new Date().getTime();
  var sequence = UUIDjs.randomUI14();
  var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();
  var tick = UUIDjs.randomUI04();
  var timestamp = 0;
  var timestampRatio = 1/4;

  if (now != timestamp) {
    if (now < timestamp) {
      sequence++;
    }
    timestamp = now;
    tick = UUIDjs.randomUI04();
  } else if (Math.random() < timestampRatio && tick < 9984) {
    tick += 1 + UUIDjs.randomUI04();
  } else {
    sequence++;
  }

  var tf = UUIDjs.getTimeFieldValues(timestamp);
  var tl = tf.low + tick;
  var thav = (tf.hi & 0xFFF) | 0x1000;

  sequence &= 0x3FFF;
  var cshar = (sequence >>> 8) | 0x80;
  var csl = sequence & 0xFF;

  return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);
};

UUIDjs.create = function(version) {
  version = version || 4;
  return this['_create' + version]();
};

UUIDjs.fromTime = function(time, last) {
  last = (!last) ? false : last;
  var tf = UUIDjs.getTimeFieldValues(time);
  var tl = tf.low;
  var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'
  if (last === false) {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);
  } else {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);
  }
};

UUIDjs.firstFromTime = function(time) {
  return UUIDjs.fromTime(time, false);
};
UUIDjs.lastFromTime = function(time) {
  return UUIDjs.fromTime(time, true);
};

UUIDjs.fromURN = function(strId) {
  var r, p = /^(?:urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\})?$/i;
  if ((r = p.exec(strId))) {
    return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),
                            parseInt(r[3], 16), parseInt(r[4], 16),
                            parseInt(r[5], 16), parseInt(r[6], 16));
  }
  return null;
};

UUIDjs.fromBytes = function(ints) {
  if (ints.length < 5) {
    return null;
  }
  var str = '';
  var pos = 0;
  var parts = [4, 2, 2, 2, 6];
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i]; j++) {
      var octet = ints[pos++].toString(16);
      if (octet.length == 1) {
        octet = '0' + octet;
      }
      str += octet;
    }
    if (parts[i] !== 6) {
      str += '-';
    }
  }
  return UUIDjs.fromURN(str);
};

UUIDjs.fromBinary = function(binary) {
  var ints = [];
  for (var i = 0; i < binary.length; i++) {
    ints[i] = binary.charCodeAt(i);
    if (ints[i] > 255 || ints[i] < 0) {
      throw new Error('Unexpected byte in binary data.');
    }
  }
  return UUIDjs.fromBytes(ints);
};

// Aliases to support legacy code. Do not use these when writing new code as
// they may be removed in future versions!
UUIDjs.new = function() {
  return this.create(4);
};
UUIDjs.newTS = function() {
  return this.create(1);
};

module.exports = UUIDjs;

},{}],588:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":589,"./env":601,"./makePromise":604}],589:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],590:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],591:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],592:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			var h = Promise._handler(p);
			if(h.state() === 0) {
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			h._unreport();
			return state.inspect(h);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":591,"../state":605}],593:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],594:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],595:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":605}],596:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],597:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],598:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":590,"../env":601}],599:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":601,"../format":602}],600:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],601:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
		return (typeof MutationObserver === 'function' && MutationObserver) ||
			(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":517}],602:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],603:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],604:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
				return (function(noop, self, CustomEvent) {
					var hasCustomEvent = false;
					try {
						var ev = new CustomEvent('unhandledRejection');
						hasCustomEvent = ev instanceof CustomEvent;
					} catch (e) {}

					return !hasCustomEvent ? noop : function(type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(noop, self, CustomEvent));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":517}],605:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],606:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":591,"./lib/env":601,"./lib/liftAll":603,"./when":607}],607:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":588,"./lib/TimeoutError":590,"./lib/apply":591,"./lib/decorators/array":592,"./lib/decorators/flow":593,"./lib/decorators/fold":594,"./lib/decorators/inspect":595,"./lib/decorators/iterate":596,"./lib/decorators/progress":597,"./lib/decorators/timed":598,"./lib/decorators/unhandledRejection":599,"./lib/decorators/with":600}],608:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}]},{},[29]);
